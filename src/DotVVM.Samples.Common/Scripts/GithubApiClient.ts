namespace GithubApiClient {
    class ClientBase {
        public transformOptions(options: RequestInit) {
            options.credentials = "same-origin";
            return Promise.resolve(options);
        }
    }
    /* tslint:disable */
    //----------------------
    // <auto-generated>
    //     Generated using the NSwag toolchain v11.12.13.0 (NJsonSchema v9.10.14.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
    // </auto-generated>
    //----------------------
    // ReSharper disable InconsistentNaming
    
    export class Client extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getEmojis(accept?: string): Promise<Emojis> {
            let url_ = this.baseUrl + "/emojis";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetEmojis(_response);
            });
        }
    
        protected processGetEmojis(response: Response): Promise<Emojis> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Emojis.fromJS(resultData200) : new Emojis();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Emojis>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getEvents(accept?: string): Promise<Events> {
            let url_ = this.baseUrl + "/events";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetEvents(_response);
            });
        }
    
        protected processGetEvents(response: Response): Promise<Events> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Events>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getFeeds(accept?: string): Promise<Feeds> {
            let url_ = this.baseUrl + "/feeds";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetFeeds(_response);
            });
        }
    
        protected processGetFeeds(response: Response): Promise<Feeds> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Feeds.fromJS(resultData200) : new Feeds();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Feeds>(<any>null);
        }
    
        /**
         * @since (optional) Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
        Only gists updated at or after this time are returned.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getGistsAll(since?: string, accept?: string): Promise<Anonymous[]> {
            let url_ = this.baseUrl + "/gists?";
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetGistsAll(_response);
            });
        }
    
        protected processGetGistsAll(response: Response): Promise<Anonymous[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous[]>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postGists(body: PostGist, accept?: string): Promise<Gist> {
            let url_ = this.baseUrl + "/gists";
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostGists(_response);
            });
        }
    
        protected processPostGists(response: Response): Promise<Gist> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Gist.fromJS(resultData201) : new Gist();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Gist>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteGists(id: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/gists/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteGists(_response);
            });
        }
    
        protected processDeleteGists(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getGists(id: number, accept?: string): Promise<Gist> {
            let url_ = this.baseUrl + "/gists/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetGists(_response);
            });
        }
    
        protected processGetGists(response: Response): Promise<Gist> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Gist.fromJS(resultData200) : new Gist();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Gist>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchGists(id: number, body: PatchGist, accept?: string): Promise<Gist> {
            let url_ = this.baseUrl + "/gists/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchGists(_response);
            });
        }
    
        protected processPatchGists(response: Response): Promise<Gist> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Gist.fromJS(resultData200) : new Gist();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Gist>(<any>null);
        }
    
        /**
         * @filter Issues assigned to you / created by you / mentioning you / you're
        subscribed to updates for / All issues the authenticated user can see
         * @labels String list of comma separated Label names. Example - bug,ui,@high.
         * @since (optional) Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Only issues updated at or after this time are returned.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getIssues(filter: Filter, state: State, labels: string, sort: Sort, direction: Direction, since?: string, accept?: string): Promise<Anonymous2[]> {
            let url_ = this.baseUrl + "/issues?";
            if (filter === undefined || filter === null)
                throw new Error("The parameter 'filter' must be defined and cannot be null.");
            else
                url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
            if (state === undefined || state === null)
                throw new Error("The parameter 'state' must be defined and cannot be null.");
            else
                url_ += "state=" + encodeURIComponent("" + state) + "&"; 
            if (labels === undefined || labels === null)
                throw new Error("The parameter 'labels' must be defined and cannot be null.");
            else
                url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
            if (sort === undefined || sort === null)
                throw new Error("The parameter 'sort' must be defined and cannot be null.");
            else
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            if (direction === undefined || direction === null)
                throw new Error("The parameter 'direction' must be defined and cannot be null.");
            else
                url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetIssues(_response);
            });
        }
    
        protected processGetIssues(response: Response): Promise<Anonymous2[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous2.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous2[]>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        postMarkdown(body: Markdown, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/markdown";
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostMarkdown(_response);
            });
        }
    
        protected processPostMarkdown(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getMeta(accept?: string): Promise<Meta> {
            let url_ = this.baseUrl + "/meta";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetMeta(_response);
            });
        }
    
        protected processGetMeta(response: Response): Promise<Meta> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Meta.fromJS(resultData200) : new Meta();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Meta>(<any>null);
        }
    
        /**
         * @all (optional) True to show notifications marked as read.
         * @participating (optional) True to show only notifications in which the user is directly participating
        or mentioned.
         * @since (optional) The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Example: "2012-10-09T23:39:01Z".
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getNotifications(all?: boolean, participating?: boolean, since?: string, accept?: string): Promise<Notifications> {
            let url_ = this.baseUrl + "/notifications?";
            if (all !== undefined)
                url_ += "all=" + encodeURIComponent("" + all) + "&"; 
            if (participating !== undefined)
                url_ += "participating=" + encodeURIComponent("" + participating) + "&"; 
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetNotifications(_response);
            });
        }
    
        protected processGetNotifications(response: Response): Promise<Notifications> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Notifications.fromJS(resultData200) : new Notifications();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Notifications>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return Marked as read.
         */
        putNotifications(body: NotificationMarkRead, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/notifications";
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutNotifications(_response);
            });
        }
    
        protected processPutNotifications(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 205) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getOrgs(org: string, accept?: string): Promise<Organization> {
            let url_ = this.baseUrl + "/orgs/{org}";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetOrgs(_response);
            });
        }
    
        protected processGetOrgs(response: Response): Promise<Organization> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Organization.fromJS(resultData200) : new Organization();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Organization>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchOrgs(org: string, body: PatchOrg, accept?: string): Promise<Organization> {
            let url_ = this.baseUrl + "/orgs/{org}";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchOrgs(_response);
            });
        }
    
        protected processPatchOrgs(response: Response): Promise<Organization> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Organization.fromJS(resultData200) : new Organization();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Organization>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getRateLimit(accept?: string): Promise<Rate_limit> {
            let url_ = this.baseUrl + "/rate_limit";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetRateLimit(_response);
            });
        }
    
        protected processGetRateLimit(response: Response): Promise<Rate_limit> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Rate_limit.fromJS(resultData200) : new Rate_limit();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Rate_limit>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Item removed.
         */
        deleteRepos(owner: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteRepos(_response);
            });
        }
    
        protected processDeleteRepos(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getRepos(owner: string, repo: string, accept?: string): Promise<Repo> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetRepos(_response);
            });
        }
    
        protected processGetRepos(response: Response): Promise<Repo> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Repo.fromJS(resultData200) : new Repo();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Repo>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchRepos(owner: string, repo: string, body: RepoEdit, accept?: string): Promise<Repo> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchRepos(_response);
            });
        }
    
        protected processPatchRepos(response: Response): Promise<Repo> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Repo.fromJS(resultData200) : new Repo();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Repo>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @path Valid Git reference, defaults to 'master'.
         * @accept (optional) Is used to set specified media type.
         */
        getRepos2(owner: string, repo: string, archive_format: Archive_format, path: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/{archive_format}/{path}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (archive_format === undefined || archive_format === null)
                throw new Error("The parameter 'archive_format' must be defined.");
            url_ = url_.replace("{archive_format}", encodeURIComponent("" + archive_format)); 
            if (path === undefined || path === null)
                throw new Error("The parameter 'path' must be defined.");
            url_ = url_.replace("{path}", encodeURIComponent("" + path)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetRepos2(_response);
            });
        }
    
        protected processGetRepos2(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 302) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @since (optional) The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Example: "2012-10-09T23:39:01Z".
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getRepositories(since?: string, accept?: string): Promise<Anonymous3[]> {
            let url_ = this.baseUrl + "/repositories?";
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetRepositories(_response);
            });
        }
    
        protected processGetRepositories(response: Response): Promise<Anonymous3[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous3.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous3[]>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteTeams(teamId: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/teams/{teamId}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteTeams(_response);
            });
        }
    
        protected processDeleteTeams(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getTeams(teamId: number, accept?: string): Promise<Team> {
            let url_ = this.baseUrl + "/teams/{teamId}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetTeams(_response);
            });
        }
    
        protected processGetTeams(response: Response): Promise<Team> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Team.fromJS(resultData200) : new Team();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Team>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchTeams(teamId: number, body: EditTeam, accept?: string): Promise<Team> {
            let url_ = this.baseUrl + "/teams/{teamId}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchTeams(_response);
            });
        }
    
        protected processPatchTeams(response: Response): Promise<Team> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Team.fromJS(resultData200) : new Team();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Team>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getUser(accept?: string): Promise<User> {
            let url_ = this.baseUrl + "/user";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetUser(_response);
            });
        }
    
        protected processGetUser(response: Response): Promise<User> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? User.fromJS(resultData200) : new User();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<User>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchUser(body: UserUpdate, accept?: string): Promise<User> {
            let url_ = this.baseUrl + "/user";
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchUser(_response);
            });
        }
    
        protected processPatchUser(response: Response): Promise<User> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? User.fromJS(resultData200) : new User();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<User>(<any>null);
        }
    
        /**
         * @since (optional) The integer ID of the last User that you've seen.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getUsersAll(since?: number, accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/users?";
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetUsersAll(_response);
            });
        }
    
        protected processGetUsersAll(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getUsersAll2(username: string, accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/users/{username}";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetUsersAll2(_response);
            });
        }
    
        protected processGetUsersAll2(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    }
    
    export class GistsClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @since (optional) Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
        Only gists updated at or after this time are returned.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getPublic(since?: string, accept?: string): Promise<Anonymous[]> {
            let url_ = this.baseUrl + "/gists/public?";
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetPublic(_response);
            });
        }
    
        protected processGetPublic(response: Response): Promise<Anonymous[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous[]>(<any>null);
        }
    
        /**
         * @since (optional) Timestamp in ISO 8601 format YYYY-MM-DDTHH:MM:SSZ.
        Only gists updated at or after this time are returned.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getStarred(since?: string, accept?: string): Promise<Anonymous[]> {
            let url_ = this.baseUrl + "/gists/starred?";
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetStarred(_response);
            });
        }
    
        protected processGetStarred(response: Response): Promise<Anonymous[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous[]>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getCommentsAll(id: number, accept?: string): Promise<Anonymous5[]> {
            let url_ = this.baseUrl + "/gists/{id}/comments";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetCommentsAll(_response);
            });
        }
    
        protected processGetCommentsAll(response: Response): Promise<Anonymous5[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous5.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous5[]>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postComments(id: number, body: CommentBody, accept?: string): Promise<Comment> {
            let url_ = this.baseUrl + "/gists/{id}/comments";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostComments(_response);
            });
        }
    
        protected processPostComments(response: Response): Promise<Comment> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Comment.fromJS(resultData201) : new Comment();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Comment>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @commentId Id of comment.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteComments(id: number, commentId: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/gists/{id}/comments/{commentId}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteComments(_response);
            });
        }
    
        protected processDeleteComments(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @commentId Id of comment.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getComments(id: number, commentId: number, accept?: string): Promise<Comment> {
            let url_ = this.baseUrl + "/gists/{id}/comments/{commentId}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetComments(_response);
            });
        }
    
        protected processGetComments(response: Response): Promise<Comment> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Comment.fromJS(resultData200) : new Comment();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Comment>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @commentId Id of comment.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchComments(id: number, commentId: number, body: Comment, accept?: string): Promise<Comment> {
            let url_ = this.baseUrl + "/gists/{id}/comments/{commentId}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchComments(_response);
            });
        }
    
        protected processPatchComments(response: Response): Promise<Comment> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Comment.fromJS(resultData200) : new Comment();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Comment>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @accept (optional) Is used to set specified media type.
         * @return Exists.
         */
        postForks(id: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/gists/{id}/forks";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostForks(_response);
            });
        }
    
        protected processPostForks(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @accept (optional) Is used to set specified media type.
         * @return Item removed.
         */
        deleteStar(id: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/gists/{id}/star";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteStar(_response);
            });
        }
    
        protected processDeleteStar(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @accept (optional) Is used to set specified media type.
         * @return Exists.
         */
        getStar(id: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/gists/{id}/star";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetStar(_response);
            });
        }
    
        protected processGetStar(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @id Id of gist.
         * @accept (optional) Is used to set specified media type.
         * @return Starred.
         */
        putStar(id: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/gists/{id}/star";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutStar(_response);
            });
        }
    
        protected processPutStar(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    }
    
    export class GitignoreClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getTemplatesAll(accept?: string): Promise<any[]> {
            let url_ = this.baseUrl + "/gitignore/templates";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetTemplatesAll(_response);
            });
        }
    
        protected processGetTemplatesAll(response: Response): Promise<any[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<any[]>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getTemplates(language: string, accept?: string): Promise<GitignoreLang> {
            let url_ = this.baseUrl + "/gitignore/templates/{language}";
            if (language === undefined || language === null)
                throw new Error("The parameter 'language' must be defined.");
            url_ = url_.replace("{language}", encodeURIComponent("" + language)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetTemplates(_response);
            });
        }
    
        protected processGetTemplates(response: Response): Promise<GitignoreLang> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? GitignoreLang.fromJS(resultData200) : new GitignoreLang();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<GitignoreLang>(<any>null);
        }
    }
    
    export class LegacyClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @keyword The search term.
         * @state Indicates the state of the issues to return. Can be either open or closed.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        issuesGetSearch(keyword: string, state: State2, owner: string, repository: string, accept?: string): Promise<SearchIssuesByKeyword> {
            let url_ = this.baseUrl + "/legacy/issues/search/{owner}/{repository}/{state}/{keyword}";
            if (keyword === undefined || keyword === null)
                throw new Error("The parameter 'keyword' must be defined.");
            url_ = url_.replace("{keyword}", encodeURIComponent("" + keyword)); 
            if (state === undefined || state === null)
                throw new Error("The parameter 'state' must be defined.");
            url_ = url_.replace("{state}", encodeURIComponent("" + state)); 
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repository === undefined || repository === null)
                throw new Error("The parameter 'repository' must be defined.");
            url_ = url_.replace("{repository}", encodeURIComponent("" + repository)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesGetSearch(_response);
            });
        }
    
        protected processIssuesGetSearch(response: Response): Promise<SearchIssuesByKeyword> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SearchIssuesByKeyword.fromJS(resultData200) : new SearchIssuesByKeyword();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<SearchIssuesByKeyword>(<any>null);
        }
    
        /**
         * @keyword The search term
         * @order (optional) The sort field. if sort param is provided. Can be either asc or desc.
         * @language (optional) Filter results by language
         * @start_page (optional) The page number to fetch
         * @sort (optional) The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        reposGetSearch(keyword: string, order?: Order, language?: string, start_page?: string, sort?: Sort2, accept?: string): Promise<SearchRepositoriesByKeyword> {
            let url_ = this.baseUrl + "/legacy/repos/search/{keyword}?";
            if (keyword === undefined || keyword === null)
                throw new Error("The parameter 'keyword' must be defined.");
            url_ = url_.replace("{keyword}", encodeURIComponent("" + keyword)); 
            if (order !== undefined)
                url_ += "order=" + encodeURIComponent("" + order) + "&"; 
            if (language !== undefined)
                url_ += "language=" + encodeURIComponent("" + language) + "&"; 
            if (start_page !== undefined)
                url_ += "start_page=" + encodeURIComponent("" + start_page) + "&"; 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processReposGetSearch(_response);
            });
        }
    
        protected processReposGetSearch(response: Response): Promise<SearchRepositoriesByKeyword> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SearchRepositoriesByKeyword.fromJS(resultData200) : new SearchRepositoriesByKeyword();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<SearchRepositoriesByKeyword>(<any>null);
        }
    
        /**
         * @email The email address
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        userGetEmail(email: string, accept?: string): Promise<SearchUserByEmail> {
            let url_ = this.baseUrl + "/legacy/user/email/{email}";
            if (email === undefined || email === null)
                throw new Error("The parameter 'email' must be defined.");
            url_ = url_.replace("{email}", encodeURIComponent("" + email)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processUserGetEmail(_response);
            });
        }
    
        protected processUserGetEmail(response: Response): Promise<SearchUserByEmail> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SearchUserByEmail.fromJS(resultData200) : new SearchUserByEmail();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<SearchUserByEmail>(<any>null);
        }
    
        /**
         * @keyword The search term
         * @order (optional) The sort field. if sort param is provided. Can be either asc or desc.
         * @start_page (optional) The page number to fetch
         * @sort (optional) The sort field. One of stars, forks, or updated. Default: results are sorted by best match.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        userGetSearch(keyword: string, order?: Order2, start_page?: string, sort?: Sort3, accept?: string): Promise<SearchUsersByKeyword> {
            let url_ = this.baseUrl + "/legacy/user/search/{keyword}?";
            if (keyword === undefined || keyword === null)
                throw new Error("The parameter 'keyword' must be defined.");
            url_ = url_.replace("{keyword}", encodeURIComponent("" + keyword)); 
            if (order !== undefined)
                url_ += "order=" + encodeURIComponent("" + order) + "&"; 
            if (start_page !== undefined)
                url_ += "start_page=" + encodeURIComponent("" + start_page) + "&"; 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processUserGetSearch(_response);
            });
        }
    
        protected processUserGetSearch(response: Response): Promise<SearchUsersByKeyword> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SearchUsersByKeyword.fromJS(resultData200) : new SearchUsersByKeyword();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<SearchUsersByKeyword>(<any>null);
        }
    }
    
    export class MarkdownClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        postRaw(accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/markdown/raw";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "text/plain", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostRaw(_response);
            });
        }
    
        protected processPostRaw(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    }
    
    export class NetworksClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @owner Name of the owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getEvents(owner: string, repo: string, accept?: string): Promise<Events> {
            let url_ = this.baseUrl + "/networks/{owner}/{repo}/events";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetEvents(_response);
            });
        }
    
        protected processGetEvents(response: Response): Promise<Events> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Events>(<any>null);
        }
    }
    
    export class NotificationsClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @id Id of thread.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getThreads(id: number, accept?: string): Promise<Notifications> {
            let url_ = this.baseUrl + "/notifications/threads/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetThreads(_response);
            });
        }
    
        protected processGetThreads(response: Response): Promise<Notifications> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Notifications.fromJS(resultData200) : new Notifications();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Notifications>(<any>null);
        }
    
        /**
         * @id Id of thread.
         * @accept (optional) Is used to set specified media type.
         * @return Thread marked as read.
         */
        patchThreads(id: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/notifications/threads/{id}";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchThreads(_response);
            });
        }
    
        protected processPatchThreads(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 205) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @id Id of thread.
         * @accept (optional) Is used to set specified media type.
         * @return No Content
         */
        threadsDeleteSubscription(id: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/notifications/threads/{id}/subscription";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processThreadsDeleteSubscription(_response);
            });
        }
    
        protected processThreadsDeleteSubscription(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @id Id of thread.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        threadsGetSubscription(id: number, accept?: string): Promise<Subscription> {
            let url_ = this.baseUrl + "/notifications/threads/{id}/subscription";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processThreadsGetSubscription(_response);
            });
        }
    
        protected processThreadsGetSubscription(response: Response): Promise<Subscription> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Subscription>(<any>null);
        }
    
        /**
         * @id Id of thread.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        threadsPutSubscription(id: number, body: PutSubscription, accept?: string): Promise<Subscription> {
            let url_ = this.baseUrl + "/notifications/threads/{id}/subscription";
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processThreadsPutSubscription(_response);
            });
        }
    
        protected processThreadsPutSubscription(response: Response): Promise<Subscription> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Subscription.fromJS(resultData200) : new Subscription();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Subscription>(<any>null);
        }
    }
    
    export class OrgsClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @org Name of organisation.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getEvents(org: string, accept?: string): Promise<Events> {
            let url_ = this.baseUrl + "/orgs/{org}/events";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetEvents(_response);
            });
        }
    
        protected processGetEvents(response: Response): Promise<Events> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Events>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @filter Issues assigned to you / created by you / mentioning you / you're
        subscribed to updates for / All issues the authenticated user can see
         * @labels String list of comma separated Label names. Example - bug,ui,@high.
         * @since (optional) Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Only issues updated at or after this time are returned.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getIssues(org: string, filter: Filter2, state: State3, labels: string, sort: Sort4, direction: Direction2, since?: string, accept?: string): Promise<Anonymous2[]> {
            let url_ = this.baseUrl + "/orgs/{org}/issues?";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            if (filter === undefined || filter === null)
                throw new Error("The parameter 'filter' must be defined and cannot be null.");
            else
                url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
            if (state === undefined || state === null)
                throw new Error("The parameter 'state' must be defined and cannot be null.");
            else
                url_ += "state=" + encodeURIComponent("" + state) + "&"; 
            if (labels === undefined || labels === null)
                throw new Error("The parameter 'labels' must be defined and cannot be null.");
            else
                url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
            if (sort === undefined || sort === null)
                throw new Error("The parameter 'sort' must be defined and cannot be null.");
            else
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            if (direction === undefined || direction === null)
                throw new Error("The parameter 'direction' must be defined and cannot be null.");
            else
                url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetIssues(_response);
            });
        }
    
        protected processGetIssues(response: Response): Promise<Anonymous2[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous2.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous2[]>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getMembersAll(org: string, accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/orgs/{org}/members";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetMembersAll(_response);
            });
        }
    
        protected processGetMembersAll(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 302) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @username Name of the user.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteMembers(org: string, username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/orgs/{org}/members/{username}";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteMembers(_response);
            });
        }
    
        protected processDeleteMembers(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @username Name of the user.
         * @accept (optional) Is used to set specified media type.
         * @return No content. Response if requester is an organization member and user is a member
         */
        getMembers(org: string, username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/orgs/{org}/members/{username}";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetMembers(_response);
            });
        }
    
        protected processGetMembers(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 302) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getPublicMembersAll(org: string, accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/orgs/{org}/public_members";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetPublicMembersAll(_response);
            });
        }
    
        protected processGetPublicMembersAll(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @username Name of the user.
         * @accept (optional) Is used to set specified media type.
         * @return Concealed.
         */
        deletePublicMembers(org: string, username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/orgs/{org}/public_members/{username}";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeletePublicMembers(_response);
            });
        }
    
        protected processDeletePublicMembers(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @username Name of the user.
         * @accept (optional) Is used to set specified media type.
         * @return User is a public member.
         */
        getPublicMembers(org: string, username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/orgs/{org}/public_members/{username}";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetPublicMembers(_response);
            });
        }
    
        protected processGetPublicMembers(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @username Name of the user.
         * @accept (optional) Is used to set specified media type.
         * @return Publicized.
         */
        putPublicMembers(org: string, username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/orgs/{org}/public_members/{username}";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutPublicMembers(_response);
            });
        }
    
        protected processPutPublicMembers(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @type (optional) 
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getRepos(org: string, type?: Type, accept?: string): Promise<Anonymous6[]> {
            let url_ = this.baseUrl + "/orgs/{org}/repos?";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            if (type !== undefined)
                url_ += "type=" + encodeURIComponent("" + type) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetRepos(_response);
            });
        }
    
        protected processGetRepos(response: Response): Promise<Anonymous6[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous6.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous6[]>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postRepos(org: string, body: PostRepo, accept?: string): Promise<Anonymous6[]> {
            let url_ = this.baseUrl + "/orgs/{org}/repos";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostRepos(_response);
            });
        }
    
        protected processPostRepos(response: Response): Promise<Anonymous6[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData201 && resultData201.constructor === Array) {
                    result201 = [];
                    for (let item of resultData201)
                        result201.push(Anonymous6.fromJS(item));
                }
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous6[]>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getTeams(org: string, accept?: string): Promise<Anonymous7[]> {
            let url_ = this.baseUrl + "/orgs/{org}/teams";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetTeams(_response);
            });
        }
    
        protected processGetTeams(response: Response): Promise<Anonymous7[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous7.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous7[]>(<any>null);
        }
    
        /**
         * @org Name of organisation.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postTeams(org: string, body: OrgTeamsPost, accept?: string): Promise<Team> {
            let url_ = this.baseUrl + "/orgs/{org}/teams";
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostTeams(_response);
            });
        }
    
        protected processPostTeams(response: Response): Promise<Team> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Team.fromJS(resultData201) : new Team();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Team>(<any>null);
        }
    }
    
    export class ReposClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getAssigneesAll(owner: string, repo: string, accept?: string): Promise<Anonymous8[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/assignees";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetAssigneesAll(_response);
            });
        }
    
        protected processGetAssigneesAll(response: Response): Promise<Anonymous8[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous8.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous8[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @assignee Login of the assignee.
         * @accept (optional) Is used to set specified media type.
         * @return User is an assignee.
         */
        getAssignees(owner: string, repo: string, assignee: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/assignees/{assignee}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (assignee === undefined || assignee === null)
                throw new Error("The parameter 'assignee' must be defined.");
            url_ = url_.replace("{assignee}", encodeURIComponent("" + assignee)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetAssignees(_response);
            });
        }
    
        protected processGetAssignees(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getBranchesAll(owner: string, repo: string, accept?: string): Promise<Anonymous9[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/branches";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetBranchesAll(_response);
            });
        }
    
        protected processGetBranchesAll(response: Response): Promise<Anonymous9[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous9.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous9[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @branch Name of the branch.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getBranches(owner: string, repo: string, branch: string, accept?: string): Promise<Branch> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/branches/{branch}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (branch === undefined || branch === null)
                throw new Error("The parameter 'branch' must be defined.");
            url_ = url_.replace("{branch}", encodeURIComponent("" + branch)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetBranches(_response);
            });
        }
    
        protected processGetBranches(response: Response): Promise<Branch> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Branch.fromJS(resultData200) : new Branch();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Branch>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getCollaboratorsAll(owner: string, repo: string, accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetCollaboratorsAll(_response);
            });
        }
    
        protected processGetCollaboratorsAll(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @user Login of the user.
         * @accept (optional) Is used to set specified media type.
         * @return Collaborator removed.
         */
        deleteCollaborators(owner: string, repo: string, user: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators/{user}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (user === undefined || user === null)
                throw new Error("The parameter 'user' must be defined.");
            url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteCollaborators(_response);
            });
        }
    
        protected processDeleteCollaborators(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @user Login of the user.
         * @accept (optional) Is used to set specified media type.
         * @return User is a collaborator.
         */
        getCollaborators(owner: string, repo: string, user: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators/{user}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (user === undefined || user === null)
                throw new Error("The parameter 'user' must be defined.");
            url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetCollaborators(_response);
            });
        }
    
        protected processGetCollaborators(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @user Login of the user.
         * @accept (optional) Is used to set specified media type.
         * @return Collaborator added.
         */
        putCollaborators(owner: string, repo: string, user: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/collaborators/{user}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (user === undefined || user === null)
                throw new Error("The parameter 'user' must be defined.");
            url_ = url_.replace("{user}", encodeURIComponent("" + user)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutCollaborators(_response);
            });
        }
    
        protected processPutCollaborators(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getCommentsAll(owner: string, repo: string, accept?: string): Promise<Anonymous10[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetCommentsAll(_response);
            });
        }
    
        protected processGetCommentsAll(response: Response): Promise<Anonymous10[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous10.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous10[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @commentId Id of comment.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteComments(owner: string, repo: string, commentId: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments/{commentId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteComments(_response);
            });
        }
    
        protected processDeleteComments(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @commentId Id of comment.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getComments(owner: string, repo: string, commentId: number, accept?: string): Promise<CommitComments> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments/{commentId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetComments(_response);
            });
        }
    
        protected processGetComments(response: Response): Promise<CommitComments> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? CommitComments.fromJS(resultData200) : new CommitComments();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<CommitComments>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @commentId Id of comment.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchComments(owner: string, repo: string, commentId: number, body: CommentBody, accept?: string): Promise<CommitComments> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/comments/{commentId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchComments(_response);
            });
        }
    
        protected processPatchComments(response: Response): Promise<CommitComments> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? CommitComments.fromJS(resultData200) : new CommitComments();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<CommitComments>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @since (optional) The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Example: "2012-10-09T23:39:01Z".
         * @sha (optional) Sha or branch to start listing commits from.
         * @path (optional) Only commits containing this file path will be returned.
         * @author (optional) GitHub login, name, or email by which to filter by commit author.
         * @until (optional) ISO 8601 Date - Only commits before this date will be returned.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getCommitsAll(owner: string, repo: string, since?: string, sha?: string, path?: string, author?: string, until?: string, accept?: string): Promise<Anonymous11[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            if (sha !== undefined)
                url_ += "sha=" + encodeURIComponent("" + sha) + "&"; 
            if (path !== undefined)
                url_ += "path=" + encodeURIComponent("" + path) + "&"; 
            if (author !== undefined)
                url_ += "author=" + encodeURIComponent("" + author) + "&"; 
            if (until !== undefined)
                url_ += "until=" + encodeURIComponent("" + until) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetCommitsAll(_response);
            });
        }
    
        protected processGetCommitsAll(response: Response): Promise<Anonymous11[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous11.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous11[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        commitsGetStatus(owner: string, repo: string, ref: string, accept?: string): Promise<Anonymous12[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{ref}/status";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (ref === undefined || ref === null)
                throw new Error("The parameter 'ref' must be defined.");
            url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processCommitsGetStatus(_response);
            });
        }
    
        protected processCommitsGetStatus(response: Response): Promise<Anonymous12[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous12.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous12[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @shaCode SHA-1 code of the commit.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getCommits(owner: string, repo: string, shaCode: string, accept?: string): Promise<Commit> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{shaCode}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (shaCode === undefined || shaCode === null)
                throw new Error("The parameter 'shaCode' must be defined.");
            url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetCommits(_response);
            });
        }
    
        protected processGetCommits(response: Response): Promise<Commit> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Commit.fromJS(resultData200) : new Commit();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Commit>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @shaCode SHA-1 code of the commit.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        commitsGetComments(owner: string, repo: string, shaCode: string, accept?: string): Promise<Anonymous10[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{shaCode}/comments";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (shaCode === undefined || shaCode === null)
                throw new Error("The parameter 'shaCode' must be defined.");
            url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processCommitsGetComments(_response);
            });
        }
    
        protected processCommitsGetComments(response: Response): Promise<Anonymous10[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous10.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous10[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @shaCode SHA-1 code of the commit.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        commitsPostComments(owner: string, repo: string, shaCode: string, body: CommitBody, accept?: string): Promise<CommitComments> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/commits/{shaCode}/comments";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (shaCode === undefined || shaCode === null)
                throw new Error("The parameter 'shaCode' must be defined.");
            url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processCommitsPostComments(_response);
            });
        }
    
        protected processCommitsPostComments(response: Response): Promise<CommitComments> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? CommitComments.fromJS(resultData201) : new CommitComments();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<CommitComments>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getCompare(owner: string, repo: string, baseId: string, headId: string, accept?: string): Promise<CompareCommits> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/compare/{baseId}...{headId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (baseId === undefined || baseId === null)
                throw new Error("The parameter 'baseId' must be defined.");
            url_ = url_.replace("{baseId}", encodeURIComponent("" + baseId)); 
            if (headId === undefined || headId === null)
                throw new Error("The parameter 'headId' must be defined.");
            url_ = url_.replace("{headId}", encodeURIComponent("" + headId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetCompare(_response);
            });
        }
    
        protected processGetCompare(response: Response): Promise<CompareCommits> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? CompareCommits.fromJS(resultData200) : new CompareCommits();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<CompareCommits>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        deleteContents(owner: string, repo: string, path: string, body: DeleteFileBody, accept?: string): Promise<DeleteFile> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/contents/{path}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (path === undefined || path === null)
                throw new Error("The parameter 'path' must be defined.");
            url_ = url_.replace("{path}", encodeURIComponent("" + path)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteContents(_response);
            });
        }
    
        protected processDeleteContents(response: Response): Promise<DeleteFile> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? DeleteFile.fromJS(resultData200) : new DeleteFile();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<DeleteFile>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @pathQuery (optional) The content path.
         * @ref (optional) The String name of the Commit/Branch/Tag. Defaults to 'master'.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getContents(owner: string, repo: string, pathPath: string, pathQuery?: string, ref?: string, accept?: string): Promise<ContentsPath> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/contents/{path}?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (pathPath === undefined || pathPath === null)
                throw new Error("The parameter 'pathPath' must be defined.");
            url_ = url_.replace("{path}", encodeURIComponent("" + pathPath)); 
            if (pathQuery !== undefined)
                url_ += "path=" + encodeURIComponent("" + pathQuery) + "&"; 
            if (ref !== undefined)
                url_ += "ref=" + encodeURIComponent("" + ref) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetContents(_response);
            });
        }
    
        protected processGetContents(response: Response): Promise<ContentsPath> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ContentsPath.fromJS(resultData200) : new ContentsPath();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<ContentsPath>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        putContents(owner: string, repo: string, path: string, body: CreateFileBody, accept?: string): Promise<CreateFile> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/contents/{path}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (path === undefined || path === null)
                throw new Error("The parameter 'path' must be defined.");
            url_ = url_.replace("{path}", encodeURIComponent("" + path)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutContents(_response);
            });
        }
    
        protected processPutContents(response: Response): Promise<CreateFile> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? CreateFile.fromJS(resultData200) : new CreateFile();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<CreateFile>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @anon Set to 1 or true to include anonymous contributors in results.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getContributors(owner: string, repo: string, anon: string, accept?: string): Promise<Anonymous13[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/contributors?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (anon === undefined || anon === null)
                throw new Error("The parameter 'anon' must be defined and cannot be null.");
            else
                url_ += "anon=" + encodeURIComponent("" + anon) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetContributors(_response);
            });
        }
    
        protected processGetContributors(response: Response): Promise<Anonymous13[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous13.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous13[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getDeployments(owner: string, repo: string, accept?: string): Promise<Anonymous14[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetDeployments(_response);
            });
        }
    
        protected processGetDeployments(response: Response): Promise<Anonymous14[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous14.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous14[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postDeployments(owner: string, repo: string, body: Deployment, accept?: string): Promise<DeploymentResp> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostDeployments(_response);
            });
        }
    
        protected processPostDeployments(response: Response): Promise<DeploymentResp> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? DeploymentResp.fromJS(resultData201) : new DeploymentResp();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<DeploymentResp>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @id The Deployment ID to list the statuses from.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        deploymentsGetStatuses(owner: string, repo: string, id: number, accept?: string): Promise<Anonymous15[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments/{id}/statuses";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeploymentsGetStatuses(_response);
            });
        }
    
        protected processDeploymentsGetStatuses(response: Response): Promise<Anonymous15[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous15.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous15[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @id The Deployment ID to list the statuses from.
         * @accept (optional) Is used to set specified media type.
         * @return ok
         */
        deploymentsPostStatuses(owner: string, repo: string, id: number, body: DeploymentStatusesCreate, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/deployments/{id}/statuses";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeploymentsPostStatuses(_response);
            });
        }
    
        protected processDeploymentsPostStatuses(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getDownloads(owner: string, repo: string, accept?: string): Promise<Downloads> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/downloads";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetDownloads(_response);
            });
        }
    
        protected processGetDownloads(response: Response): Promise<Downloads> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Downloads.fromJS(resultData200) : new Downloads();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Downloads>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @downloadId Id of download.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteDownloads(owner: string, repo: string, downloadId: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/downloads/{downloadId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (downloadId === undefined || downloadId === null)
                throw new Error("The parameter 'downloadId' must be defined.");
            url_ = url_.replace("{downloadId}", encodeURIComponent("" + downloadId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteDownloads(_response);
            });
        }
    
        protected processDeleteDownloads(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @downloadId Id of download.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getDownloads2(owner: string, repo: string, downloadId: number, accept?: string): Promise<Downloads> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/downloads/{downloadId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (downloadId === undefined || downloadId === null)
                throw new Error("The parameter 'downloadId' must be defined.");
            url_ = url_.replace("{downloadId}", encodeURIComponent("" + downloadId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetDownloads2(_response);
            });
        }
    
        protected processGetDownloads2(response: Response): Promise<Downloads> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Downloads.fromJS(resultData200) : new Downloads();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Downloads>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getEvents(owner: string, repo: string, accept?: string): Promise<Events> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/events";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetEvents(_response);
            });
        }
    
        protected processGetEvents(response: Response): Promise<Events> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Events>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @sort (optional) 
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getForks(owner: string, repo: string, sort?: Sort5, accept?: string): Promise<Anonymous16[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/forks?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetForks(_response);
            });
        }
    
        protected processGetForks(response: Response): Promise<Anonymous16[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous16.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous16[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postForks(owner: string, repo: string, body: ForkBody, accept?: string): Promise<Fork> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/forks";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostForks(_response);
            });
        }
    
        protected processPostForks(response: Response): Promise<Fork> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Fork.fromJS(resultData201) : new Fork();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Fork>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        gitPostBlobs(owner: string, repo: string, body: Blob, accept?: string): Promise<Blobs> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/blobs";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitPostBlobs(_response);
            });
        }
    
        protected processGitPostBlobs(response: Response): Promise<Blobs> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Blobs.fromJS(resultData201) : new Blobs();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Blobs>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @shaCode SHA-1 code.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        gitGetBlobs(owner: string, repo: string, shaCode: string, accept?: string): Promise<Blob> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/blobs/{shaCode}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (shaCode === undefined || shaCode === null)
                throw new Error("The parameter 'shaCode' must be defined.");
            url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitGetBlobs(_response);
            });
        }
    
        protected processGitGetBlobs(response: Response): Promise<Blob> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Blob.fromJS(resultData200) : new Blob();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Blob>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        gitPostCommits(owner: string, repo: string, body: RepoCommitBody, accept?: string): Promise<GitCommit> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/commits";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitPostCommits(_response);
            });
        }
    
        protected processGitPostCommits(response: Response): Promise<GitCommit> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? GitCommit.fromJS(resultData201) : new GitCommit();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<GitCommit>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @shaCode SHA-1 code.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        gitGetCommits(owner: string, repo: string, shaCode: string, accept?: string): Promise<RepoCommit> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/commits/{shaCode}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (shaCode === undefined || shaCode === null)
                throw new Error("The parameter 'shaCode' must be defined.");
            url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitGetCommits(_response);
            });
        }
    
        protected processGitGetCommits(response: Response): Promise<RepoCommit> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? RepoCommit.fromJS(resultData200) : new RepoCommit();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<RepoCommit>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        gitGetRefsAll(owner: string, repo: string, accept?: string): Promise<Anonymous17[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitGetRefsAll(_response);
            });
        }
    
        protected processGitGetRefsAll(response: Response): Promise<Anonymous17[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous17.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous17[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        gitPostRefs(owner: string, repo: string, body: RefsBody, accept?: string): Promise<HeadBranch> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitPostRefs(_response);
            });
        }
    
        protected processGitPostRefs(response: Response): Promise<HeadBranch> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? HeadBranch.fromJS(resultData201) : new HeadBranch();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<HeadBranch>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return No Content
         */
        gitDeleteRefs(owner: string, repo: string, ref: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs/{ref}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (ref === undefined || ref === null)
                throw new Error("The parameter 'ref' must be defined.");
            url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitDeleteRefs(_response);
            });
        }
    
        protected processGitDeleteRefs(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        gitGetRefs(owner: string, repo: string, ref: string, accept?: string): Promise<HeadBranch> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs/{ref}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (ref === undefined || ref === null)
                throw new Error("The parameter 'ref' must be defined.");
            url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitGetRefs(_response);
            });
        }
    
        protected processGitGetRefs(response: Response): Promise<HeadBranch> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? HeadBranch.fromJS(resultData200) : new HeadBranch();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<HeadBranch>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        gitPatchRefs(owner: string, repo: string, ref: string, body: GitRefPatch, accept?: string): Promise<HeadBranch> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/refs/{ref}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (ref === undefined || ref === null)
                throw new Error("The parameter 'ref' must be defined.");
            url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitPatchRefs(_response);
            });
        }
    
        protected processGitPatchRefs(response: Response): Promise<HeadBranch> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? HeadBranch.fromJS(resultData200) : new HeadBranch();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<HeadBranch>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        gitPostTags(owner: string, repo: string, body: Tag, accept?: string): Promise<Tags> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/tags";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitPostTags(_response);
            });
        }
    
        protected processGitPostTags(response: Response): Promise<Tags> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Tags.fromJS(resultData201) : new Tags();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Tags>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        gitGetTags(owner: string, repo: string, shaCode: string, accept?: string): Promise<Tag> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/tags/{shaCode}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (shaCode === undefined || shaCode === null)
                throw new Error("The parameter 'shaCode' must be defined.");
            url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitGetTags(_response);
            });
        }
    
        protected processGitGetTags(response: Response): Promise<Tag> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Tag.fromJS(resultData200) : new Tag();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Tag>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        gitPostTrees(owner: string, repo: string, body: Tree, accept?: string): Promise<Trees> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/trees";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitPostTrees(_response);
            });
        }
    
        protected processGitPostTrees(response: Response): Promise<Trees> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Trees.fromJS(resultData201) : new Trees();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Trees>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @shaCode Tree SHA.
         * @recursive (optional) Get a Tree Recursively. (0 or 1)
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        gitGetTrees(owner: string, repo: string, shaCode: string, recursive?: number, accept?: string): Promise<Tree> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/git/trees/{shaCode}?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (shaCode === undefined || shaCode === null)
                throw new Error("The parameter 'shaCode' must be defined.");
            url_ = url_.replace("{shaCode}", encodeURIComponent("" + shaCode)); 
            if (recursive !== undefined)
                url_ += "recursive=" + encodeURIComponent("" + recursive) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGitGetTrees(_response);
            });
        }
    
        protected processGitGetTrees(response: Response): Promise<Tree> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Tree.fromJS(resultData200) : new Tree();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Tree>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getHooksAll(owner: string, repo: string, accept?: string): Promise<Anonymous18[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetHooksAll(_response);
            });
        }
    
        protected processGetHooksAll(response: Response): Promise<Anonymous18[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous18.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous18[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postHooks(owner: string, repo: string, body: HookBody, accept?: string): Promise<Anonymous18[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostHooks(_response);
            });
        }
    
        protected processPostHooks(response: Response): Promise<Anonymous18[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData201 && resultData201.constructor === Array) {
                    result201 = [];
                    for (let item of resultData201)
                        result201.push(Anonymous18.fromJS(item));
                }
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous18[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @hookId Id of hook.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteHooks(owner: string, repo: string, hookId: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (hookId === undefined || hookId === null)
                throw new Error("The parameter 'hookId' must be defined.");
            url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteHooks(_response);
            });
        }
    
        protected processDeleteHooks(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @hookId Id of hook.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getHooksAll2(owner: string, repo: string, hookId: number, accept?: string): Promise<Anonymous18[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (hookId === undefined || hookId === null)
                throw new Error("The parameter 'hookId' must be defined.");
            url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetHooksAll2(_response);
            });
        }
    
        protected processGetHooksAll2(response: Response): Promise<Anonymous18[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous18.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous18[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @hookId Id of hook.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchHooks(owner: string, repo: string, hookId: number, body: HookBody, accept?: string): Promise<Anonymous18[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (hookId === undefined || hookId === null)
                throw new Error("The parameter 'hookId' must be defined.");
            url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchHooks(_response);
            });
        }
    
        protected processPatchHooks(response: Response): Promise<Anonymous18[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous18.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous18[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @hookId Id of hook.
         * @accept (optional) Is used to set specified media type.
         * @return Hook is triggered.
         */
        hooksPostTests(owner: string, repo: string, hookId: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/hooks/{hookId}/tests";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (hookId === undefined || hookId === null)
                throw new Error("The parameter 'hookId' must be defined.");
            url_ = url_.replace("{hookId}", encodeURIComponent("" + hookId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processHooksPostTests(_response);
            });
        }
    
        protected processHooksPostTests(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @filter Issues assigned to you / created by you / mentioning you / you're
        subscribed to updates for / All issues the authenticated user can see
         * @labels String list of comma separated Label names. Example - bug,ui,@high.
         * @since (optional) Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Only issues updated at or after this time are returned.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getIssuesAll(owner: string, repo: string, filter: Filter3, state: State4, labels: string, sort: Sort6, direction: Direction3, since?: string, accept?: string): Promise<Anonymous2[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (filter === undefined || filter === null)
                throw new Error("The parameter 'filter' must be defined and cannot be null.");
            else
                url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
            if (state === undefined || state === null)
                throw new Error("The parameter 'state' must be defined and cannot be null.");
            else
                url_ += "state=" + encodeURIComponent("" + state) + "&"; 
            if (labels === undefined || labels === null)
                throw new Error("The parameter 'labels' must be defined and cannot be null.");
            else
                url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
            if (sort === undefined || sort === null)
                throw new Error("The parameter 'sort' must be defined and cannot be null.");
            else
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            if (direction === undefined || direction === null)
                throw new Error("The parameter 'direction' must be defined and cannot be null.");
            else
                url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetIssuesAll(_response);
            });
        }
    
        protected processGetIssuesAll(response: Response): Promise<Anonymous2[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous2.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous2[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postIssues(owner: string, repo: string, body: Issue, accept?: string): Promise<Issue> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostIssues(_response);
            });
        }
    
        protected processPostIssues(response: Response): Promise<Issue> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Issue.fromJS(resultData201) : new Issue();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Issue>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @direction (optional) Ignored without 'sort' parameter.
         * @sort (optional) 
         * @since (optional) The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Example: "2012-10-09T23:39:01Z".
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        issuesGetCommentsAll(owner: string, repo: string, direction?: string, sort?: Sort7, since?: string, accept?: string): Promise<Anonymous19[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (direction !== undefined)
                url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesGetCommentsAll(_response);
            });
        }
    
        protected processIssuesGetCommentsAll(response: Response): Promise<Anonymous19[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous19.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous19[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @commentId ID of comment.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        issuesDeleteComments(owner: string, repo: string, commentId: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments/{commentId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesDeleteComments(_response);
            });
        }
    
        protected processIssuesDeleteComments(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @commentId ID of comment.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        issuesGetComments(owner: string, repo: string, commentId: number, accept?: string): Promise<IssuesComment> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments/{commentId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesGetComments(_response);
            });
        }
    
        protected processIssuesGetComments(response: Response): Promise<IssuesComment> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? IssuesComment.fromJS(resultData200) : new IssuesComment();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<IssuesComment>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @commentId ID of comment.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        issuesPatchComments(owner: string, repo: string, commentId: number, body: CommentBody, accept?: string): Promise<IssuesComment> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/comments/{commentId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesPatchComments(_response);
            });
        }
    
        protected processIssuesPatchComments(response: Response): Promise<IssuesComment> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? IssuesComment.fromJS(resultData200) : new IssuesComment();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<IssuesComment>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        issuesGetEvents(owner: string, repo: string, accept?: string): Promise<Events> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/events";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesGetEvents(_response);
            });
        }
    
        protected processIssuesGetEvents(response: Response): Promise<Events> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Events>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @eventId Id of the event.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        issuesGetEvents2(owner: string, repo: string, eventId: number, accept?: string): Promise<Event> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/events/{eventId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (eventId === undefined || eventId === null)
                throw new Error("The parameter 'eventId' must be defined.");
            url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesGetEvents2(_response);
            });
        }
    
        protected processIssuesGetEvents2(response: Response): Promise<Event> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Event.fromJS(resultData200) : new Event();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Event>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of issue.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getIssues(owner: string, repo: string, number: number, accept?: string): Promise<Issue> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetIssues(_response);
            });
        }
    
        protected processGetIssues(response: Response): Promise<Issue> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Issue.fromJS(resultData200) : new Issue();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Issue>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of issue.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchIssues(owner: string, repo: string, number: number, body: Issue, accept?: string): Promise<Issue> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchIssues(_response);
            });
        }
    
        protected processPatchIssues(response: Response): Promise<Issue> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Issue.fromJS(resultData200) : new Issue();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Issue>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of issue.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        issuesGetCommentsAll2(owner: string, repo: string, number: number, accept?: string): Promise<Anonymous19[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/comments";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesGetCommentsAll2(_response);
            });
        }
    
        protected processIssuesGetCommentsAll2(response: Response): Promise<Anonymous19[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous19.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous19[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of issue.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        issuesPostComments(owner: string, repo: string, number: number, body: CommentBody, accept?: string): Promise<IssuesComment> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/comments";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesPostComments(_response);
            });
        }
    
        protected processIssuesPostComments(response: Response): Promise<IssuesComment> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? IssuesComment.fromJS(resultData201) : new IssuesComment();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<IssuesComment>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of issue.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        issuesGetEvents3(owner: string, repo: string, number: number, accept?: string): Promise<Events> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/events";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesGetEvents3(_response);
            });
        }
    
        protected processIssuesGetEvents3(response: Response): Promise<Events> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Events.fromJS(resultData200) : new Events();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Events>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of issue.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        issuesDeleteLabels(owner: string, repo: string, number: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesDeleteLabels(_response);
            });
        }
    
        protected processIssuesDeleteLabels(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of issue.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        issuesGetLabels(owner: string, repo: string, number: number, accept?: string): Promise<Anonymous20[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesGetLabels(_response);
            });
        }
    
        protected processIssuesGetLabels(response: Response): Promise<Anonymous20[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous20.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous20[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of issue.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        issuesPostLabels(owner: string, repo: string, number: number, body: string[], accept?: string): Promise<Label> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesPostLabels(_response);
            });
        }
    
        protected processIssuesPostLabels(response: Response): Promise<Label> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Label.fromJS(resultData201) : new Label();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Label>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of issue.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        issuesPutLabels(owner: string, repo: string, number: number, body: string[], accept?: string): Promise<Label> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesPutLabels(_response);
            });
        }
    
        protected processIssuesPutLabels(response: Response): Promise<Label> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Label.fromJS(resultData201) : new Label();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Label>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of issue.
         * @name Name of the label.
         * @accept (optional) Is used to set specified media type.
         * @return Item removed.
         */
        issuesDeleteLabels2(owner: string, repo: string, number: number, name: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/issues/{number}/labels/{name}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            if (name === undefined || name === null)
                throw new Error("The parameter 'name' must be defined.");
            url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processIssuesDeleteLabels2(_response);
            });
        }
    
        protected processIssuesDeleteLabels2(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getKeysAll(owner: string, repo: string, accept?: string): Promise<Anonymous21[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetKeysAll(_response);
            });
        }
    
        protected processGetKeysAll(response: Response): Promise<Anonymous21[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous21.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous21[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postKeys(owner: string, repo: string, body: UserKeysPost, accept?: string): Promise<UserKeysKeyId> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostKeys(_response);
            });
        }
    
        protected processPostKeys(response: Response): Promise<UserKeysKeyId> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? UserKeysKeyId.fromJS(resultData201) : new UserKeysKeyId();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<UserKeysKeyId>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @keyId Id of key.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteKeys(owner: string, repo: string, keyId: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys/{keyId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (keyId === undefined || keyId === null)
                throw new Error("The parameter 'keyId' must be defined.");
            url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteKeys(_response);
            });
        }
    
        protected processDeleteKeys(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @keyId Id of key.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getKeys(owner: string, repo: string, keyId: number, accept?: string): Promise<UserKeysKeyId> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/keys/{keyId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (keyId === undefined || keyId === null)
                throw new Error("The parameter 'keyId' must be defined.");
            url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetKeys(_response);
            });
        }
    
        protected processGetKeys(response: Response): Promise<UserKeysKeyId> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? UserKeysKeyId.fromJS(resultData200) : new UserKeysKeyId();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<UserKeysKeyId>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getLabelsAll(owner: string, repo: string, accept?: string): Promise<Anonymous20[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetLabelsAll(_response);
            });
        }
    
        protected processGetLabelsAll(response: Response): Promise<Anonymous20[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous20.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous20[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postLabels(owner: string, repo: string, body: string[], accept?: string): Promise<Label> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostLabels(_response);
            });
        }
    
        protected processPostLabels(response: Response): Promise<Label> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Label.fromJS(resultData201) : new Label();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Label>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @name Name of the label.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteLabels(owner: string, repo: string, name: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels/{name}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (name === undefined || name === null)
                throw new Error("The parameter 'name' must be defined.");
            url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteLabels(_response);
            });
        }
    
        protected processDeleteLabels(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @name Name of the label.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getLabels(owner: string, repo: string, name: string, accept?: string): Promise<Label> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels/{name}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (name === undefined || name === null)
                throw new Error("The parameter 'name' must be defined.");
            url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetLabels(_response);
            });
        }
    
        protected processGetLabels(response: Response): Promise<Label> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Label.fromJS(resultData200) : new Label();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Label>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @name Name of the label.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchLabels(owner: string, repo: string, name: string, body: string[], accept?: string): Promise<Label> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/labels/{name}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (name === undefined || name === null)
                throw new Error("The parameter 'name' must be defined.");
            url_ = url_.replace("{name}", encodeURIComponent("" + name)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchLabels(_response);
            });
        }
    
        protected processPatchLabels(response: Response): Promise<Label> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Label.fromJS(resultData200) : new Label();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Label>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getLanguages(owner: string, repo: string, accept?: string): Promise<{ [key: string] : number; }> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/languages";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetLanguages(_response);
            });
        }
    
        protected processGetLanguages(response: Response): Promise<{ [key: string] : number; }> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200) {
                    result200 = {};
                    for (let key in resultData200) {
                        if (resultData200.hasOwnProperty(key))
                            result200[key] = resultData200[key];
                    }
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<{ [key: string] : number; }>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Successful Response (The resulting merge commit)
         */
        postMerges(owner: string, repo: string, body: MergesBody, accept?: string): Promise<MergesSuccessful> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/merges";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostMerges(_response);
            });
        }
    
        protected processPostMerges(response: Response): Promise<MergesSuccessful> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? MergesSuccessful.fromJS(resultData201) : new MergesSuccessful();
                return result201;
                });
            } else if (status === 204) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = resultData404 ? MergesConflict.fromJS(resultData404) : new MergesConflict();
                return throwException("A server error occurred.", status, _responseText, _headers, result404);
                });
            } else if (status === 409) {
                return response.text().then((_responseText) => {
                let result409: any = null;
                let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result409 = resultData409 ? MergesConflict.fromJS(resultData409) : new MergesConflict();
                return throwException("A server error occurred.", status, _responseText, _headers, result409);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<MergesSuccessful>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @state (optional) String to filter by state.
         * @direction (optional) Ignored without 'sort' parameter.
         * @sort (optional) 
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getMilestones(owner: string, repo: string, state?: State5, direction?: string, sort?: Sort8, accept?: string): Promise<Milestone> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (state !== undefined)
                url_ += "state=" + encodeURIComponent("" + state) + "&"; 
            if (direction !== undefined)
                url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetMilestones(_response);
            });
        }
    
        protected processGetMilestones(response: Response): Promise<Milestone> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Milestone.fromJS(resultData200) : new Milestone();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Milestone>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postMilestones(owner: string, repo: string, body: MilestoneUpdate, accept?: string): Promise<Milestone> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostMilestones(_response);
            });
        }
    
        protected processPostMilestones(response: Response): Promise<Milestone> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Milestone.fromJS(resultData201) : new Milestone();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Milestone>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of milestone.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteMilestones(owner: string, repo: string, number: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteMilestones(_response);
            });
        }
    
        protected processDeleteMilestones(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of milestone.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getMilestones2(owner: string, repo: string, number: number, accept?: string): Promise<Milestone> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetMilestones2(_response);
            });
        }
    
        protected processGetMilestones2(response: Response): Promise<Milestone> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Milestone.fromJS(resultData200) : new Milestone();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Milestone>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of milestone.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchMilestones(owner: string, repo: string, number: number, body: MilestoneUpdate, accept?: string): Promise<Milestone> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchMilestones(_response);
            });
        }
    
        protected processPatchMilestones(response: Response): Promise<Milestone> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Milestone.fromJS(resultData200) : new Milestone();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Milestone>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Number of milestone.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        milestonesGetLabels(owner: string, repo: string, number: number, accept?: string): Promise<Anonymous20[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/milestones/{number}/labels";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processMilestonesGetLabels(_response);
            });
        }
    
        protected processMilestonesGetLabels(response: Response): Promise<Anonymous20[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous20.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous20[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @all (optional) True to show notifications marked as read.
         * @participating (optional) True to show only notifications in which the user is directly participating
        or mentioned.
         * @since (optional) The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Example: "2012-10-09T23:39:01Z".
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getNotifications(owner: string, repo: string, all?: boolean, participating?: boolean, since?: string, accept?: string): Promise<Notifications> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/notifications?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (all !== undefined)
                url_ += "all=" + encodeURIComponent("" + all) + "&"; 
            if (participating !== undefined)
                url_ += "participating=" + encodeURIComponent("" + participating) + "&"; 
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetNotifications(_response);
            });
        }
    
        protected processGetNotifications(response: Response): Promise<Notifications> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Notifications.fromJS(resultData200) : new Notifications();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Notifications>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Marked as read.
         */
        putNotifications(owner: string, repo: string, body: NotificationMarkRead, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/notifications";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutNotifications(_response);
            });
        }
    
        protected processPutNotifications(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 205) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @state (optional) String to filter by state.
         * @head (optional) Filter pulls by head user and branch name in the format of 'user:ref-name'.
        Example: github:new-script-format.
         * @base (optional) Filter pulls by base branch name. Example - gh-pages.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getPullsAll(owner: string, repo: string, state?: State6, head?: string, base?: string, accept?: string): Promise<Anonymous22[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (state !== undefined)
                url_ += "state=" + encodeURIComponent("" + state) + "&"; 
            if (head !== undefined)
                url_ += "head=" + encodeURIComponent("" + head) + "&"; 
            if (base !== undefined)
                url_ += "base=" + encodeURIComponent("" + base) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetPullsAll(_response);
            });
        }
    
        protected processGetPullsAll(response: Response): Promise<Anonymous22[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous22.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous22[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postPulls(owner: string, repo: string, body: PullsPost, accept?: string): Promise<Anonymous22[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostPulls(_response);
            });
        }
    
        protected processPostPulls(response: Response): Promise<Anonymous22[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData201 && resultData201.constructor === Array) {
                    result201 = [];
                    for (let item of resultData201)
                        result201.push(Anonymous22.fromJS(item));
                }
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous22[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @direction (optional) Ignored without 'sort' parameter.
         * @sort (optional) 
         * @since (optional) The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Example: "2012-10-09T23:39:01Z".
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        pullsGetCommentsAll(owner: string, repo: string, direction?: string, sort?: Sort9, since?: string, accept?: string): Promise<Anonymous19[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (direction !== undefined)
                url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPullsGetCommentsAll(_response);
            });
        }
    
        protected processPullsGetCommentsAll(response: Response): Promise<Anonymous19[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous19.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous19[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @commentId Id of comment.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        pullsDeleteComments(owner: string, repo: string, commentId: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments/{commentId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPullsDeleteComments(_response);
            });
        }
    
        protected processPullsDeleteComments(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @commentId Id of comment.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        pullsGetComments(owner: string, repo: string, commentId: number, accept?: string): Promise<PullsComment> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments/{commentId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPullsGetComments(_response);
            });
        }
    
        protected processPullsGetComments(response: Response): Promise<PullsComment> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PullsComment.fromJS(resultData200) : new PullsComment();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<PullsComment>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @commentId Id of comment.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        pullsPatchComments(owner: string, repo: string, commentId: number, body: CommentBody, accept?: string): Promise<PullsComment> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/comments/{commentId}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (commentId === undefined || commentId === null)
                throw new Error("The parameter 'commentId' must be defined.");
            url_ = url_.replace("{commentId}", encodeURIComponent("" + commentId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPullsPatchComments(_response);
            });
        }
    
        protected processPullsPatchComments(response: Response): Promise<PullsComment> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PullsComment.fromJS(resultData200) : new PullsComment();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<PullsComment>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Id of pull.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getPulls(owner: string, repo: string, number: number, accept?: string): Promise<PullRequest> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetPulls(_response);
            });
        }
    
        protected processGetPulls(response: Response): Promise<PullRequest> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PullRequest.fromJS(resultData200) : new PullRequest();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<PullRequest>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Id of pull.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchPulls(owner: string, repo: string, number: number, body: PullUpdate, accept?: string): Promise<Repo> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchPulls(_response);
            });
        }
    
        protected processPatchPulls(response: Response): Promise<Repo> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Repo.fromJS(resultData200) : new Repo();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Repo>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Id of pull.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        pullsGetComments2(owner: string, repo: string, number: number, accept?: string): Promise<PullsComment> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/comments";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPullsGetComments2(_response);
            });
        }
    
        protected processPullsGetComments2(response: Response): Promise<PullsComment> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? PullsComment.fromJS(resultData200) : new PullsComment();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<PullsComment>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Id of pull.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        pullsPostComments(owner: string, repo: string, number: number, body: PullsCommentPost, accept?: string): Promise<PullsComment> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/comments";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPullsPostComments(_response);
            });
        }
    
        protected processPullsPostComments(response: Response): Promise<PullsComment> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? PullsComment.fromJS(resultData201) : new PullsComment();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<PullsComment>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Id of pull.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        pullsGetCommits(owner: string, repo: string, number: number, accept?: string): Promise<Anonymous11[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/commits";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPullsGetCommits(_response);
            });
        }
    
        protected processPullsGetCommits(response: Response): Promise<Anonymous11[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous11.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous11[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Id of pull.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        pullsGetFiles(owner: string, repo: string, number: number, accept?: string): Promise<Anonymous22[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/files";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPullsGetFiles(_response);
            });
        }
    
        protected processPullsGetFiles(response: Response): Promise<Anonymous22[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous22.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous22[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Id of pull.
         * @accept (optional) Is used to set specified media type.
         * @return Pull request has been merged.
         */
        pullsGetMerge(owner: string, repo: string, number: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/merge";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPullsGetMerge(_response);
            });
        }
    
        protected processPullsGetMerge(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @number Id of pull.
         * @accept (optional) Is used to set specified media type.
         * @return Response if merge was successful.
         */
        pullsPutMerge(owner: string, repo: string, number: number, body: MergePullBody, accept?: string): Promise<Merge> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/pulls/{number}/merge";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (number === undefined || number === null)
                throw new Error("The parameter 'number' must be defined.");
            url_ = url_.replace("{number}", encodeURIComponent("" + number)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPullsPutMerge(_response);
            });
        }
    
        protected processPullsPutMerge(response: Response): Promise<Merge> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Merge.fromJS(resultData200) : new Merge();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 405) {
                return response.text().then((_responseText) => {
                let result405: any = null;
                let resultData405 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result405 = resultData405 ? Merge.fromJS(resultData405) : new Merge();
                return throwException("A server error occurred.", status, _responseText, _headers, result405);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Merge>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @ref (optional) The String name of the Commit/Branch/Tag. Defaults to master.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getReadme(owner: string, repo: string, ref?: string, accept?: string): Promise<ContentsPath> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/readme?";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (ref !== undefined)
                url_ += "ref=" + encodeURIComponent("" + ref) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetReadme(_response);
            });
        }
    
        protected processGetReadme(response: Response): Promise<ContentsPath> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ContentsPath.fromJS(resultData200) : new ContentsPath();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<ContentsPath>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getReleasesAll(owner: string, repo: string, accept?: string): Promise<Anonymous23[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetReleasesAll(_response);
            });
        }
    
        protected processGetReleasesAll(response: Response): Promise<Anonymous23[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous23.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous23[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postReleases(owner: string, repo: string, body: ReleaseCreate, accept?: string): Promise<Release> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostReleases(_response);
            });
        }
    
        protected processPostReleases(response: Response): Promise<Release> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? Release.fromJS(resultData201) : new Release();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Release>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return No Content
         */
        releasesDeleteAssets(owner: string, repo: string, id: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/assets/{id}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processReleasesDeleteAssets(_response);
            });
        }
    
        protected processReleasesDeleteAssets(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        releasesGetAssets(owner: string, repo: string, id: string, accept?: string): Promise<Asset> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/assets/{id}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processReleasesGetAssets(_response);
            });
        }
    
        protected processReleasesGetAssets(response: Response): Promise<Asset> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Asset.fromJS(resultData200) : new Asset();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Asset>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        releasesPatchAssets(owner: string, repo: string, id: string, body: AssetPatch, accept?: string): Promise<Asset> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/assets/{id}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processReleasesPatchAssets(_response);
            });
        }
    
        protected processReleasesPatchAssets(response: Response): Promise<Asset> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Asset.fromJS(resultData200) : new Asset();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Asset>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return No Content
         */
        deleteReleases(owner: string, repo: string, id: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteReleases(_response);
            });
        }
    
        protected processDeleteReleases(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getReleases(owner: string, repo: string, id: string, accept?: string): Promise<Release> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetReleases(_response);
            });
        }
    
        protected processGetReleases(response: Response): Promise<Release> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Release.fromJS(resultData200) : new Release();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Release>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        patchReleases(owner: string, repo: string, id: string, body: ReleaseCreate, accept?: string): Promise<Release> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PATCH",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPatchReleases(_response);
            });
        }
    
        protected processPatchReleases(response: Response): Promise<Release> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Release.fromJS(resultData200) : new Release();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Release>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        releasesGetAssetsAll(owner: string, repo: string, id: string, accept?: string): Promise<Anonymous24[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/releases/{id}/assets";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (id === undefined || id === null)
                throw new Error("The parameter 'id' must be defined.");
            url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processReleasesGetAssetsAll(_response);
            });
        }
    
        protected processReleasesGetAssetsAll(response: Response): Promise<Anonymous24[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous24.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous24[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getStargazers(owner: string, repo: string, accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/stargazers";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetStargazers(_response);
            });
        }
    
        protected processGetStargazers(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        statsGetCodeFrequency(owner: string, repo: string, accept?: string): Promise<number[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/code_frequency";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processStatsGetCodeFrequency(_response);
            });
        }
    
        protected processStatsGetCodeFrequency(response: Response): Promise<number[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<number[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        statsGetCommitActivity(owner: string, repo: string, accept?: string): Promise<Anonymous25[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/commit_activity";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processStatsGetCommitActivity(_response);
            });
        }
    
        protected processStatsGetCommitActivity(response: Response): Promise<Anonymous25[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous25.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous25[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        statsGetContributors(owner: string, repo: string, accept?: string): Promise<Anonymous26[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/contributors";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processStatsGetContributors(_response);
            });
        }
    
        protected processStatsGetContributors(response: Response): Promise<Anonymous26[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous26.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous26[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        statsGetParticipation(owner: string, repo: string, accept?: string): Promise<ParticipationStats> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/participation";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processStatsGetParticipation(_response);
            });
        }
    
        protected processStatsGetParticipation(response: Response): Promise<ParticipationStats> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? ParticipationStats.fromJS(resultData200) : new ParticipationStats();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<ParticipationStats>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        statsGetPunchCard(owner: string, repo: string, accept?: string): Promise<number[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/stats/punch_card";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processStatsGetPunchCard(_response);
            });
        }
    
        protected processStatsGetPunchCard(response: Response): Promise<number[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<number[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @ref Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getStatuses(owner: string, repo: string, ref: string, accept?: string): Promise<Anonymous27[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/statuses/{ref}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (ref === undefined || ref === null)
                throw new Error("The parameter 'ref' must be defined.");
            url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetStatuses(_response);
            });
        }
    
        protected processGetStatuses(response: Response): Promise<Anonymous27[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous27.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous27[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @ref Ref to list the statuses from. It can be a SHA, a branch name, or a tag name.
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postStatuses(owner: string, repo: string, ref: string, body: HeadBranch, accept?: string): Promise<Anonymous27[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/statuses/{ref}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            if (ref === undefined || ref === null)
                throw new Error("The parameter 'ref' must be defined.");
            url_ = url_.replace("{ref}", encodeURIComponent("" + ref)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostStatuses(_response);
            });
        }
    
        protected processPostStatuses(response: Response): Promise<Anonymous27[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData201 && resultData201.constructor === Array) {
                    result201 = [];
                    for (let item of resultData201)
                        result201.push(Anonymous27.fromJS(item));
                }
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous27[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getSubscribers(owner: string, repo: string, accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscribers";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetSubscribers(_response);
            });
        }
    
        protected processGetSubscribers(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteSubscription(owner: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscription";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteSubscription(_response);
            });
        }
    
        protected processDeleteSubscription(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getSubscription(owner: string, repo: string, accept?: string): Promise<Subscribition> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscription";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetSubscription(_response);
            });
        }
    
        protected processGetSubscription(response: Response): Promise<Subscribition> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Subscribition.fromJS(resultData200) : new Subscribition();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Subscribition>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        putSubscription(owner: string, repo: string, body: SubscribitionBody, accept?: string): Promise<Subscribition> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/subscription";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutSubscription(_response);
            });
        }
    
        protected processPutSubscription(response: Response): Promise<Subscribition> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Subscribition.fromJS(resultData200) : new Subscribition();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Subscribition>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getTags(owner: string, repo: string, accept?: string): Promise<Tags> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/tags";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetTags(_response);
            });
        }
    
        protected processGetTags(response: Response): Promise<Tags> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? Tags.fromJS(resultData200) : new Tags();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Tags>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getTeams(owner: string, repo: string, accept?: string): Promise<Anonymous7[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/teams";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetTeams(_response);
            });
        }
    
        protected processGetTeams(response: Response): Promise<Anonymous7[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous7.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous7[]>(<any>null);
        }
    
        /**
         * @owner Name of repository owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getWatchers(owner: string, repo: string, accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/repos/{owner}/{repo}/watchers";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetWatchers(_response);
            });
        }
    
        protected processGetWatchers(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    }
    
    export class SearchClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @q The search terms. This can be any combination of the supported code
        search parameters:
        'Search In' Qualifies which fields are searched. With this qualifier
        you can restrict the search to just the file contents, the file path,
        or both.
        'Languages' Searches code based on the language it's written in.
        'Forks' Filters repositories based on the number of forks, and/or
        whether code from forked repositories should be included in the results
        at all.
        'Size' Finds files that match a certain size (in bytes).
        'Path' Specifies the path that the resulting file must be at.
        'Extension' Matches files with a certain extension.
        'Users' or 'Repositories' Limits searches to a specific user or repository.
         * @order (optional) The sort field. if sort param is provided. Can be either asc or desc.
         * @sort (optional) Can only be 'indexed', which indicates how recently a file has been indexed
        by the GitHub search infrastructure. If not provided, results are sorted
        by best match.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getCode(q: string, order?: Order3, sort?: Sort10, accept?: string): Promise<SearchCode> {
            let url_ = this.baseUrl + "/search/code?";
            if (q === undefined || q === null)
                throw new Error("The parameter 'q' must be defined and cannot be null.");
            else
                url_ += "q=" + encodeURIComponent("" + q) + "&"; 
            if (order !== undefined)
                url_ += "order=" + encodeURIComponent("" + order) + "&"; 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetCode(_response);
            });
        }
    
        protected processGetCode(response: Response): Promise<SearchCode> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SearchCode.fromJS(resultData200) : new SearchCode();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<SearchCode>(<any>null);
        }
    
        /**
         * @q The q search term can also contain any combination of the supported issue search qualifiers:
         * @order (optional) The sort field. if sort param is provided. Can be either asc or desc.
         * @sort (optional) The sort field. Can be comments, created, or updated. Default: results are sorted by best match.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getIssues(q: string, order?: Order4, sort?: Sort11, accept?: string): Promise<SearchIssues> {
            let url_ = this.baseUrl + "/search/issues?";
            if (q === undefined || q === null)
                throw new Error("The parameter 'q' must be defined and cannot be null.");
            else
                url_ += "q=" + encodeURIComponent("" + q) + "&"; 
            if (order !== undefined)
                url_ += "order=" + encodeURIComponent("" + order) + "&"; 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetIssues(_response);
            });
        }
    
        protected processGetIssues(response: Response): Promise<SearchIssues> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SearchIssues.fromJS(resultData200) : new SearchIssues();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<SearchIssues>(<any>null);
        }
    
        /**
         * @q The search terms. This can be any combination of the supported repository
        search parameters:
        'Search In' Qualifies which fields are searched. With this qualifier you
        can restrict the search to just the repository name, description, readme,
        or any combination of these.
        'Size' Finds repositories that match a certain size (in kilobytes).
        'Forks' Filters repositories based on the number of forks, and/or whether
        forked repositories should be included in the results at all.
        'Created' and 'Last Updated' Filters repositories based on times of
        creation, or when they were last updated.
        'Users or Repositories' Limits searches to a specific user or repository.
        'Languages' Searches repositories based on the language they are written in.
        'Stars' Searches repositories based on the number of stars.
         * @order (optional) The sort field. if sort param is provided. Can be either asc or desc.
         * @sort (optional) If not provided, results are sorted by best match.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getRepositories(q: string, order?: Order5, sort?: Sort12, accept?: string): Promise<SearchRepositories> {
            let url_ = this.baseUrl + "/search/repositories?";
            if (q === undefined || q === null)
                throw new Error("The parameter 'q' must be defined and cannot be null.");
            else
                url_ += "q=" + encodeURIComponent("" + q) + "&"; 
            if (order !== undefined)
                url_ += "order=" + encodeURIComponent("" + order) + "&"; 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetRepositories(_response);
            });
        }
    
        protected processGetRepositories(response: Response): Promise<SearchRepositories> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SearchRepositories.fromJS(resultData200) : new SearchRepositories();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<SearchRepositories>(<any>null);
        }
    
        /**
         * @q The search terms. This can be any combination of the supported user
        search parameters:
        'Search In' Qualifies which fields are searched. With this qualifier you
        can restrict the search to just the username, public email, full name,
        location, or any combination of these.
        'Repository count' Filters users based on the number of repositories they
        have.
        'Location' Filter users by the location indicated in their profile.
        'Language' Search for users that have repositories that match a certain
        language.
        'Created' Filter users based on when they joined.
        'Followers' Filter users based on the number of followers they have.
         * @order (optional) The sort field. if sort param is provided. Can be either asc or desc.
         * @sort (optional) If not provided, results are sorted by best match.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getUsers(q: string, order?: Order6, sort?: Sort13, accept?: string): Promise<SearchUsers> {
            let url_ = this.baseUrl + "/search/users?";
            if (q === undefined || q === null)
                throw new Error("The parameter 'q' must be defined and cannot be null.");
            else
                url_ += "q=" + encodeURIComponent("" + q) + "&"; 
            if (order !== undefined)
                url_ += "order=" + encodeURIComponent("" + order) + "&"; 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetUsers(_response);
            });
        }
    
        protected processGetUsers(response: Response): Promise<SearchUsers> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? SearchUsers.fromJS(resultData200) : new SearchUsers();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<SearchUsers>(<any>null);
        }
    }
    
    export class TeamsClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @teamId Id of team.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getMembersAll(teamId: number, accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/teams/{teamId}/members";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetMembersAll(_response);
            });
        }
    
        protected processGetMembersAll(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @username Name of a member.
         * @accept (optional) Is used to set specified media type.
         * @return Team member removed.
         */
        deleteMembers(teamId: number, username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/teams/{teamId}/members/{username}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteMembers(_response);
            });
        }
    
        protected processDeleteMembers(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @username Name of a member.
         * @accept (optional) Is used to set specified media type.
         * @return User is a member.
         */
        getMembers(teamId: number, username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/teams/{teamId}/members/{username}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetMembers(_response);
            });
        }
    
        protected processGetMembers(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @username Name of a member.
         * @accept (optional) Is used to set specified media type.
         * @return Team member added.
         */
        putMembers(teamId: number, username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/teams/{teamId}/members/{username}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutMembers(_response);
            });
        }
    
        protected processPutMembers(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 422) {
                return response.text().then((_responseText) => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = resultData422 ? OrganizationAsTeamMember.fromJS(resultData422) : new OrganizationAsTeamMember();
                return throwException("A server error occurred.", status, _responseText, _headers, result422);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @username Name of a member.
         * @accept (optional) Is used to set specified media type.
         * @return Team member removed.
         */
        deleteMemberships(teamId: number, username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/teams/{teamId}/memberships/{username}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteMemberships(_response);
            });
        }
    
        protected processDeleteMemberships(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @username Name of a member.
         * @accept (optional) Is used to set specified media type.
         * @return User is a member.
         */
        getMemberships(teamId: number, username: string, accept?: string): Promise<TeamMembership> {
            let url_ = this.baseUrl + "/teams/{teamId}/memberships/{username}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetMemberships(_response);
            });
        }
    
        protected processGetMemberships(response: Response): Promise<TeamMembership> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? TeamMembership.fromJS(resultData200) : new TeamMembership();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<TeamMembership>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @username Name of a member.
         * @accept (optional) Is used to set specified media type.
         * @return Team member added.
         */
        putMemberships(teamId: number, username: string, accept?: string): Promise<TeamMembership> {
            let url_ = this.baseUrl + "/teams/{teamId}/memberships/{username}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutMemberships(_response);
            });
        }
    
        protected processPutMemberships(response: Response): Promise<TeamMembership> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? TeamMembership.fromJS(resultData200) : new TeamMembership();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 422) {
                return response.text().then((_responseText) => {
                let result422: any = null;
                let resultData422 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result422 = resultData422 ? OrganizationAsTeamMember.fromJS(resultData422) : new OrganizationAsTeamMember();
                return throwException("A server error occurred.", status, _responseText, _headers, result422);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<TeamMembership>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getReposAll(teamId: number, accept?: string): Promise<Anonymous28[]> {
            let url_ = this.baseUrl + "/teams/{teamId}/repos";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetReposAll(_response);
            });
        }
    
        protected processGetReposAll(response: Response): Promise<Anonymous28[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous28.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous28[]>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @org Name of a organization.
         * @repo Name of a repository.
         * @accept (optional) Is used to set specified media type.
         */
        putRepos(teamId: number, org: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/teams/{teamId}/repos/{org}/{repo}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutRepos(_response);
            });
        }
    
        protected processPutRepos(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @owner Name of a repository owner.
         * @repo Name of a repository.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteRepos(teamId: number, owner: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/teams/{teamId}/repos/{owner}/{repo}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteRepos(_response);
            });
        }
    
        protected processDeleteRepos(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @teamId Id of team.
         * @owner Name of a repository owner.
         * @repo Name of a repository.
         * @accept (optional) Is used to set specified media type.
         */
        getRepos(teamId: number, owner: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/teams/{teamId}/repos/{owner}/{repo}";
            if (teamId === undefined || teamId === null)
                throw new Error("The parameter 'teamId' must be defined.");
            url_ = url_.replace("{teamId}", encodeURIComponent("" + teamId)); 
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetRepos(_response);
            });
        }
    
        protected processGetRepos(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    }
    
    export class UserClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteEmails(body: string[], accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/emails";
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteEmails(_response);
            });
        }
    
        protected processDeleteEmails(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getEmails(accept?: string): Promise<string[]> {
            let url_ = this.baseUrl + "/user/emails";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetEmails(_response);
            });
        }
    
        protected processGetEmails(response: Response): Promise<string[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<string[]>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         */
        postEmails(body: string[], accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/emails";
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostEmails(_response);
            });
        }
    
        protected processPostEmails(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getFollowers(accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/user/followers";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetFollowers(_response);
            });
        }
    
        protected processGetFollowers(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getFollowingAll(accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/user/following";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetFollowingAll(_response);
            });
        }
    
        protected processGetFollowingAll(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         * @return User unfollowed.
         */
        deleteFollowing(username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/following/{username}";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteFollowing(_response);
            });
        }
    
        protected processDeleteFollowing(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         * @return Response if you are following this user.
         */
        getFollowing(username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/following/{username}";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetFollowing(_response);
            });
        }
    
        protected processGetFollowing(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         * @return You are now following the user.
         */
        putFollowing(username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/following/{username}";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutFollowing(_response);
            });
        }
    
        protected processPutFollowing(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @filter Issues assigned to you / created by you / mentioning you / you're
        subscribed to updates for / All issues the authenticated user can see
         * @labels String list of comma separated Label names. Example - bug,ui,@high.
         * @since (optional) Optional string of a timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Only issues updated at or after this time are returned.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getIssues(filter: Filter4, state: State7, labels: string, sort: Sort14, direction: Direction4, since?: string, accept?: string): Promise<Anonymous2[]> {
            let url_ = this.baseUrl + "/user/issues?";
            if (filter === undefined || filter === null)
                throw new Error("The parameter 'filter' must be defined and cannot be null.");
            else
                url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
            if (state === undefined || state === null)
                throw new Error("The parameter 'state' must be defined and cannot be null.");
            else
                url_ += "state=" + encodeURIComponent("" + state) + "&"; 
            if (labels === undefined || labels === null)
                throw new Error("The parameter 'labels' must be defined and cannot be null.");
            else
                url_ += "labels=" + encodeURIComponent("" + labels) + "&"; 
            if (sort === undefined || sort === null)
                throw new Error("The parameter 'sort' must be defined and cannot be null.");
            else
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            if (direction === undefined || direction === null)
                throw new Error("The parameter 'direction' must be defined and cannot be null.");
            else
                url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetIssues(_response);
            });
        }
    
        protected processGetIssues(response: Response): Promise<Anonymous2[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous2.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous2[]>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getKeysAll(accept?: string): Promise<any[]> {
            let url_ = this.baseUrl + "/user/keys";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetKeysAll(_response);
            });
        }
    
        protected processGetKeysAll(response: Response): Promise<any[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<any[]>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postKeys(body: UserKeysPost, accept?: string): Promise<UserKeysKeyId> {
            let url_ = this.baseUrl + "/user/keys";
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostKeys(_response);
            });
        }
    
        protected processPostKeys(response: Response): Promise<UserKeysKeyId> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result201 = resultData201 ? UserKeysKeyId.fromJS(resultData201) : new UserKeysKeyId();
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<UserKeysKeyId>(<any>null);
        }
    
        /**
         * @keyId ID of key.
         * @accept (optional) Is used to set specified media type.
         * @return No content.
         */
        deleteKeys(keyId: number, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/keys/{keyId}";
            if (keyId === undefined || keyId === null)
                throw new Error("The parameter 'keyId' must be defined.");
            url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteKeys(_response);
            });
        }
    
        protected processDeleteKeys(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @keyId ID of key.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getKeys(keyId: number, accept?: string): Promise<UserKeysKeyId> {
            let url_ = this.baseUrl + "/user/keys/{keyId}";
            if (keyId === undefined || keyId === null)
                throw new Error("The parameter 'keyId' must be defined.");
            url_ = url_.replace("{keyId}", encodeURIComponent("" + keyId)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetKeys(_response);
            });
        }
    
        protected processGetKeys(response: Response): Promise<UserKeysKeyId> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 ? UserKeysKeyId.fromJS(resultData200) : new UserKeysKeyId();
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<UserKeysKeyId>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getOrgs(accept?: string): Promise<any[]> {
            let url_ = this.baseUrl + "/user/orgs";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetOrgs(_response);
            });
        }
    
        protected processGetOrgs(response: Response): Promise<any[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<any[]>(<any>null);
        }
    
        /**
         * @type (optional) 
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getRepos(type?: Type2, accept?: string): Promise<Anonymous6[]> {
            let url_ = this.baseUrl + "/user/repos?";
            if (type !== undefined)
                url_ += "type=" + encodeURIComponent("" + type) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetRepos(_response);
            });
        }
    
        protected processGetRepos(response: Response): Promise<Anonymous6[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous6.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous6[]>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return Created
         */
        postRepos(body: PostRepo, accept?: string): Promise<Anonymous6[]> {
            let url_ = this.baseUrl + "/user/repos";
            url_ = url_.replace(/[?&]$/, "");
    
            const content_ = JSON.stringify(body);
    
            let options_ = <RequestInit>{
                body: content_,
                method: "POST",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPostRepos(_response);
            });
        }
    
        protected processPostRepos(response: Response): Promise<Anonymous6[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 201) {
                return response.text().then((_responseText) => {
                let result201: any = null;
                let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData201 && resultData201.constructor === Array) {
                    result201 = [];
                    for (let item of resultData201)
                        result201.push(Anonymous6.fromJS(item));
                }
                return result201;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous6[]>(<any>null);
        }
    
        /**
         * @direction (optional) Ignored without 'sort' parameter.
         * @sort (optional) 
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getStarredAll(direction?: string, sort?: Sort15, accept?: string): Promise<any[]> {
            let url_ = this.baseUrl + "/user/starred?";
            if (direction !== undefined)
                url_ += "direction=" + encodeURIComponent("" + direction) + "&"; 
            if (sort !== undefined)
                url_ += "sort=" + encodeURIComponent("" + sort) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetStarredAll(_response);
            });
        }
    
        protected processGetStarredAll(response: Response): Promise<any[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<any[]>(<any>null);
        }
    
        /**
         * @owner Name of a repository owner.
         * @repo Name of a repository.
         * @accept (optional) Is used to set specified media type.
         * @return Unstarred.
         */
        deleteStarred(owner: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/starred/{owner}/{repo}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteStarred(_response);
            });
        }
    
        protected processDeleteStarred(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of a repository owner.
         * @repo Name of a repository.
         * @accept (optional) Is used to set specified media type.
         * @return This repository is starred by you.
         */
        getStarred(owner: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/starred/{owner}/{repo}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetStarred(_response);
            });
        }
    
        protected processGetStarred(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of a repository owner.
         * @repo Name of a repository.
         * @accept (optional) Is used to set specified media type.
         * @return Repository starred.
         */
        putStarred(owner: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/starred/{owner}/{repo}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutStarred(_response);
            });
        }
    
        protected processPutStarred(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getSubscriptionsAll(accept?: string): Promise<Anonymous29[]> {
            let url_ = this.baseUrl + "/user/subscriptions";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetSubscriptionsAll(_response);
            });
        }
    
        protected processGetSubscriptionsAll(response: Response): Promise<Anonymous29[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous29.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous29[]>(<any>null);
        }
    
        /**
         * @owner Name of the owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Unwatched.
         */
        deleteSubscriptions(owner: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/subscriptions/{owner}/{repo}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "DELETE",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processDeleteSubscriptions(_response);
            });
        }
    
        protected processDeleteSubscriptions(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of the owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Repository is watched by you.
         */
        getSubscriptions(owner: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/subscriptions/{owner}/{repo}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetSubscriptions(_response);
            });
        }
    
        protected processGetSubscriptions(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @owner Name of the owner.
         * @repo Name of repository.
         * @accept (optional) Is used to set specified media type.
         * @return Repository is watched.
         */
        putSubscriptions(owner: string, repo: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/user/subscriptions/{owner}/{repo}";
            if (owner === undefined || owner === null)
                throw new Error("The parameter 'owner' must be defined.");
            url_ = url_.replace("{owner}", encodeURIComponent("" + owner)); 
            if (repo === undefined || repo === null)
                throw new Error("The parameter 'repo' must be defined.");
            url_ = url_.replace("{repo}", encodeURIComponent("" + repo)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "PUT",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processPutSubscriptions(_response);
            });
        }
    
        protected processPutSubscriptions(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getTeams(accept?: string): Promise<Anonymous30[]> {
            let url_ = this.baseUrl + "/user/teams";
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetTeams(_response);
            });
        }
    
        protected processGetTeams(response: Response): Promise<Anonymous30[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous30.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous30[]>(<any>null);
        }
    }
    
    export class UsersClient extends ClientBase {
        private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
        private baseUrl: string;
        protected jsonParseReviver: (key: string, value: any) => any = undefined;
    
        constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
            super();
            this.http = http ? http : <any>window;
            this.baseUrl = baseUrl ? baseUrl : "https://api.github.com";
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         */
        getEvents(username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/users/{username}/events";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetEvents(_response);
            });
        }
    
        protected processGetEvents(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         */
        eventsGetOrgs(username: string, org: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/users/{username}/events/orgs/{org}";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            if (org === undefined || org === null)
                throw new Error("The parameter 'org' must be defined.");
            url_ = url_.replace("{org}", encodeURIComponent("" + org)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processEventsGetOrgs(_response);
            });
        }
    
        protected processEventsGetOrgs(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getFollowers(username: string, accept?: string): Promise<Anonymous4[]> {
            let url_ = this.baseUrl + "/users/{username}/followers";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetFollowers(_response);
            });
        }
    
        protected processGetFollowers(response: Response): Promise<Anonymous4[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous4.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous4[]>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @targetUser Name of user.
         * @accept (optional) Is used to set specified media type.
         * @return Response if user follows target user.
         */
        getFollowing(username: string, targetUser: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/users/{username}/following/{targetUser}";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            if (targetUser === undefined || targetUser === null)
                throw new Error("The parameter 'targetUser' must be defined.");
            url_ = url_.replace("{targetUser}", encodeURIComponent("" + targetUser)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetFollowing(_response);
            });
        }
    
        protected processGetFollowing(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 204) {
                return response.text().then((_responseText) => {
                return;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status === 404) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @since (optional) The time should be passed in as UTC in the ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ.
        Example: "2012-10-09T23:39:01Z".
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getGists(username: string, since?: string, accept?: string): Promise<Anonymous[]> {
            let url_ = this.baseUrl + "/users/{username}/gists?";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            if (since !== undefined)
                url_ += "since=" + encodeURIComponent("" + since) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetGists(_response);
            });
        }
    
        protected processGetGists(response: Response): Promise<Anonymous[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous[]>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getKeys(username: string, accept?: string): Promise<any[]> {
            let url_ = this.baseUrl + "/users/{username}/keys";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetKeys(_response);
            });
        }
    
        protected processGetKeys(response: Response): Promise<any[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<any[]>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getOrgs(username: string, accept?: string): Promise<any[]> {
            let url_ = this.baseUrl + "/users/{username}/orgs";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetOrgs(_response);
            });
        }
    
        protected processGetOrgs(response: Response): Promise<any[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(item);
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<any[]>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         */
        getReceivedEvents(username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/users/{username}/received_events";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetReceivedEvents(_response);
            });
        }
    
        protected processGetReceivedEvents(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         */
        receivedEventsGetPublic(username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/users/{username}/received_events/public";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processReceivedEventsGetPublic(_response);
            });
        }
    
        protected processReceivedEventsGetPublic(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @type (optional) 
         * @accept (optional) Is used to set specified media type.
         * @return OK
         */
        getRepos(username: string, type?: Type3, accept?: string): Promise<Anonymous6[]> {
            let url_ = this.baseUrl + "/users/{username}/repos?";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            if (type !== undefined)
                url_ += "type=" + encodeURIComponent("" + type) + "&"; 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetRepos(_response);
            });
        }
    
        protected processGetRepos(response: Response): Promise<Anonymous6[]> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 200) {
                return response.text().then((_responseText) => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (resultData200 && resultData200.constructor === Array) {
                    result200 = [];
                    for (let item of resultData200)
                        result200.push(Anonymous6.fromJS(item));
                }
                return result200;
                });
            } else if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<Anonymous6[]>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         */
        getStarred(username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/users/{username}/starred";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetStarred(_response);
            });
        }
    
        protected processGetStarred(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    
        /**
         * @username Name of user.
         * @accept (optional) Is used to set specified media type.
         */
        getSubscriptions(username: string, accept?: string): Promise<void> {
            let url_ = this.baseUrl + "/users/{username}/subscriptions";
            if (username === undefined || username === null)
                throw new Error("The parameter 'username' must be defined.");
            url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
            url_ = url_.replace(/[?&]$/, "");
    
            let options_ = <RequestInit>{
                method: "GET",
                headers: new Headers({
                    "Accept": accept !== undefined && accept !== null ? "" + accept : "", 
                    "Content-Type": "application/json", 
                })
            };
    
            return this.transformOptions(options_).then(transformedOptions_ => {
                return this.http.fetch(url_, transformedOptions_);
            }).then((_response: Response) => {
                return this.processGetSubscriptions(_response);
            });
        }
    
        protected processGetSubscriptions(response: Response): Promise<void> {
            const status = response.status;
            let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v, k) => _headers[k] = v); };
            if (status === 403) {
                return response.text().then((_responseText) => {
                return throwException("A server error occurred.", status, _responseText, _headers);
                });
            } else if (status !== 200 && status !== 204) {
                return response.text().then((_responseText) => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
                });
            }
            return Promise.resolve<void>(<any>null);
        }
    }
    
    export class Asset implements IAsset {
        Content_type?: string;
        Created_at?: string;
        Download_count?: number;
        Id?: number;
        Label?: string;
        Name?: string;
        Size?: number;
        State?: string;
        Updated_at?: string;
        Uploader?: Uploader;
        Url?: string;
    
        constructor(data?: IAsset) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content_type = data["content_type"] !== undefined ? data["content_type"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Download_count = data["download_count"] !== undefined ? data["download_count"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Label = data["label"] !== undefined ? data["label"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Uploader = data["uploader"] ? Uploader.fromJS(data["uploader"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Asset {
            let result = new Asset();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content_type"] = this.Content_type !== undefined ? this.Content_type : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["download_count"] = this.Download_count !== undefined ? this.Download_count : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["label"] = this.Label !== undefined ? this.Label : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["uploader"] = this.Uploader ? this.Uploader.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAsset {
        Content_type?: string;
        Created_at?: string;
        Download_count?: number;
        Id?: number;
        Label?: string;
        Name?: string;
        Size?: number;
        State?: string;
        Updated_at?: string;
        Uploader?: Uploader;
        Url?: string;
    }
    
    export class AssetPatch implements IAssetPatch {
        Label?: string;
        Name: string;
    
        constructor(data?: IAssetPatch) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Label = data["label"] !== undefined ? data["label"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): AssetPatch {
            let result = new AssetPatch();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["label"] = this.Label !== undefined ? this.Label : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAssetPatch {
        Label?: string;
        Name: string;
    }
    
    export class Blob implements IBlob {
        Content?: string;
        Encoding?: BlobEncoding;
        Sha?: string;
        Size?: number;
    
        constructor(data?: IBlob) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content = data["content"] !== undefined ? data["content"] : <any>null;
                this.Encoding = data["encoding"] !== undefined ? data["encoding"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
            }
        }
    
        static fromJS(data: any): Blob {
            let result = new Blob();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content"] = this.Content !== undefined ? this.Content : <any>null;
            data["encoding"] = this.Encoding !== undefined ? this.Encoding : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            return data; 
        }
    }
    
    export interface IBlob {
        Content?: string;
        Encoding?: BlobEncoding;
        Sha?: string;
        Size?: number;
    }
    
    export class Blobs implements IBlobs {
        Sha?: string;
    
        constructor(data?: IBlobs) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
            }
        }
    
        static fromJS(data: any): Blobs {
            let result = new Blobs();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            return data; 
        }
    }
    
    export interface IBlobs {
        Sha?: string;
    }
    
    export class Branch implements IBranch {
        _links?: _links;
        Commit?: Commit2;
        Name?: string;
    
        constructor(data?: IBranch) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this._links = data["_links"] ? _links.fromJS(data["_links"]) : <any>null;
                this.Commit = data["commit"] ? Commit2.fromJS(data["commit"]) : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Branch {
            let result = new Branch();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["_links"] = this._links ? this._links.toJSON() : <any>null;
            data["commit"] = this.Commit ? this.Commit.toJSON() : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IBranch {
        _links?: _links;
        Commit?: Commit2;
        Name?: string;
    }
    
    export class Comment implements IComment {
        Body?: string;
    
        constructor(data?: IComment) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
            }
        }
    
        static fromJS(data: any): Comment {
            let result = new Comment();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            return data; 
        }
    }
    
    export interface IComment {
        Body?: string;
    }
    
    export class CommentBody implements ICommentBody {
        Body: string;
    
        constructor(data?: ICommentBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
            }
        }
    
        static fromJS(data: any): CommentBody {
            let result = new CommentBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            return data; 
        }
    }
    
    export interface ICommentBody {
        Body: string;
    }
    
    export class Commit implements ICommit {
        Author?: Author;
        Commit?: Commit3;
        Committer?: Committer;
        Files?: Files[];
        Parents?: Parents[];
        Sha?: string;
        Stats?: Stats;
        Url?: string;
    
        constructor(data?: ICommit) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author.fromJS(data["author"]) : <any>null;
                this.Commit = data["commit"] ? Commit3.fromJS(data["commit"]) : <any>null;
                this.Committer = data["committer"] ? Committer.fromJS(data["committer"]) : <any>null;
                if (data["files"] && data["files"].constructor === Array) {
                    this.Files = [];
                    for (let item of data["files"])
                        this.Files.push(Files.fromJS(item));
                }
                if (data["parents"] && data["parents"].constructor === Array) {
                    this.Parents = [];
                    for (let item of data["parents"])
                        this.Parents.push(Parents.fromJS(item));
                }
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Stats = data["stats"] ? Stats.fromJS(data["stats"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit {
            let result = new Commit();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["commit"] = this.Commit ? this.Commit.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            if (this.Files && this.Files.constructor === Array) {
                data["files"] = [];
                for (let item of this.Files)
                    data["files"].push(item.toJSON());
            }
            if (this.Parents && this.Parents.constructor === Array) {
                data["parents"] = [];
                for (let item of this.Parents)
                    data["parents"].push(item.toJSON());
            }
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["stats"] = this.Stats ? this.Stats.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit {
        Author?: Author;
        Commit?: Commit3;
        Committer?: Committer;
        Files?: Files[];
        Parents?: Parents[];
        Sha?: string;
        Stats?: Stats;
        Url?: string;
    }
    
    export class CommitBody implements ICommitBody {
        Body: string;
        /** Deprecated - Use position parameter instead. */
        Line?: string;
        /** Line number in the file to comment on. Defaults to null. */
        Number?: string;
        /** Relative path of the file to comment on. */
        Path?: string;
        /** Line index in the diff to comment on. */
        Position?: number;
        /** SHA of the commit to comment on. */
        Sha: string;
    
        constructor(data?: ICommitBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Line = data["line"] !== undefined ? data["line"] : <any>null;
                this.Number = data["number"] !== undefined ? data["number"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Position = data["position"] !== undefined ? data["position"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
            }
        }
    
        static fromJS(data: any): CommitBody {
            let result = new CommitBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["line"] = this.Line !== undefined ? this.Line : <any>null;
            data["number"] = this.Number !== undefined ? this.Number : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["position"] = this.Position !== undefined ? this.Position : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            return data; 
        }
    }
    
    export interface ICommitBody {
        Body: string;
        /** Deprecated - Use position parameter instead. */
        Line?: string;
        /** Line number in the file to comment on. Defaults to null. */
        Number?: string;
        /** Relative path of the file to comment on. */
        Path?: string;
        /** Line index in the diff to comment on. */
        Position?: number;
        /** SHA of the commit to comment on. */
        Sha: string;
    }
    
    export class CommitComments implements ICommitComments {
        Body?: string;
        Commit_id?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Html_url?: string;
        Id?: number;
        Line?: number;
        Path?: string;
        Position?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User2;
    
        constructor(data?: ICommitComments) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Commit_id = data["commit_id"] !== undefined ? data["commit_id"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Line = data["line"] !== undefined ? data["line"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Position = data["position"] !== undefined ? data["position"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User2.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): CommitComments {
            let result = new CommitComments();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["commit_id"] = this.Commit_id !== undefined ? this.Commit_id : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["line"] = this.Line !== undefined ? this.Line : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["position"] = this.Position !== undefined ? this.Position : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface ICommitComments {
        Body?: string;
        Commit_id?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Html_url?: string;
        Id?: number;
        Line?: number;
        Path?: string;
        Position?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User2;
    }
    
    export class CompareCommits implements ICompareCommits {
        Ahead_by?: number;
        Base_commit?: Base_commit;
        Behind_by?: number;
        Commits?: Commits[];
        Diff_url?: string;
        Files?: Files2[];
        Html_url?: string;
        Patch_url?: string;
        Permalink_url?: string;
        Status?: string;
        Total_commits?: number;
        Url?: string;
    
        constructor(data?: ICompareCommits) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Ahead_by = data["ahead_by"] !== undefined ? data["ahead_by"] : <any>null;
                this.Base_commit = data["base_commit"] ? Base_commit.fromJS(data["base_commit"]) : <any>null;
                this.Behind_by = data["behind_by"] !== undefined ? data["behind_by"] : <any>null;
                if (data["commits"] && data["commits"].constructor === Array) {
                    this.Commits = [];
                    for (let item of data["commits"])
                        this.Commits.push(Commits.fromJS(item));
                }
                this.Diff_url = data["diff_url"] !== undefined ? data["diff_url"] : <any>null;
                if (data["files"] && data["files"].constructor === Array) {
                    this.Files = [];
                    for (let item of data["files"])
                        this.Files.push(Files2.fromJS(item));
                }
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Patch_url = data["patch_url"] !== undefined ? data["patch_url"] : <any>null;
                this.Permalink_url = data["permalink_url"] !== undefined ? data["permalink_url"] : <any>null;
                this.Status = data["status"] !== undefined ? data["status"] : <any>null;
                this.Total_commits = data["total_commits"] !== undefined ? data["total_commits"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): CompareCommits {
            let result = new CompareCommits();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["ahead_by"] = this.Ahead_by !== undefined ? this.Ahead_by : <any>null;
            data["base_commit"] = this.Base_commit ? this.Base_commit.toJSON() : <any>null;
            data["behind_by"] = this.Behind_by !== undefined ? this.Behind_by : <any>null;
            if (this.Commits && this.Commits.constructor === Array) {
                data["commits"] = [];
                for (let item of this.Commits)
                    data["commits"].push(item.toJSON());
            }
            data["diff_url"] = this.Diff_url !== undefined ? this.Diff_url : <any>null;
            if (this.Files && this.Files.constructor === Array) {
                data["files"] = [];
                for (let item of this.Files)
                    data["files"].push(item.toJSON());
            }
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["patch_url"] = this.Patch_url !== undefined ? this.Patch_url : <any>null;
            data["permalink_url"] = this.Permalink_url !== undefined ? this.Permalink_url : <any>null;
            data["status"] = this.Status !== undefined ? this.Status : <any>null;
            data["total_commits"] = this.Total_commits !== undefined ? this.Total_commits : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICompareCommits {
        Ahead_by?: number;
        Base_commit?: Base_commit;
        Behind_by?: number;
        Commits?: Commits[];
        Diff_url?: string;
        Files?: Files2[];
        Html_url?: string;
        Patch_url?: string;
        Permalink_url?: string;
        Status?: string;
        Total_commits?: number;
        Url?: string;
    }
    
    export class ContentsPath implements IContentsPath {
        _links?: _links2;
        Content?: string;
        Encoding?: string;
        Git_url?: string;
        Html_url?: string;
        Name?: string;
        Path?: string;
        Sha?: string;
        Size?: number;
        Type?: string;
        Url?: string;
    
        constructor(data?: IContentsPath) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this._links = data["_links"] ? _links2.fromJS(data["_links"]) : <any>null;
                this.Content = data["content"] !== undefined ? data["content"] : <any>null;
                this.Encoding = data["encoding"] !== undefined ? data["encoding"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): ContentsPath {
            let result = new ContentsPath();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["_links"] = this._links ? this._links.toJSON() : <any>null;
            data["content"] = this.Content !== undefined ? this.Content : <any>null;
            data["encoding"] = this.Encoding !== undefined ? this.Encoding : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IContentsPath {
        _links?: _links2;
        Content?: string;
        Encoding?: string;
        Git_url?: string;
        Html_url?: string;
        Name?: string;
        Path?: string;
        Sha?: string;
        Size?: number;
        Type?: string;
        Url?: string;
    }
    
    export class CreateDownload implements ICreateDownload {
        Accesskeyid?: string;
        Acl?: string;
        Bucket?: string;
        Content_type?: string;
        Description?: string;
        Download_count?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Expirationdate?: string;
        Html_url?: string;
        Id?: number;
        Mime_type?: string;
        Name?: string;
        Path?: string;
        Policy?: string;
        Prefix?: string;
        Redirect?: boolean;
        S3_url?: string;
        Signature?: string;
        Size?: number;
        Url?: string;
    
        constructor(data?: ICreateDownload) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Accesskeyid = data["accesskeyid"] !== undefined ? data["accesskeyid"] : <any>null;
                this.Acl = data["acl"] !== undefined ? data["acl"] : <any>null;
                this.Bucket = data["bucket"] !== undefined ? data["bucket"] : <any>null;
                this.Content_type = data["content_type"] !== undefined ? data["content_type"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Download_count = data["download_count"] !== undefined ? data["download_count"] : <any>null;
                this.Expirationdate = data["expirationdate"] !== undefined ? data["expirationdate"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Mime_type = data["mime_type"] !== undefined ? data["mime_type"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Policy = data["policy"] !== undefined ? data["policy"] : <any>null;
                this.Prefix = data["prefix"] !== undefined ? data["prefix"] : <any>null;
                this.Redirect = data["redirect"] !== undefined ? data["redirect"] : <any>null;
                this.S3_url = data["s3_url"] !== undefined ? data["s3_url"] : <any>null;
                this.Signature = data["signature"] !== undefined ? data["signature"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): CreateDownload {
            let result = new CreateDownload();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["accesskeyid"] = this.Accesskeyid !== undefined ? this.Accesskeyid : <any>null;
            data["acl"] = this.Acl !== undefined ? this.Acl : <any>null;
            data["bucket"] = this.Bucket !== undefined ? this.Bucket : <any>null;
            data["content_type"] = this.Content_type !== undefined ? this.Content_type : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["download_count"] = this.Download_count !== undefined ? this.Download_count : <any>null;
            data["expirationdate"] = this.Expirationdate !== undefined ? this.Expirationdate : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["mime_type"] = this.Mime_type !== undefined ? this.Mime_type : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["policy"] = this.Policy !== undefined ? this.Policy : <any>null;
            data["prefix"] = this.Prefix !== undefined ? this.Prefix : <any>null;
            data["redirect"] = this.Redirect !== undefined ? this.Redirect : <any>null;
            data["s3_url"] = this.S3_url !== undefined ? this.S3_url : <any>null;
            data["signature"] = this.Signature !== undefined ? this.Signature : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICreateDownload {
        Accesskeyid?: string;
        Acl?: string;
        Bucket?: string;
        Content_type?: string;
        Description?: string;
        Download_count?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Expirationdate?: string;
        Html_url?: string;
        Id?: number;
        Mime_type?: string;
        Name?: string;
        Path?: string;
        Policy?: string;
        Prefix?: string;
        Redirect?: boolean;
        S3_url?: string;
        Signature?: string;
        Size?: number;
        Url?: string;
    }
    
    export class CreateFile implements ICreateFile {
        Commit?: Commit4;
        Content?: Content;
    
        constructor(data?: ICreateFile) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Commit = data["commit"] ? Commit4.fromJS(data["commit"]) : <any>null;
                this.Content = data["content"] ? Content.fromJS(data["content"]) : <any>null;
            }
        }
    
        static fromJS(data: any): CreateFile {
            let result = new CreateFile();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["commit"] = this.Commit ? this.Commit.toJSON() : <any>null;
            data["content"] = this.Content ? this.Content.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface ICreateFile {
        Commit?: Commit4;
        Content?: Content;
    }
    
    export class CreateFileBody implements ICreateFileBody {
        Committer?: Committer2;
        Content?: string;
        Message?: string;
    
        constructor(data?: ICreateFileBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Committer = data["committer"] ? Committer2.fromJS(data["committer"]) : <any>null;
                this.Content = data["content"] !== undefined ? data["content"] : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
            }
        }
    
        static fromJS(data: any): CreateFileBody {
            let result = new CreateFileBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["content"] = this.Content !== undefined ? this.Content : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            return data; 
        }
    }
    
    export interface ICreateFileBody {
        Committer?: Committer2;
        Content?: string;
        Message?: string;
    }
    
    export class DeleteFile implements IDeleteFile {
        Commit?: Commit5;
        Content?: string;
    
        constructor(data?: IDeleteFile) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Commit = data["commit"] ? Commit5.fromJS(data["commit"]) : <any>null;
                this.Content = data["content"] !== undefined ? data["content"] : <any>null;
            }
        }
    
        static fromJS(data: any): DeleteFile {
            let result = new DeleteFile();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["commit"] = this.Commit ? this.Commit.toJSON() : <any>null;
            data["content"] = this.Content !== undefined ? this.Content : <any>null;
            return data; 
        }
    }
    
    export interface IDeleteFile {
        Commit?: Commit5;
        Content?: string;
    }
    
    export class DeleteFileBody implements IDeleteFileBody {
        Committer?: Committer3;
        Message?: string;
        Sha?: string;
    
        constructor(data?: IDeleteFileBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Committer = data["committer"] ? Committer3.fromJS(data["committer"]) : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
            }
        }
    
        static fromJS(data: any): DeleteFileBody {
            let result = new DeleteFileBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            return data; 
        }
    }
    
    export interface IDeleteFileBody {
        Committer?: Committer3;
        Message?: string;
        Sha?: string;
    }
    
    export class Deployment implements IDeployment {
        Description?: string;
        Payload?: Payload;
        Ref?: string;
    
        constructor(data?: IDeployment) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Payload = data["payload"] ? Payload.fromJS(data["payload"]) : <any>null;
                this.Ref = data["ref"] !== undefined ? data["ref"] : <any>null;
            }
        }
    
        static fromJS(data: any): Deployment {
            let result = new Deployment();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["payload"] = this.Payload ? this.Payload.toJSON() : <any>null;
            data["ref"] = this.Ref !== undefined ? this.Ref : <any>null;
            return data; 
        }
    }
    
    export interface IDeployment {
        Description?: string;
        Payload?: Payload;
        Ref?: string;
    }
    
    export class DeploymentResp implements IDeploymentResp {
        Created_at?: string;
        Creator?: Creator;
        Description?: string;
        Id?: number;
        Payload?: string;
        Sha?: string;
        Statuses_url?: string;
        Updated_at?: string;
        Url?: string;
    
        constructor(data?: IDeploymentResp) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Creator = data["creator"] ? Creator.fromJS(data["creator"]) : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Payload = data["payload"] !== undefined ? data["payload"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Statuses_url = data["statuses_url"] !== undefined ? data["statuses_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): DeploymentResp {
            let result = new DeploymentResp();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["creator"] = this.Creator ? this.Creator.toJSON() : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["payload"] = this.Payload !== undefined ? this.Payload : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["statuses_url"] = this.Statuses_url !== undefined ? this.Statuses_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IDeploymentResp {
        Created_at?: string;
        Creator?: Creator;
        Description?: string;
        Id?: number;
        Payload?: string;
        Sha?: string;
        Statuses_url?: string;
        Updated_at?: string;
        Url?: string;
    }
    
    export class DeploymentStatusesCreate implements IDeploymentStatusesCreate {
        Description?: string;
        State?: string;
        Target_url?: string;
    
        constructor(data?: IDeploymentStatusesCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Target_url = data["target_url"] !== undefined ? data["target_url"] : <any>null;
            }
        }
    
        static fromJS(data: any): DeploymentStatusesCreate {
            let result = new DeploymentStatusesCreate();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["target_url"] = this.Target_url !== undefined ? this.Target_url : <any>null;
            return data; 
        }
    }
    
    export interface IDeploymentStatusesCreate {
        Description?: string;
        State?: string;
        Target_url?: string;
    }
    
    export class DownloadBody implements IDownloadBody {
        Content_type?: string;
        Description?: string;
        Name: string;
        /** Size of file in bytes. */
        Size: number;
    
        constructor(data?: IDownloadBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content_type = data["content_type"] !== undefined ? data["content_type"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
            }
        }
    
        static fromJS(data: any): DownloadBody {
            let result = new DownloadBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content_type"] = this.Content_type !== undefined ? this.Content_type : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            return data; 
        }
    }
    
    export interface IDownloadBody {
        Content_type?: string;
        Description?: string;
        Name: string;
        /** Size of file in bytes. */
        Size: number;
    }
    
    export class Downloads implements IDownloads {
        Content_type?: string;
        Description?: string;
        Download_count?: number;
        Html_url?: string;
        Id?: number;
        Name?: string;
        Size?: number;
        Url?: string;
    
        constructor(data?: IDownloads) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content_type = data["content_type"] !== undefined ? data["content_type"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Download_count = data["download_count"] !== undefined ? data["download_count"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Downloads {
            let result = new Downloads();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content_type"] = this.Content_type !== undefined ? this.Content_type : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["download_count"] = this.Download_count !== undefined ? this.Download_count : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IDownloads {
        Content_type?: string;
        Description?: string;
        Download_count?: number;
        Html_url?: string;
        Id?: number;
        Name?: string;
        Size?: number;
        Url?: string;
    }
    
    export class EditTeam implements IEditTeam {
        Name: string;
        Permission?: EditTeamPermission;
    
        constructor(data?: IEditTeam) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Permission = data["permission"] !== undefined ? data["permission"] : <any>null;
            }
        }
    
        static fromJS(data: any): EditTeam {
            let result = new EditTeam();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["permission"] = this.Permission !== undefined ? this.Permission : <any>null;
            return data; 
        }
    }
    
    export interface IEditTeam {
        Name: string;
        Permission?: EditTeamPermission;
    }
    
    export class Emojis implements IEmojis {
        _100?: string;
        _1234?: string;
        Plus1?: string;
        _1?: string;
        _8ball?: string;
        A?: string;
        Ab?: string;
    
        constructor(data?: IEmojis) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this._100 = data["100"] !== undefined ? data["100"] : <any>null;
                this._1234 = data["1234"] !== undefined ? data["1234"] : <any>null;
                this.Plus1 = data["+1"] !== undefined ? data["+1"] : <any>null;
                this._1 = data["-1"] !== undefined ? data["-1"] : <any>null;
                this._8ball = data["8ball"] !== undefined ? data["8ball"] : <any>null;
                this.A = data["a"] !== undefined ? data["a"] : <any>null;
                this.Ab = data["ab"] !== undefined ? data["ab"] : <any>null;
            }
        }
    
        static fromJS(data: any): Emojis {
            let result = new Emojis();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["100"] = this._100 !== undefined ? this._100 : <any>null;
            data["1234"] = this._1234 !== undefined ? this._1234 : <any>null;
            data["+1"] = this.Plus1 !== undefined ? this.Plus1 : <any>null;
            data["-1"] = this._1 !== undefined ? this._1 : <any>null;
            data["8ball"] = this._8ball !== undefined ? this._8ball : <any>null;
            data["a"] = this.A !== undefined ? this.A : <any>null;
            data["ab"] = this.Ab !== undefined ? this.Ab : <any>null;
            return data; 
        }
    }
    
    export interface IEmojis {
        _100?: string;
        _1234?: string;
        Plus1?: string;
        _1?: string;
        _8ball?: string;
        A?: string;
        Ab?: string;
    }
    
    export class Event implements IEvent {
        Actor?: Actor;
        Commit_id?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Event?: string;
        Issue?: Issue2;
        Url?: string;
    
        constructor(data?: IEvent) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Actor = data["actor"] ? Actor.fromJS(data["actor"]) : <any>null;
                this.Commit_id = data["commit_id"] !== undefined ? data["commit_id"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Event = data["event"] !== undefined ? data["event"] : <any>null;
                this.Issue = data["issue"] ? Issue2.fromJS(data["issue"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Event {
            let result = new Event();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["actor"] = this.Actor ? this.Actor.toJSON() : <any>null;
            data["commit_id"] = this.Commit_id !== undefined ? this.Commit_id : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["event"] = this.Event !== undefined ? this.Event : <any>null;
            data["issue"] = this.Issue ? this.Issue.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IEvent {
        Actor?: Actor;
        Commit_id?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Event?: string;
        Issue?: Issue2;
        Url?: string;
    }
    
    export class Events implements IEvents {
        Actor?: Actor2;
        Created_at?: any;
        Id?: number;
        Org?: Org;
        Payload?: any;
        Public?: boolean;
        Repo?: Repo2;
        Type?: string;
    
        constructor(data?: IEvents) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Actor = data["actor"] ? Actor2.fromJS(data["actor"]) : <any>null;
                if (data["created_at"]) {
                    this.Created_at = {};
                    for (let key in data["created_at"]) {
                        if (data["created_at"].hasOwnProperty(key))
                            this.Created_at[key] = data["created_at"][key];
                    }
                }
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Org = data["org"] ? Org.fromJS(data["org"]) : <any>null;
                if (data["payload"]) {
                    this.Payload = {};
                    for (let key in data["payload"]) {
                        if (data["payload"].hasOwnProperty(key))
                            this.Payload[key] = data["payload"][key];
                    }
                }
                this.Public = data["public"] !== undefined ? data["public"] : <any>null;
                this.Repo = data["repo"] ? Repo2.fromJS(data["repo"]) : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
            }
        }
    
        static fromJS(data: any): Events {
            let result = new Events();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["actor"] = this.Actor ? this.Actor.toJSON() : <any>null;
            if (this.Created_at) {
                data["created_at"] = {};
                for (let key in this.Created_at) {
                    if (this.Created_at.hasOwnProperty(key))
                        data["created_at"][key] = this.Created_at[key] !== undefined ? this.Created_at[key] : <any>null;
                }
            }
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["org"] = this.Org ? this.Org.toJSON() : <any>null;
            if (this.Payload) {
                data["payload"] = {};
                for (let key in this.Payload) {
                    if (this.Payload.hasOwnProperty(key))
                        data["payload"][key] = this.Payload[key] !== undefined ? this.Payload[key] : <any>null;
                }
            }
            data["public"] = this.Public !== undefined ? this.Public : <any>null;
            data["repo"] = this.Repo ? this.Repo.toJSON() : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            return data; 
        }
    }
    
    export interface IEvents {
        Actor?: Actor2;
        Created_at?: any;
        Id?: number;
        Org?: Org;
        Payload?: any;
        Public?: boolean;
        Repo?: Repo2;
        Type?: string;
    }
    
    export class Feeds implements IFeeds {
        _links?: _links3;
        Current_user_actor_url?: string;
        Current_user_organization_url?: string;
        Current_user_public?: string;
        Current_user_url?: string;
        Timeline_url?: string;
        User_url?: string;
    
        constructor(data?: IFeeds) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this._links = data["_links"] ? _links3.fromJS(data["_links"]) : <any>null;
                this.Current_user_actor_url = data["current_user_actor_url"] !== undefined ? data["current_user_actor_url"] : <any>null;
                this.Current_user_organization_url = data["current_user_organization_url"] !== undefined ? data["current_user_organization_url"] : <any>null;
                this.Current_user_public = data["current_user_public"] !== undefined ? data["current_user_public"] : <any>null;
                this.Current_user_url = data["current_user_url"] !== undefined ? data["current_user_url"] : <any>null;
                this.Timeline_url = data["timeline_url"] !== undefined ? data["timeline_url"] : <any>null;
                this.User_url = data["user_url"] !== undefined ? data["user_url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Feeds {
            let result = new Feeds();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["_links"] = this._links ? this._links.toJSON() : <any>null;
            data["current_user_actor_url"] = this.Current_user_actor_url !== undefined ? this.Current_user_actor_url : <any>null;
            data["current_user_organization_url"] = this.Current_user_organization_url !== undefined ? this.Current_user_organization_url : <any>null;
            data["current_user_public"] = this.Current_user_public !== undefined ? this.Current_user_public : <any>null;
            data["current_user_url"] = this.Current_user_url !== undefined ? this.Current_user_url : <any>null;
            data["timeline_url"] = this.Timeline_url !== undefined ? this.Timeline_url : <any>null;
            data["user_url"] = this.User_url !== undefined ? this.User_url : <any>null;
            return data; 
        }
    }
    
    export interface IFeeds {
        _links?: _links3;
        Current_user_actor_url?: string;
        Current_user_organization_url?: string;
        Current_user_public?: string;
        Current_user_url?: string;
        Timeline_url?: string;
        User_url?: string;
    }
    
    export class Fork implements IFork {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IFork) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Fork {
            let result = new Fork();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IFork {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class ForkBody implements IForkBody {
        Organization?: string;
    
        constructor(data?: IForkBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Organization = data["organization"] !== undefined ? data["organization"] : <any>null;
            }
        }
    
        static fromJS(data: any): ForkBody {
            let result = new ForkBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["organization"] = this.Organization !== undefined ? this.Organization : <any>null;
            return data; 
        }
    }
    
    export interface IForkBody {
        Organization?: string;
    }
    
    export class Gist implements IGist {
        Comments?: number;
        Comments_url?: string;
        /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
        Created_at?: string;
        Description?: string;
        Files?: Files3;
        Forks?: Forks[];
        Git_pull_url?: string;
        Git_push_url?: string;
        History?: History[];
        Html_url?: string;
        Id?: string;
        Public?: boolean;
        Url?: string;
        User?: User3;
    
        constructor(data?: IGist) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Comments = data["comments"] !== undefined ? data["comments"] : <any>null;
                this.Comments_url = data["comments_url"] !== undefined ? data["comments_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Files = data["files"] ? Files3.fromJS(data["files"]) : <any>null;
                if (data["forks"] && data["forks"].constructor === Array) {
                    this.Forks = [];
                    for (let item of data["forks"])
                        this.Forks.push(Forks.fromJS(item));
                }
                this.Git_pull_url = data["git_pull_url"] !== undefined ? data["git_pull_url"] : <any>null;
                this.Git_push_url = data["git_push_url"] !== undefined ? data["git_push_url"] : <any>null;
                if (data["history"] && data["history"].constructor === Array) {
                    this.History = [];
                    for (let item of data["history"])
                        this.History.push(History.fromJS(item));
                }
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Public = data["public"] !== undefined ? data["public"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User3.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Gist {
            let result = new Gist();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["comments"] = this.Comments !== undefined ? this.Comments : <any>null;
            data["comments_url"] = this.Comments_url !== undefined ? this.Comments_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["files"] = this.Files ? this.Files.toJSON() : <any>null;
            if (this.Forks && this.Forks.constructor === Array) {
                data["forks"] = [];
                for (let item of this.Forks)
                    data["forks"].push(item.toJSON());
            }
            data["git_pull_url"] = this.Git_pull_url !== undefined ? this.Git_pull_url : <any>null;
            data["git_push_url"] = this.Git_push_url !== undefined ? this.Git_push_url : <any>null;
            if (this.History && this.History.constructor === Array) {
                data["history"] = [];
                for (let item of this.History)
                    data["history"].push(item.toJSON());
            }
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["public"] = this.Public !== undefined ? this.Public : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IGist {
        Comments?: number;
        Comments_url?: string;
        /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
        Created_at?: string;
        Description?: string;
        Files?: Files3;
        Forks?: Forks[];
        Git_pull_url?: string;
        Git_push_url?: string;
        History?: History[];
        Html_url?: string;
        Id?: string;
        Public?: boolean;
        Url?: string;
        User?: User3;
    }
    
    export class GitCommit implements IGitCommit {
        Author?: Author2;
        Message?: string;
        Parents?: string;
        Tree?: string;
    
        constructor(data?: IGitCommit) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author2.fromJS(data["author"]) : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Parents = data["parents"] !== undefined ? data["parents"] : <any>null;
                this.Tree = data["tree"] !== undefined ? data["tree"] : <any>null;
            }
        }
    
        static fromJS(data: any): GitCommit {
            let result = new GitCommit();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["parents"] = this.Parents !== undefined ? this.Parents : <any>null;
            data["tree"] = this.Tree !== undefined ? this.Tree : <any>null;
            return data; 
        }
    }
    
    export interface IGitCommit {
        Author?: Author2;
        Message?: string;
        Parents?: string;
        Tree?: string;
    }
    
    export class GitRefPatch implements IGitRefPatch {
        Force?: boolean;
        Sha?: string;
    
        constructor(data?: IGitRefPatch) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Force = data["force"] !== undefined ? data["force"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
            }
        }
    
        static fromJS(data: any): GitRefPatch {
            let result = new GitRefPatch();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["force"] = this.Force !== undefined ? this.Force : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            return data; 
        }
    }
    
    export interface IGitRefPatch {
        Force?: boolean;
        Sha?: string;
    }
    
    export class GitignoreLang implements IGitignoreLang {
        Name?: string;
        Source?: string;
    
        constructor(data?: IGitignoreLang) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Source = data["source"] !== undefined ? data["source"] : <any>null;
            }
        }
    
        static fromJS(data: any): GitignoreLang {
            let result = new GitignoreLang();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["source"] = this.Source !== undefined ? this.Source : <any>null;
            return data; 
        }
    }
    
    export interface IGitignoreLang {
        Name?: string;
        Source?: string;
    }
    
    export class HeadBranch implements IHeadBranch {
        Object?: Object;
        Ref?: string;
        Url?: string;
    
        constructor(data?: IHeadBranch) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Object = data["object"] ? Object.fromJS(data["object"]) : <any>null;
                this.Ref = data["ref"] !== undefined ? data["ref"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): HeadBranch {
            let result = new HeadBranch();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["object"] = this.Object ? this.Object.toJSON() : <any>null;
            data["ref"] = this.Ref !== undefined ? this.Ref : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IHeadBranch {
        Object?: Object;
        Ref?: string;
        Url?: string;
    }
    
    export class HeadBranchBody implements IHeadBranchBody {
        /** Boolean indicating whether to force the update or to make sure the update is a fast-forward update. The default is false, so leaving this out or setting it to false will make sure you’re not overwriting work. */
        Force: boolean;
        /** String of the SHA1 value to set this reference to. */
        Sha: string;
    
        constructor(data?: IHeadBranchBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Force = data["force"] !== undefined ? data["force"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
            }
        }
    
        static fromJS(data: any): HeadBranchBody {
            let result = new HeadBranchBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["force"] = this.Force !== undefined ? this.Force : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            return data; 
        }
    }
    
    export interface IHeadBranchBody {
        /** Boolean indicating whether to force the update or to make sure the update is a fast-forward update. The default is false, so leaving this out or setting it to false will make sure you’re not overwriting work. */
        Force: boolean;
        /** String of the SHA1 value to set this reference to. */
        Sha: string;
    }
    
    export class HookBody implements IHookBody {
        Active?: boolean;
        Add_events?: string[];
    
        constructor(data?: IHookBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Active = data["active"] !== undefined ? data["active"] : <any>null;
                if (data["add_events"] && data["add_events"].constructor === Array) {
                    this.Add_events = [];
                    for (let item of data["add_events"])
                        this.Add_events.push(item);
                }
            }
        }
    
        static fromJS(data: any): HookBody {
            let result = new HookBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["active"] = this.Active !== undefined ? this.Active : <any>null;
            if (this.Add_events && this.Add_events.constructor === Array) {
                data["add_events"] = [];
                for (let item of this.Add_events)
                    data["add_events"].push(item);
            }
            return data; 
        }
    }
    
    export interface IHookBody {
        Active?: boolean;
        Add_events?: string[];
    }
    
    export class Issue implements IIssue {
        Assignee?: string;
        Body?: string;
        Labels?: string[];
        Milestone?: number;
        Title?: string;
    
        constructor(data?: IIssue) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Assignee = data["assignee"] !== undefined ? data["assignee"] : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                if (data["labels"] && data["labels"].constructor === Array) {
                    this.Labels = [];
                    for (let item of data["labels"])
                        this.Labels.push(item);
                }
                this.Milestone = data["milestone"] !== undefined ? data["milestone"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
            }
        }
    
        static fromJS(data: any): Issue {
            let result = new Issue();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["assignee"] = this.Assignee !== undefined ? this.Assignee : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            if (this.Labels && this.Labels.constructor === Array) {
                data["labels"] = [];
                for (let item of this.Labels)
                    data["labels"].push(item);
            }
            data["milestone"] = this.Milestone !== undefined ? this.Milestone : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            return data; 
        }
    }
    
    export interface IIssue {
        Assignee?: string;
        Body?: string;
        Labels?: string[];
        Milestone?: number;
        Title?: string;
    }
    
    export class IssueBody implements IIssueBody {
        Assignee?: string;
        Body?: string;
        Labels?: string[];
        Milestone?: number;
        Title?: string;
    
        constructor(data?: IIssueBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Assignee = data["assignee"] !== undefined ? data["assignee"] : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                if (data["labels"] && data["labels"].constructor === Array) {
                    this.Labels = [];
                    for (let item of data["labels"])
                        this.Labels.push(item);
                }
                this.Milestone = data["milestone"] !== undefined ? data["milestone"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
            }
        }
    
        static fromJS(data: any): IssueBody {
            let result = new IssueBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["assignee"] = this.Assignee !== undefined ? this.Assignee : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            if (this.Labels && this.Labels.constructor === Array) {
                data["labels"] = [];
                for (let item of this.Labels)
                    data["labels"].push(item);
            }
            data["milestone"] = this.Milestone !== undefined ? this.Milestone : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            return data; 
        }
    }
    
    export interface IIssueBody {
        Assignee?: string;
        Body?: string;
        Labels?: string[];
        Milestone?: number;
        Title?: string;
    }
    
    export class IssuesComment implements IIssuesComment {
        Body?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Html_url?: string;
        Id?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User4;
    
        constructor(data?: IIssuesComment) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User4.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): IssuesComment {
            let result = new IssuesComment();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IIssuesComment {
        Body?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Html_url?: string;
        Id?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User4;
    }
    
    export class Key implements IKey {
        Id?: number;
        Key?: string;
        Title?: string;
        Url?: string;
    
        constructor(data?: IKey) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Key = data["key"] !== undefined ? data["key"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Key {
            let result = new Key();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["key"] = this.Key !== undefined ? this.Key : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IKey {
        Id?: number;
        Key?: string;
        Title?: string;
        Url?: string;
    }
    
    export class KeyBody implements IKeyBody {
        Key?: string;
        Title?: string;
    
        constructor(data?: IKeyBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Key = data["key"] !== undefined ? data["key"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
            }
        }
    
        static fromJS(data: any): KeyBody {
            let result = new KeyBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["key"] = this.Key !== undefined ? this.Key : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            return data; 
        }
    }
    
    export interface IKeyBody {
        Key?: string;
        Title?: string;
    }
    
    export class Label implements ILabel {
        Color?: string;
        Name?: string;
        Url?: string;
    
        constructor(data?: ILabel) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Color = data["color"] !== undefined ? data["color"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Label {
            let result = new Label();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["color"] = this.Color !== undefined ? this.Color : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ILabel {
        Color?: string;
        Name?: string;
        Url?: string;
    }
    
    export class Markdown implements IMarkdown {
        Context?: string;
        Mode?: string;
        Text?: string;
    
        constructor(data?: IMarkdown) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Context = data["context"] !== undefined ? data["context"] : <any>null;
                this.Mode = data["mode"] !== undefined ? data["mode"] : <any>null;
                this.Text = data["text"] !== undefined ? data["text"] : <any>null;
            }
        }
    
        static fromJS(data: any): Markdown {
            let result = new Markdown();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["context"] = this.Context !== undefined ? this.Context : <any>null;
            data["mode"] = this.Mode !== undefined ? this.Mode : <any>null;
            data["text"] = this.Text !== undefined ? this.Text : <any>null;
            return data; 
        }
    }
    
    export interface IMarkdown {
        Context?: string;
        Mode?: string;
        Text?: string;
    }
    
    export class Merge implements IMerge {
        Merged?: boolean;
        Message?: string;
        Sha?: string;
    
        constructor(data?: IMerge) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Merged = data["merged"] !== undefined ? data["merged"] : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
            }
        }
    
        static fromJS(data: any): Merge {
            let result = new Merge();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["merged"] = this.Merged !== undefined ? this.Merged : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            return data; 
        }
    }
    
    export interface IMerge {
        Merged?: boolean;
        Message?: string;
        Sha?: string;
    }
    
    export class MergePullBody implements IMergePullBody {
        Commit_message?: string;
    
        constructor(data?: IMergePullBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Commit_message = data["commit_message"] !== undefined ? data["commit_message"] : <any>null;
            }
        }
    
        static fromJS(data: any): MergePullBody {
            let result = new MergePullBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["commit_message"] = this.Commit_message !== undefined ? this.Commit_message : <any>null;
            return data; 
        }
    }
    
    export interface IMergePullBody {
        Commit_message?: string;
    }
    
    export class MergesBody implements IMergesBody {
        Base?: string;
        Commit_message?: string;
        Head?: string;
    
        constructor(data?: IMergesBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Base = data["base"] !== undefined ? data["base"] : <any>null;
                this.Commit_message = data["commit_message"] !== undefined ? data["commit_message"] : <any>null;
                this.Head = data["head"] !== undefined ? data["head"] : <any>null;
            }
        }
    
        static fromJS(data: any): MergesBody {
            let result = new MergesBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["base"] = this.Base !== undefined ? this.Base : <any>null;
            data["commit_message"] = this.Commit_message !== undefined ? this.Commit_message : <any>null;
            data["head"] = this.Head !== undefined ? this.Head : <any>null;
            return data; 
        }
    }
    
    export interface IMergesBody {
        Base?: string;
        Commit_message?: string;
        Head?: string;
    }
    
    export class MergesConflict implements IMergesConflict {
        /** Error message */
        Message?: string;
    
        constructor(data?: IMergesConflict) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
            }
        }
    
        static fromJS(data: any): MergesConflict {
            let result = new MergesConflict();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            return data; 
        }
    }
    
    export interface IMergesConflict {
        /** Error message */
        Message?: string;
    }
    
    export class MergesSuccessful implements IMergesSuccessful {
        Author?: Author3;
        Comments_url?: string;
        Commit?: Commit6;
        Committer?: Committer4;
        Merged?: boolean;
        Message?: string;
        Parents?: Parents2[];
        Sha?: string;
        Url?: string;
    
        constructor(data?: IMergesSuccessful) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author3.fromJS(data["author"]) : <any>null;
                this.Comments_url = data["comments_url"] !== undefined ? data["comments_url"] : <any>null;
                this.Commit = data["commit"] ? Commit6.fromJS(data["commit"]) : <any>null;
                this.Committer = data["committer"] ? Committer4.fromJS(data["committer"]) : <any>null;
                this.Merged = data["merged"] !== undefined ? data["merged"] : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                if (data["parents"] && data["parents"].constructor === Array) {
                    this.Parents = [];
                    for (let item of data["parents"])
                        this.Parents.push(Parents2.fromJS(item));
                }
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): MergesSuccessful {
            let result = new MergesSuccessful();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["comments_url"] = this.Comments_url !== undefined ? this.Comments_url : <any>null;
            data["commit"] = this.Commit ? this.Commit.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["merged"] = this.Merged !== undefined ? this.Merged : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            if (this.Parents && this.Parents.constructor === Array) {
                data["parents"] = [];
                for (let item of this.Parents)
                    data["parents"].push(item.toJSON());
            }
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IMergesSuccessful {
        Author?: Author3;
        Comments_url?: string;
        Commit?: Commit6;
        Committer?: Committer4;
        Merged?: boolean;
        Message?: string;
        Parents?: Parents2[];
        Sha?: string;
        Url?: string;
    }
    
    export class Meta implements IMeta {
        Git?: string[];
        Hooks?: string[];
    
        constructor(data?: IMeta) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["git"] && data["git"].constructor === Array) {
                    this.Git = [];
                    for (let item of data["git"])
                        this.Git.push(item);
                }
                if (data["hooks"] && data["hooks"].constructor === Array) {
                    this.Hooks = [];
                    for (let item of data["hooks"])
                        this.Hooks.push(item);
                }
            }
        }
    
        static fromJS(data: any): Meta {
            let result = new Meta();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Git && this.Git.constructor === Array) {
                data["git"] = [];
                for (let item of this.Git)
                    data["git"].push(item);
            }
            if (this.Hooks && this.Hooks.constructor === Array) {
                data["hooks"] = [];
                for (let item of this.Hooks)
                    data["hooks"].push(item);
            }
            return data; 
        }
    }
    
    export interface IMeta {
        Git?: string[];
        Hooks?: string[];
    }
    
    export class Milestone implements IMilestone {
        Closed_issues?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Creator?: Creator2;
        Description?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Due_on?: string;
        Number?: number;
        Open_issues?: number;
        State?: MilestoneState;
        Title?: string;
        Url?: string;
    
        constructor(data?: IMilestone) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Closed_issues = data["closed_issues"] !== undefined ? data["closed_issues"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Creator = data["creator"] ? Creator2.fromJS(data["creator"]) : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Due_on = data["due_on"] !== undefined ? data["due_on"] : <any>null;
                this.Number = data["number"] !== undefined ? data["number"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Milestone {
            let result = new Milestone();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["closed_issues"] = this.Closed_issues !== undefined ? this.Closed_issues : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["creator"] = this.Creator ? this.Creator.toJSON() : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["due_on"] = this.Due_on !== undefined ? this.Due_on : <any>null;
            data["number"] = this.Number !== undefined ? this.Number : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IMilestone {
        Closed_issues?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Creator?: Creator2;
        Description?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Due_on?: string;
        Number?: number;
        Open_issues?: number;
        State?: MilestoneState;
        Title?: string;
        Url?: string;
    }
    
    export class MilestoneBody implements IMilestoneBody {
        Description?: string;
        Due_on?: string;
        State?: string;
        Title?: string;
    
        constructor(data?: IMilestoneBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Due_on = data["due_on"] !== undefined ? data["due_on"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
            }
        }
    
        static fromJS(data: any): MilestoneBody {
            let result = new MilestoneBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["due_on"] = this.Due_on !== undefined ? this.Due_on : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            return data; 
        }
    }
    
    export interface IMilestoneBody {
        Description?: string;
        Due_on?: string;
        State?: string;
        Title?: string;
    }
    
    export class MilestoneUpdate implements IMilestoneUpdate {
        Description?: string;
        Due_on?: string;
        State?: string;
        Title?: string;
    
        constructor(data?: IMilestoneUpdate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Due_on = data["due_on"] !== undefined ? data["due_on"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
            }
        }
    
        static fromJS(data: any): MilestoneUpdate {
            let result = new MilestoneUpdate();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["due_on"] = this.Due_on !== undefined ? this.Due_on : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            return data; 
        }
    }
    
    export interface IMilestoneUpdate {
        Description?: string;
        Due_on?: string;
        State?: string;
        Title?: string;
    }
    
    export class NotificationMarkRead implements INotificationMarkRead {
        Last_read_at?: string;
    
        constructor(data?: INotificationMarkRead) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Last_read_at = data["last_read_at"] !== undefined ? data["last_read_at"] : <any>null;
            }
        }
    
        static fromJS(data: any): NotificationMarkRead {
            let result = new NotificationMarkRead();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["last_read_at"] = this.Last_read_at !== undefined ? this.Last_read_at : <any>null;
            return data; 
        }
    }
    
    export interface INotificationMarkRead {
        Last_read_at?: string;
    }
    
    export class Notifications implements INotifications {
        Id?: number;
        Last_read_at?: string;
        Reason?: string;
        Repository?: Repository;
        Subject?: Subject;
        Unread?: boolean;
        Updated_at?: string;
        Url?: string;
    
        constructor(data?: INotifications) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Last_read_at = data["last_read_at"] !== undefined ? data["last_read_at"] : <any>null;
                this.Reason = data["reason"] !== undefined ? data["reason"] : <any>null;
                this.Repository = data["repository"] ? Repository.fromJS(data["repository"]) : <any>null;
                this.Subject = data["subject"] ? Subject.fromJS(data["subject"]) : <any>null;
                this.Unread = data["unread"] !== undefined ? data["unread"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Notifications {
            let result = new Notifications();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["last_read_at"] = this.Last_read_at !== undefined ? this.Last_read_at : <any>null;
            data["reason"] = this.Reason !== undefined ? this.Reason : <any>null;
            data["repository"] = this.Repository ? this.Repository.toJSON() : <any>null;
            data["subject"] = this.Subject ? this.Subject.toJSON() : <any>null;
            data["unread"] = this.Unread !== undefined ? this.Unread : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface INotifications {
        Id?: number;
        Last_read_at?: string;
        Reason?: string;
        Repository?: Repository;
        Subject?: Subject;
        Unread?: boolean;
        Updated_at?: string;
        Url?: string;
    }
    
    export class OrgTeamsPost implements IOrgTeamsPost {
        Name: string;
        Permission?: OrgTeamsPostPermission;
        Repo_names?: string[];
    
        constructor(data?: IOrgTeamsPost) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Permission = data["permission"] !== undefined ? data["permission"] : <any>null;
                if (data["repo_names"] && data["repo_names"].constructor === Array) {
                    this.Repo_names = [];
                    for (let item of data["repo_names"])
                        this.Repo_names.push(item);
                }
            }
        }
    
        static fromJS(data: any): OrgTeamsPost {
            let result = new OrgTeamsPost();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["permission"] = this.Permission !== undefined ? this.Permission : <any>null;
            if (this.Repo_names && this.Repo_names.constructor === Array) {
                data["repo_names"] = [];
                for (let item of this.Repo_names)
                    data["repo_names"].push(item);
            }
            return data; 
        }
    }
    
    export interface IOrgTeamsPost {
        Name: string;
        Permission?: OrgTeamsPostPermission;
        Repo_names?: string[];
    }
    
    export class Organization implements IOrganization {
        Avatar_url?: string;
        Blog?: string;
        Company?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Email?: string;
        Followers?: number;
        Following?: number;
        Html_url?: string;
        Id?: number;
        Location?: string;
        Login?: string;
        Name?: string;
        Public_gists?: number;
        Public_repos?: number;
        Type?: string;
        Url?: string;
    
        constructor(data?: IOrganization) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Blog = data["blog"] !== undefined ? data["blog"] : <any>null;
                this.Company = data["company"] !== undefined ? data["company"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Followers = data["followers"] !== undefined ? data["followers"] : <any>null;
                this.Following = data["following"] !== undefined ? data["following"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Location = data["location"] !== undefined ? data["location"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Public_gists = data["public_gists"] !== undefined ? data["public_gists"] : <any>null;
                this.Public_repos = data["public_repos"] !== undefined ? data["public_repos"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Organization {
            let result = new Organization();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["blog"] = this.Blog !== undefined ? this.Blog : <any>null;
            data["company"] = this.Company !== undefined ? this.Company : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["followers"] = this.Followers !== undefined ? this.Followers : <any>null;
            data["following"] = this.Following !== undefined ? this.Following : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["location"] = this.Location !== undefined ? this.Location : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["public_gists"] = this.Public_gists !== undefined ? this.Public_gists : <any>null;
            data["public_repos"] = this.Public_repos !== undefined ? this.Public_repos : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOrganization {
        Avatar_url?: string;
        Blog?: string;
        Company?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Email?: string;
        Followers?: number;
        Following?: number;
        Html_url?: string;
        Id?: number;
        Location?: string;
        Login?: string;
        Name?: string;
        Public_gists?: number;
        Public_repos?: number;
        Type?: string;
        Url?: string;
    }
    
    export class OrganizationAsTeamMember implements IOrganizationAsTeamMember {
        Errors?: Errors[];
        Message?: string;
    
        constructor(data?: IOrganizationAsTeamMember) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["errors"] && data["errors"].constructor === Array) {
                    this.Errors = [];
                    for (let item of data["errors"])
                        this.Errors.push(Errors.fromJS(item));
                }
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
            }
        }
    
        static fromJS(data: any): OrganizationAsTeamMember {
            let result = new OrganizationAsTeamMember();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Errors && this.Errors.constructor === Array) {
                data["errors"] = [];
                for (let item of this.Errors)
                    data["errors"].push(item.toJSON());
            }
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            return data; 
        }
    }
    
    export interface IOrganizationAsTeamMember {
        Errors?: Errors[];
        Message?: string;
    }
    
    export class ParticipationStats implements IParticipationStats {
        All?: number[];
        Owner?: number[];
    
        constructor(data?: IParticipationStats) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["all"] && data["all"].constructor === Array) {
                    this.All = [];
                    for (let item of data["all"])
                        this.All.push(item);
                }
                if (data["owner"] && data["owner"].constructor === Array) {
                    this.Owner = [];
                    for (let item of data["owner"])
                        this.Owner.push(item);
                }
            }
        }
    
        static fromJS(data: any): ParticipationStats {
            let result = new ParticipationStats();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.All && this.All.constructor === Array) {
                data["all"] = [];
                for (let item of this.All)
                    data["all"].push(item);
            }
            if (this.Owner && this.Owner.constructor === Array) {
                data["owner"] = [];
                for (let item of this.Owner)
                    data["owner"].push(item);
            }
            return data; 
        }
    }
    
    export interface IParticipationStats {
        All?: number[];
        Owner?: number[];
    }
    
    export class PatchGist implements IPatchGist {
        Description?: string;
        Files?: Files4;
    
        constructor(data?: IPatchGist) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Files = data["files"] ? Files4.fromJS(data["files"]) : <any>null;
            }
        }
    
        static fromJS(data: any): PatchGist {
            let result = new PatchGist();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["files"] = this.Files ? this.Files.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IPatchGist {
        Description?: string;
        Files?: Files4;
    }
    
    export class PatchOrg implements IPatchOrg {
        /** Billing email address. This address is not publicized. */
        Billing_email?: string;
        Company?: string;
        /** Publicly visible email address. */
        Email?: string;
        Location?: string;
        Name?: string;
    
        constructor(data?: IPatchOrg) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Billing_email = data["billing_email"] !== undefined ? data["billing_email"] : <any>null;
                this.Company = data["company"] !== undefined ? data["company"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Location = data["location"] !== undefined ? data["location"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): PatchOrg {
            let result = new PatchOrg();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["billing_email"] = this.Billing_email !== undefined ? this.Billing_email : <any>null;
            data["company"] = this.Company !== undefined ? this.Company : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["location"] = this.Location !== undefined ? this.Location : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IPatchOrg {
        /** Billing email address. This address is not publicized. */
        Billing_email?: string;
        Company?: string;
        /** Publicly visible email address. */
        Email?: string;
        Location?: string;
        Name?: string;
    }
    
    export class PostComment implements IPostComment {
        Body: string;
    
        constructor(data?: IPostComment) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
            }
        }
    
        static fromJS(data: any): PostComment {
            let result = new PostComment();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            return data; 
        }
    }
    
    export interface IPostComment {
        Body: string;
    }
    
    export class PostGist implements IPostGist {
        Description?: string;
        Files?: Files5;
        Public?: boolean;
    
        constructor(data?: IPostGist) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Files = data["files"] ? Files5.fromJS(data["files"]) : <any>null;
                this.Public = data["public"] !== undefined ? data["public"] : <any>null;
            }
        }
    
        static fromJS(data: any): PostGist {
            let result = new PostGist();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["files"] = this.Files ? this.Files.toJSON() : <any>null;
            data["public"] = this.Public !== undefined ? this.Public : <any>null;
            return data; 
        }
    }
    
    export interface IPostGist {
        Description?: string;
        Files?: Files5;
        Public?: boolean;
    }
    
    export class PostRepo implements IPostRepo {
        /** True to create an initial commit with empty README. Default is false. */
        Auto_init?: boolean;
        Description?: string;
        /** Desired language or platform .gitignore template to apply. Use the name of the template without the extension. For example, "Haskell" Ignored if auto_init parameter is not provided.  */
        Gitignore_template?: string;
        /** True to enable downloads for this repository, false to disable them. Default is true. */
        Has_downloads?: boolean;
        /** True to enable issues for this repository, false to disable them. Default is true. */
        Has_issues?: boolean;
        /** True to enable the wiki for this repository, false to disable it. Default is true. */
        Has_wiki?: boolean;
        Homepage?: string;
        Name: string;
        /** True to create a private repository, false to create a public one. Creating private repositories requires a paid GitHub account. */
        Private?: boolean;
        /** The id of the team that will be granted access to this repository. This is only valid when creating a repo in an organization. */
        Team_id?: number;
    
        constructor(data?: IPostRepo) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Auto_init = data["auto_init"] !== undefined ? data["auto_init"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Gitignore_template = data["gitignore_template"] !== undefined ? data["gitignore_template"] : <any>null;
                this.Has_downloads = data["has_downloads"] !== undefined ? data["has_downloads"] : <any>null;
                this.Has_issues = data["has_issues"] !== undefined ? data["has_issues"] : <any>null;
                this.Has_wiki = data["has_wiki"] !== undefined ? data["has_wiki"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Team_id = data["team_id"] !== undefined ? data["team_id"] : <any>null;
            }
        }
    
        static fromJS(data: any): PostRepo {
            let result = new PostRepo();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["auto_init"] = this.Auto_init !== undefined ? this.Auto_init : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["gitignore_template"] = this.Gitignore_template !== undefined ? this.Gitignore_template : <any>null;
            data["has_downloads"] = this.Has_downloads !== undefined ? this.Has_downloads : <any>null;
            data["has_issues"] = this.Has_issues !== undefined ? this.Has_issues : <any>null;
            data["has_wiki"] = this.Has_wiki !== undefined ? this.Has_wiki : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["team_id"] = this.Team_id !== undefined ? this.Team_id : <any>null;
            return data; 
        }
    }
    
    export interface IPostRepo {
        /** True to create an initial commit with empty README. Default is false. */
        Auto_init?: boolean;
        Description?: string;
        /** Desired language or platform .gitignore template to apply. Use the name of the template without the extension. For example, "Haskell" Ignored if auto_init parameter is not provided.  */
        Gitignore_template?: string;
        /** True to enable downloads for this repository, false to disable them. Default is true. */
        Has_downloads?: boolean;
        /** True to enable issues for this repository, false to disable them. Default is true. */
        Has_issues?: boolean;
        /** True to enable the wiki for this repository, false to disable it. Default is true. */
        Has_wiki?: boolean;
        Homepage?: string;
        Name: string;
        /** True to create a private repository, false to create a public one. Creating private repositories requires a paid GitHub account. */
        Private?: boolean;
        /** The id of the team that will be granted access to this repository. This is only valid when creating a repo in an organization. */
        Team_id?: number;
    }
    
    export class PullRequest implements IPullRequest {
        _links?: _links4;
        Additions?: number;
        Base?: Base;
        Body?: string;
        Changed_files?: number;
        Closed_at?: string;
        Comments?: number;
        Commits?: number;
        Created_at?: string;
        Deletions?: number;
        Diff_url?: string;
        Head?: Head;
        Html_url?: string;
        Issue_url?: string;
        Merge_commit_sha?: string;
        Mergeable?: boolean;
        Merged?: boolean;
        Merged_at?: string;
        Merged_by?: Merged_by;
        Number?: number;
        Patch_url?: string;
        State?: string;
        Title?: string;
        Updated_at?: string;
        Url?: string;
        User?: User5;
    
        constructor(data?: IPullRequest) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this._links = data["_links"] ? _links4.fromJS(data["_links"]) : <any>null;
                this.Additions = data["additions"] !== undefined ? data["additions"] : <any>null;
                this.Base = data["base"] ? Base.fromJS(data["base"]) : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Changed_files = data["changed_files"] !== undefined ? data["changed_files"] : <any>null;
                this.Closed_at = data["closed_at"] !== undefined ? data["closed_at"] : <any>null;
                this.Comments = data["comments"] !== undefined ? data["comments"] : <any>null;
                this.Commits = data["commits"] !== undefined ? data["commits"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Deletions = data["deletions"] !== undefined ? data["deletions"] : <any>null;
                this.Diff_url = data["diff_url"] !== undefined ? data["diff_url"] : <any>null;
                this.Head = data["head"] ? Head.fromJS(data["head"]) : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Issue_url = data["issue_url"] !== undefined ? data["issue_url"] : <any>null;
                this.Merge_commit_sha = data["merge_commit_sha"] !== undefined ? data["merge_commit_sha"] : <any>null;
                this.Mergeable = data["mergeable"] !== undefined ? data["mergeable"] : <any>null;
                this.Merged = data["merged"] !== undefined ? data["merged"] : <any>null;
                this.Merged_at = data["merged_at"] !== undefined ? data["merged_at"] : <any>null;
                this.Merged_by = data["merged_by"] ? Merged_by.fromJS(data["merged_by"]) : <any>null;
                this.Number = data["number"] !== undefined ? data["number"] : <any>null;
                this.Patch_url = data["patch_url"] !== undefined ? data["patch_url"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User5.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): PullRequest {
            let result = new PullRequest();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["_links"] = this._links ? this._links.toJSON() : <any>null;
            data["additions"] = this.Additions !== undefined ? this.Additions : <any>null;
            data["base"] = this.Base ? this.Base.toJSON() : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["changed_files"] = this.Changed_files !== undefined ? this.Changed_files : <any>null;
            data["closed_at"] = this.Closed_at !== undefined ? this.Closed_at : <any>null;
            data["comments"] = this.Comments !== undefined ? this.Comments : <any>null;
            data["commits"] = this.Commits !== undefined ? this.Commits : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["deletions"] = this.Deletions !== undefined ? this.Deletions : <any>null;
            data["diff_url"] = this.Diff_url !== undefined ? this.Diff_url : <any>null;
            data["head"] = this.Head ? this.Head.toJSON() : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["issue_url"] = this.Issue_url !== undefined ? this.Issue_url : <any>null;
            data["merge_commit_sha"] = this.Merge_commit_sha !== undefined ? this.Merge_commit_sha : <any>null;
            data["mergeable"] = this.Mergeable !== undefined ? this.Mergeable : <any>null;
            data["merged"] = this.Merged !== undefined ? this.Merged : <any>null;
            data["merged_at"] = this.Merged_at !== undefined ? this.Merged_at : <any>null;
            data["merged_by"] = this.Merged_by ? this.Merged_by.toJSON() : <any>null;
            data["number"] = this.Number !== undefined ? this.Number : <any>null;
            data["patch_url"] = this.Patch_url !== undefined ? this.Patch_url : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IPullRequest {
        _links?: _links4;
        Additions?: number;
        Base?: Base;
        Body?: string;
        Changed_files?: number;
        Closed_at?: string;
        Comments?: number;
        Commits?: number;
        Created_at?: string;
        Deletions?: number;
        Diff_url?: string;
        Head?: Head;
        Html_url?: string;
        Issue_url?: string;
        Merge_commit_sha?: string;
        Mergeable?: boolean;
        Merged?: boolean;
        Merged_at?: string;
        Merged_by?: Merged_by;
        Number?: number;
        Patch_url?: string;
        State?: string;
        Title?: string;
        Updated_at?: string;
        Url?: string;
        User?: User5;
    }
    
    export class PullUpdate implements IPullUpdate {
        Body?: string;
        State?: string;
        Title?: string;
    
        constructor(data?: IPullUpdate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
            }
        }
    
        static fromJS(data: any): PullUpdate {
            let result = new PullUpdate();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            return data; 
        }
    }
    
    export interface IPullUpdate {
        Body?: string;
        State?: string;
        Title?: string;
    }
    
    export class PullsComment implements IPullsComment {
        _links?: _links5;
        Body?: string;
        Commit_id?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Id?: number;
        Path?: string;
        Position?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User6;
    
        constructor(data?: IPullsComment) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this._links = data["_links"] ? _links5.fromJS(data["_links"]) : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Commit_id = data["commit_id"] !== undefined ? data["commit_id"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Position = data["position"] !== undefined ? data["position"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User6.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): PullsComment {
            let result = new PullsComment();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["_links"] = this._links ? this._links.toJSON() : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["commit_id"] = this.Commit_id !== undefined ? this.Commit_id : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["position"] = this.Position !== undefined ? this.Position : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IPullsComment {
        _links?: _links5;
        Body?: string;
        Commit_id?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Id?: number;
        Path?: string;
        Position?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User6;
    }
    
    export class PullsCommentPost implements IPullsCommentPost {
        Body?: string;
        Commit_id?: string;
        Path?: string;
        Position?: number;
    
        constructor(data?: IPullsCommentPost) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Commit_id = data["commit_id"] !== undefined ? data["commit_id"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Position = data["position"] !== undefined ? data["position"] : <any>null;
            }
        }
    
        static fromJS(data: any): PullsCommentPost {
            let result = new PullsCommentPost();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["commit_id"] = this.Commit_id !== undefined ? this.Commit_id : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["position"] = this.Position !== undefined ? this.Position : <any>null;
            return data; 
        }
    }
    
    export interface IPullsCommentPost {
        Body?: string;
        Commit_id?: string;
        Path?: string;
        Position?: number;
    }
    
    export class PullsPost implements IPullsPost {
        Base?: string;
        Body?: string;
        Head?: string;
        Title?: string;
    
        constructor(data?: IPullsPost) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Base = data["base"] !== undefined ? data["base"] : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Head = data["head"] !== undefined ? data["head"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
            }
        }
    
        static fromJS(data: any): PullsPost {
            let result = new PullsPost();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["base"] = this.Base !== undefined ? this.Base : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["head"] = this.Head !== undefined ? this.Head : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            return data; 
        }
    }
    
    export interface IPullsPost {
        Base?: string;
        Body?: string;
        Head?: string;
        Title?: string;
    }
    
    export class PutSubscription implements IPutSubscription {
        Created_at?: string;
        Ignored?: boolean;
        Reason?: any;
        Subscribed?: boolean;
        Thread_url?: string;
        Url?: string;
    
        constructor(data?: IPutSubscription) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Ignored = data["ignored"] !== undefined ? data["ignored"] : <any>null;
                if (data["reason"]) {
                    this.Reason = {};
                    for (let key in data["reason"]) {
                        if (data["reason"].hasOwnProperty(key))
                            this.Reason[key] = data["reason"][key];
                    }
                }
                this.Subscribed = data["subscribed"] !== undefined ? data["subscribed"] : <any>null;
                this.Thread_url = data["thread_url"] !== undefined ? data["thread_url"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): PutSubscription {
            let result = new PutSubscription();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["ignored"] = this.Ignored !== undefined ? this.Ignored : <any>null;
            if (this.Reason) {
                data["reason"] = {};
                for (let key in this.Reason) {
                    if (this.Reason.hasOwnProperty(key))
                        data["reason"][key] = this.Reason[key] !== undefined ? this.Reason[key] : <any>null;
                }
            }
            data["subscribed"] = this.Subscribed !== undefined ? this.Subscribed : <any>null;
            data["thread_url"] = this.Thread_url !== undefined ? this.Thread_url : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IPutSubscription {
        Created_at?: string;
        Ignored?: boolean;
        Reason?: any;
        Subscribed?: boolean;
        Thread_url?: string;
        Url?: string;
    }
    
    export class Rate_limit implements IRate_limit {
        Rate?: Rate;
    
        constructor(data?: IRate_limit) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Rate = data["rate"] ? Rate.fromJS(data["rate"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Rate_limit {
            let result = new Rate_limit();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["rate"] = this.Rate ? this.Rate.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IRate_limit {
        Rate?: Rate;
    }
    
    export class Readme implements IReadme {
        _links?: _links6;
        Content?: string;
        Encoding?: string;
        Git_url?: string;
        Html_url?: string;
        Name?: string;
        Path?: string;
        Sha?: string;
        Size?: number;
        Type?: string;
        Url?: string;
    
        constructor(data?: IReadme) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this._links = data["_links"] ? _links6.fromJS(data["_links"]) : <any>null;
                this.Content = data["content"] !== undefined ? data["content"] : <any>null;
                this.Encoding = data["encoding"] !== undefined ? data["encoding"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Readme {
            let result = new Readme();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["_links"] = this._links ? this._links.toJSON() : <any>null;
            data["content"] = this.Content !== undefined ? this.Content : <any>null;
            data["encoding"] = this.Encoding !== undefined ? this.Encoding : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IReadme {
        _links?: _links6;
        Content?: string;
        Encoding?: string;
        Git_url?: string;
        Html_url?: string;
        Name?: string;
        Path?: string;
        Sha?: string;
        Size?: number;
        Type?: string;
        Url?: string;
    }
    
    export class RefBody implements IRefBody {
        Object?: Object2;
        Ref?: string;
        Url?: string;
    
        constructor(data?: IRefBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Object = data["object"] ? Object2.fromJS(data["object"]) : <any>null;
                this.Ref = data["ref"] !== undefined ? data["ref"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): RefBody {
            let result = new RefBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["object"] = this.Object ? this.Object.toJSON() : <any>null;
            data["ref"] = this.Ref !== undefined ? this.Ref : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IRefBody {
        Object?: Object2;
        Ref?: string;
        Url?: string;
    }
    
    export class RefsBody implements IRefsBody {
        Ref?: string;
        Sha?: string;
    
        constructor(data?: IRefsBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Ref = data["ref"] !== undefined ? data["ref"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
            }
        }
    
        static fromJS(data: any): RefsBody {
            let result = new RefsBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["ref"] = this.Ref !== undefined ? this.Ref : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            return data; 
        }
    }
    
    export interface IRefsBody {
        Ref?: string;
        Sha?: string;
    }
    
    export class Release implements IRelease {
        Assets?: Assets[];
        Assets_url?: string;
        Author?: Author4;
        Body?: string;
        Created_at?: string;
        Draft?: boolean;
        Html_url?: string;
        Id?: number;
        Name?: string;
        Prerelease?: boolean;
        Published_at?: string;
        Tag_name?: string;
        Tarball_url?: string;
        Target_commitish?: string;
        Upload_url?: string;
        Url?: string;
        Zipball_url?: string;
    
        constructor(data?: IRelease) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["assets"] && data["assets"].constructor === Array) {
                    this.Assets = [];
                    for (let item of data["assets"])
                        this.Assets.push(Assets.fromJS(item));
                }
                this.Assets_url = data["assets_url"] !== undefined ? data["assets_url"] : <any>null;
                this.Author = data["author"] ? Author4.fromJS(data["author"]) : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Draft = data["draft"] !== undefined ? data["draft"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Prerelease = data["prerelease"] !== undefined ? data["prerelease"] : <any>null;
                this.Published_at = data["published_at"] !== undefined ? data["published_at"] : <any>null;
                this.Tag_name = data["tag_name"] !== undefined ? data["tag_name"] : <any>null;
                this.Tarball_url = data["tarball_url"] !== undefined ? data["tarball_url"] : <any>null;
                this.Target_commitish = data["target_commitish"] !== undefined ? data["target_commitish"] : <any>null;
                this.Upload_url = data["upload_url"] !== undefined ? data["upload_url"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Zipball_url = data["zipball_url"] !== undefined ? data["zipball_url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Release {
            let result = new Release();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Assets && this.Assets.constructor === Array) {
                data["assets"] = [];
                for (let item of this.Assets)
                    data["assets"].push(item.toJSON());
            }
            data["assets_url"] = this.Assets_url !== undefined ? this.Assets_url : <any>null;
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["draft"] = this.Draft !== undefined ? this.Draft : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["prerelease"] = this.Prerelease !== undefined ? this.Prerelease : <any>null;
            data["published_at"] = this.Published_at !== undefined ? this.Published_at : <any>null;
            data["tag_name"] = this.Tag_name !== undefined ? this.Tag_name : <any>null;
            data["tarball_url"] = this.Tarball_url !== undefined ? this.Tarball_url : <any>null;
            data["target_commitish"] = this.Target_commitish !== undefined ? this.Target_commitish : <any>null;
            data["upload_url"] = this.Upload_url !== undefined ? this.Upload_url : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["zipball_url"] = this.Zipball_url !== undefined ? this.Zipball_url : <any>null;
            return data; 
        }
    }
    
    export interface IRelease {
        Assets?: Assets[];
        Assets_url?: string;
        Author?: Author4;
        Body?: string;
        Created_at?: string;
        Draft?: boolean;
        Html_url?: string;
        Id?: number;
        Name?: string;
        Prerelease?: boolean;
        Published_at?: string;
        Tag_name?: string;
        Tarball_url?: string;
        Target_commitish?: string;
        Upload_url?: string;
        Url?: string;
        Zipball_url?: string;
    }
    
    export class ReleaseCreate implements IReleaseCreate {
        Body?: string;
        Draft?: boolean;
        Name?: string;
        Prerelease?: boolean;
        Tag_name?: string;
        Target_commitish?: string;
    
        constructor(data?: IReleaseCreate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Draft = data["draft"] !== undefined ? data["draft"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Prerelease = data["prerelease"] !== undefined ? data["prerelease"] : <any>null;
                this.Tag_name = data["tag_name"] !== undefined ? data["tag_name"] : <any>null;
                this.Target_commitish = data["target_commitish"] !== undefined ? data["target_commitish"] : <any>null;
            }
        }
    
        static fromJS(data: any): ReleaseCreate {
            let result = new ReleaseCreate();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["draft"] = this.Draft !== undefined ? this.Draft : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["prerelease"] = this.Prerelease !== undefined ? this.Prerelease : <any>null;
            data["tag_name"] = this.Tag_name !== undefined ? this.Tag_name : <any>null;
            data["target_commitish"] = this.Target_commitish !== undefined ? this.Target_commitish : <any>null;
            return data; 
        }
    }
    
    export interface IReleaseCreate {
        Body?: string;
        Draft?: boolean;
        Name?: string;
        Prerelease?: boolean;
        Tag_name?: string;
        Target_commitish?: string;
    }
    
    export class Repo implements IRepo {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Has_downloads?: boolean;
        Has_issues?: boolean;
        Has_wiki?: boolean;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Organization?: Organization2;
        Owner?: Owner2;
        /** Is present when the repo is a fork. Parent is the repo this repo was forked from. */
        Parent?: Parent;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        /** Is present when the repo is a fork. Source is the ultimate source for the network. */
        Source?: Source;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IRepo) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Has_downloads = data["has_downloads"] !== undefined ? data["has_downloads"] : <any>null;
                this.Has_issues = data["has_issues"] !== undefined ? data["has_issues"] : <any>null;
                this.Has_wiki = data["has_wiki"] !== undefined ? data["has_wiki"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Organization = data["organization"] ? Organization2.fromJS(data["organization"]) : <any>null;
                this.Owner = data["owner"] ? Owner2.fromJS(data["owner"]) : <any>null;
                this.Parent = data["parent"] ? Parent.fromJS(data["parent"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Source = data["source"] ? Source.fromJS(data["source"]) : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Repo {
            let result = new Repo();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["has_downloads"] = this.Has_downloads !== undefined ? this.Has_downloads : <any>null;
            data["has_issues"] = this.Has_issues !== undefined ? this.Has_issues : <any>null;
            data["has_wiki"] = this.Has_wiki !== undefined ? this.Has_wiki : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["organization"] = this.Organization ? this.Organization.toJSON() : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["parent"] = this.Parent ? this.Parent.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["source"] = this.Source ? this.Source.toJSON() : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IRepo {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Has_downloads?: boolean;
        Has_issues?: boolean;
        Has_wiki?: boolean;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Organization?: Organization2;
        Owner?: Owner2;
        /** Is present when the repo is a fork. Parent is the repo this repo was forked from. */
        Parent?: Parent;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        /** Is present when the repo is a fork. Source is the ultimate source for the network. */
        Source?: Source;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class RepoCommit implements IRepoCommit {
        Author?: Author5;
        Committer?: Committer5;
        Message?: string;
        Parents?: Parents3[];
        Sha?: string;
        Tree?: Tree2;
        Url?: string;
    
        constructor(data?: IRepoCommit) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author5.fromJS(data["author"]) : <any>null;
                this.Committer = data["committer"] ? Committer5.fromJS(data["committer"]) : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                if (data["parents"] && data["parents"].constructor === Array) {
                    this.Parents = [];
                    for (let item of data["parents"])
                        this.Parents.push(Parents3.fromJS(item));
                }
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Tree = data["tree"] ? Tree2.fromJS(data["tree"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): RepoCommit {
            let result = new RepoCommit();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            if (this.Parents && this.Parents.constructor === Array) {
                data["parents"] = [];
                for (let item of this.Parents)
                    data["parents"].push(item.toJSON());
            }
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["tree"] = this.Tree ? this.Tree.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IRepoCommit {
        Author?: Author5;
        Committer?: Committer5;
        Message?: string;
        Parents?: Parents3[];
        Sha?: string;
        Tree?: Tree2;
        Url?: string;
    }
    
    export class RepoCommitBody implements IRepoCommitBody {
        Author?: Author6;
        Message: string;
        Parents: string[] = [];
        Tree: string;
    
        constructor(data?: IRepoCommitBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author6.fromJS(data["author"]) : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                if (data["parents"] && data["parents"].constructor === Array) {
                    this.Parents = [];
                    for (let item of data["parents"])
                        this.Parents.push(item);
                }
                this.Tree = data["tree"] !== undefined ? data["tree"] : <any>null;
            }
        }
    
        static fromJS(data: any): RepoCommitBody {
            let result = new RepoCommitBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            if (this.Parents && this.Parents.constructor === Array) {
                data["parents"] = [];
                for (let item of this.Parents)
                    data["parents"].push(item);
            }
            data["tree"] = this.Tree !== undefined ? this.Tree : <any>null;
            return data; 
        }
    }
    
    export interface IRepoCommitBody {
        Author?: Author6;
        Message: string;
        Parents: string[];
        Tree: string;
    }
    
    export class RepoEdit implements IRepoEdit {
        Description?: string;
        Has_downloads?: boolean;
        Has_issues?: boolean;
        Has_wiki?: boolean;
        Homepage?: string;
        Name?: string;
        Private?: boolean;
    
        constructor(data?: IRepoEdit) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Has_downloads = data["has_downloads"] !== undefined ? data["has_downloads"] : <any>null;
                this.Has_issues = data["has_issues"] !== undefined ? data["has_issues"] : <any>null;
                this.Has_wiki = data["has_wiki"] !== undefined ? data["has_wiki"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
            }
        }
    
        static fromJS(data: any): RepoEdit {
            let result = new RepoEdit();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["has_downloads"] = this.Has_downloads !== undefined ? this.Has_downloads : <any>null;
            data["has_issues"] = this.Has_issues !== undefined ? this.Has_issues : <any>null;
            data["has_wiki"] = this.Has_wiki !== undefined ? this.Has_wiki : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            return data; 
        }
    }
    
    export interface IRepoEdit {
        Description?: string;
        Has_downloads?: boolean;
        Has_issues?: boolean;
        Has_wiki?: boolean;
        Homepage?: string;
        Name?: string;
        Private?: boolean;
    }
    
    export class SearchCode implements ISearchCode {
        Items?: Items[];
        Total_count?: number;
    
        constructor(data?: ISearchCode) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["items"] && data["items"].constructor === Array) {
                    this.Items = [];
                    for (let item of data["items"])
                        this.Items.push(Items.fromJS(item));
                }
                this.Total_count = data["total_count"] !== undefined ? data["total_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): SearchCode {
            let result = new SearchCode();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Items && this.Items.constructor === Array) {
                data["items"] = [];
                for (let item of this.Items)
                    data["items"].push(item.toJSON());
            }
            data["total_count"] = this.Total_count !== undefined ? this.Total_count : <any>null;
            return data; 
        }
    }
    
    export interface ISearchCode {
        Items?: Items[];
        Total_count?: number;
    }
    
    export class SearchIssues implements ISearchIssues {
        Items?: Items2[];
        Total_count?: number;
    
        constructor(data?: ISearchIssues) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["items"] && data["items"].constructor === Array) {
                    this.Items = [];
                    for (let item of data["items"])
                        this.Items.push(Items2.fromJS(item));
                }
                this.Total_count = data["total_count"] !== undefined ? data["total_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): SearchIssues {
            let result = new SearchIssues();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Items && this.Items.constructor === Array) {
                data["items"] = [];
                for (let item of this.Items)
                    data["items"].push(item.toJSON());
            }
            data["total_count"] = this.Total_count !== undefined ? this.Total_count : <any>null;
            return data; 
        }
    }
    
    export interface ISearchIssues {
        Items?: Items2[];
        Total_count?: number;
    }
    
    export class SearchIssuesByKeyword implements ISearchIssuesByKeyword {
        Issues?: Issues[];
    
        constructor(data?: ISearchIssuesByKeyword) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["issues"] && data["issues"].constructor === Array) {
                    this.Issues = [];
                    for (let item of data["issues"])
                        this.Issues.push(Issues.fromJS(item));
                }
            }
        }
    
        static fromJS(data: any): SearchIssuesByKeyword {
            let result = new SearchIssuesByKeyword();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Issues && this.Issues.constructor === Array) {
                data["issues"] = [];
                for (let item of this.Issues)
                    data["issues"].push(item.toJSON());
            }
            return data; 
        }
    }
    
    export interface ISearchIssuesByKeyword {
        Issues?: Issues[];
    }
    
    export class SearchRepositories implements ISearchRepositories {
        Items?: Items3[];
        Total_count?: number;
    
        constructor(data?: ISearchRepositories) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["items"] && data["items"].constructor === Array) {
                    this.Items = [];
                    for (let item of data["items"])
                        this.Items.push(Items3.fromJS(item));
                }
                this.Total_count = data["total_count"] !== undefined ? data["total_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): SearchRepositories {
            let result = new SearchRepositories();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Items && this.Items.constructor === Array) {
                data["items"] = [];
                for (let item of this.Items)
                    data["items"].push(item.toJSON());
            }
            data["total_count"] = this.Total_count !== undefined ? this.Total_count : <any>null;
            return data; 
        }
    }
    
    export interface ISearchRepositories {
        Items?: Items3[];
        Total_count?: number;
    }
    
    export class SearchRepositoriesByKeyword implements ISearchRepositoriesByKeyword {
        Repositories?: Repositories[];
    
        constructor(data?: ISearchRepositoriesByKeyword) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["repositories"] && data["repositories"].constructor === Array) {
                    this.Repositories = [];
                    for (let item of data["repositories"])
                        this.Repositories.push(Repositories.fromJS(item));
                }
            }
        }
    
        static fromJS(data: any): SearchRepositoriesByKeyword {
            let result = new SearchRepositoriesByKeyword();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Repositories && this.Repositories.constructor === Array) {
                data["repositories"] = [];
                for (let item of this.Repositories)
                    data["repositories"].push(item.toJSON());
            }
            return data; 
        }
    }
    
    export interface ISearchRepositoriesByKeyword {
        Repositories?: Repositories[];
    }
    
    export class SearchUserByEmail implements ISearchUserByEmail {
        User?: User7;
    
        constructor(data?: ISearchUserByEmail) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.User = data["user"] ? User7.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): SearchUserByEmail {
            let result = new SearchUserByEmail();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface ISearchUserByEmail {
        User?: User7;
    }
    
    export class SearchUsers implements ISearchUsers {
        Items?: Items4[];
        Total_count?: number;
    
        constructor(data?: ISearchUsers) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["items"] && data["items"].constructor === Array) {
                    this.Items = [];
                    for (let item of data["items"])
                        this.Items.push(Items4.fromJS(item));
                }
                this.Total_count = data["total_count"] !== undefined ? data["total_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): SearchUsers {
            let result = new SearchUsers();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Items && this.Items.constructor === Array) {
                data["items"] = [];
                for (let item of this.Items)
                    data["items"].push(item.toJSON());
            }
            data["total_count"] = this.Total_count !== undefined ? this.Total_count : <any>null;
            return data; 
        }
    }
    
    export interface ISearchUsers {
        Items?: Items4[];
        Total_count?: number;
    }
    
    export class SearchUsersByKeyword implements ISearchUsersByKeyword {
        Users?: Users[];
    
        constructor(data?: ISearchUsersByKeyword) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["users"] && data["users"].constructor === Array) {
                    this.Users = [];
                    for (let item of data["users"])
                        this.Users.push(Users.fromJS(item));
                }
            }
        }
    
        static fromJS(data: any): SearchUsersByKeyword {
            let result = new SearchUsersByKeyword();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Users && this.Users.constructor === Array) {
                data["users"] = [];
                for (let item of this.Users)
                    data["users"].push(item.toJSON());
            }
            return data; 
        }
    }
    
    export interface ISearchUsersByKeyword {
        Users?: Users[];
    }
    
    export class Subscribition implements ISubscribition {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Ignored?: boolean;
        Reason?: string;
        Repository_url?: string;
        Subscribed?: boolean;
        Url?: string;
    
        constructor(data?: ISubscribition) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Ignored = data["ignored"] !== undefined ? data["ignored"] : <any>null;
                this.Reason = data["reason"] !== undefined ? data["reason"] : <any>null;
                this.Repository_url = data["repository_url"] !== undefined ? data["repository_url"] : <any>null;
                this.Subscribed = data["subscribed"] !== undefined ? data["subscribed"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Subscribition {
            let result = new Subscribition();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["ignored"] = this.Ignored !== undefined ? this.Ignored : <any>null;
            data["reason"] = this.Reason !== undefined ? this.Reason : <any>null;
            data["repository_url"] = this.Repository_url !== undefined ? this.Repository_url : <any>null;
            data["subscribed"] = this.Subscribed !== undefined ? this.Subscribed : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ISubscribition {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Ignored?: boolean;
        Reason?: string;
        Repository_url?: string;
        Subscribed?: boolean;
        Url?: string;
    }
    
    export class SubscribitionBody implements ISubscribitionBody {
        Ignored?: boolean;
        Subscribed?: boolean;
    
        constructor(data?: ISubscribitionBody) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Ignored = data["ignored"] !== undefined ? data["ignored"] : <any>null;
                this.Subscribed = data["subscribed"] !== undefined ? data["subscribed"] : <any>null;
            }
        }
    
        static fromJS(data: any): SubscribitionBody {
            let result = new SubscribitionBody();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["ignored"] = this.Ignored !== undefined ? this.Ignored : <any>null;
            data["subscribed"] = this.Subscribed !== undefined ? this.Subscribed : <any>null;
            return data; 
        }
    }
    
    export interface ISubscribitionBody {
        Ignored?: boolean;
        Subscribed?: boolean;
    }
    
    export class Subscription implements ISubscription {
        Created_at?: string;
        Ignored?: boolean;
        Reason?: boolean;
        Subscribed?: boolean;
        Thread_url?: string;
        Url?: string;
    
        constructor(data?: ISubscription) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Ignored = data["ignored"] !== undefined ? data["ignored"] : <any>null;
                this.Reason = data["reason"] !== undefined ? data["reason"] : <any>null;
                this.Subscribed = data["subscribed"] !== undefined ? data["subscribed"] : <any>null;
                this.Thread_url = data["thread_url"] !== undefined ? data["thread_url"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Subscription {
            let result = new Subscription();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["ignored"] = this.Ignored !== undefined ? this.Ignored : <any>null;
            data["reason"] = this.Reason !== undefined ? this.Reason : <any>null;
            data["subscribed"] = this.Subscribed !== undefined ? this.Subscribed : <any>null;
            data["thread_url"] = this.Thread_url !== undefined ? this.Thread_url : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ISubscription {
        Created_at?: string;
        Ignored?: boolean;
        Reason?: boolean;
        Subscribed?: boolean;
        Thread_url?: string;
        Url?: string;
    }
    
    export class Tag implements ITag {
        Message?: string;
        Object?: Object3;
        Sha?: string;
        Tag?: string;
        Tagger?: Tagger;
        Url?: string;
    
        constructor(data?: ITag) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Object = data["object"] ? Object3.fromJS(data["object"]) : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Tag = data["tag"] !== undefined ? data["tag"] : <any>null;
                this.Tagger = data["tagger"] ? Tagger.fromJS(data["tagger"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tag {
            let result = new Tag();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["object"] = this.Object ? this.Object.toJSON() : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["tag"] = this.Tag !== undefined ? this.Tag : <any>null;
            data["tagger"] = this.Tagger ? this.Tagger.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITag {
        Message?: string;
        Object?: Object3;
        Sha?: string;
        Tag?: string;
        Tagger?: Tagger;
        Url?: string;
    }
    
    export class Tags implements ITags {
        /** String of the tag message. */
        Message: string;
        /** String of the SHA of the git object this is tagging. */
        Object: string;
        Tag: string;
        Tagger: Tagger2 = new Tagger2();
        /** String of the type of the object we’re tagging. Normally this is a commit but it can also be a tree or a blob. */
        Type: string;
    
        constructor(data?: ITags) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Object = data["object"] !== undefined ? data["object"] : <any>null;
                this.Tag = data["tag"] !== undefined ? data["tag"] : <any>null;
                this.Tagger = data["tagger"] ? Tagger2.fromJS(data["tagger"]) : new Tagger2();
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tags {
            let result = new Tags();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["object"] = this.Object !== undefined ? this.Object : <any>null;
            data["tag"] = this.Tag !== undefined ? this.Tag : <any>null;
            data["tagger"] = this.Tagger ? this.Tagger.toJSON() : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            return data; 
        }
    }
    
    export interface ITags {
        /** String of the tag message. */
        Message: string;
        /** String of the SHA of the git object this is tagging. */
        Object: string;
        Tag: string;
        Tagger: Tagger2;
        /** String of the type of the object we’re tagging. Normally this is a commit but it can also be a tree or a blob. */
        Type: string;
    }
    
    export class Team implements ITeam {
        Id?: number;
        Members_count?: number;
        Name?: string;
        Permission?: string;
        Repos_count?: number;
        Url?: string;
    
        constructor(data?: ITeam) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Members_count = data["members_count"] !== undefined ? data["members_count"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Permission = data["permission"] !== undefined ? data["permission"] : <any>null;
                this.Repos_count = data["repos_count"] !== undefined ? data["repos_count"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Team {
            let result = new Team();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["members_count"] = this.Members_count !== undefined ? this.Members_count : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["permission"] = this.Permission !== undefined ? this.Permission : <any>null;
            data["repos_count"] = this.Repos_count !== undefined ? this.Repos_count : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITeam {
        Id?: number;
        Members_count?: number;
        Name?: string;
        Permission?: string;
        Repos_count?: number;
        Url?: string;
    }
    
    export class TeamMembership implements ITeamMembership {
        State?: string;
        Url?: string;
    
        constructor(data?: ITeamMembership) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): TeamMembership {
            let result = new TeamMembership();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITeamMembership {
        State?: string;
        Url?: string;
    }
    
    export class Tree implements ITree {
        Sha?: string;
        Tree?: Tree3[];
        Url?: string;
    
        constructor(data?: ITree) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                if (data["tree"] && data["tree"].constructor === Array) {
                    this.Tree = [];
                    for (let item of data["tree"])
                        this.Tree.push(Tree3.fromJS(item));
                }
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree {
            let result = new Tree();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            if (this.Tree && this.Tree.constructor === Array) {
                data["tree"] = [];
                for (let item of this.Tree)
                    data["tree"].push(item.toJSON());
            }
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree {
        Sha?: string;
        Tree?: Tree3[];
        Url?: string;
    }
    
    export class Trees implements ITrees {
        Base_tree?: string;
        /** SHA1 checksum ID of the object in the tree. */
        Sha?: string;
        Tree?: Tree4[];
        Url?: string;
    
        constructor(data?: ITrees) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Base_tree = data["base_tree"] !== undefined ? data["base_tree"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                if (data["tree"] && data["tree"].constructor === Array) {
                    this.Tree = [];
                    for (let item of data["tree"])
                        this.Tree.push(Tree4.fromJS(item));
                }
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Trees {
            let result = new Trees();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["base_tree"] = this.Base_tree !== undefined ? this.Base_tree : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            if (this.Tree && this.Tree.constructor === Array) {
                data["tree"] = [];
                for (let item of this.Tree)
                    data["tree"].push(item.toJSON());
            }
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITrees {
        Base_tree?: string;
        /** SHA1 checksum ID of the object in the tree. */
        Sha?: string;
        Tree?: Tree4[];
        Url?: string;
    }
    
    export class User implements IUser {
        Avatar_url?: string;
        Bio?: string;
        Blog?: string;
        Collaborators?: number;
        Company?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Disk_usage?: number;
        Email?: string;
        Followers?: number;
        Following?: number;
        Gravatar_id?: string;
        Hireable?: boolean;
        Html_url?: string;
        Id?: number;
        Location?: string;
        Login?: string;
        Name?: string;
        Owned_private_repos?: number;
        Plan?: Plan;
        Private_gists?: number;
        Public_gists?: number;
        Public_repos?: number;
        Total_private_repos?: number;
        Type?: string;
        Url?: string;
    
        constructor(data?: IUser) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Bio = data["bio"] !== undefined ? data["bio"] : <any>null;
                this.Blog = data["blog"] !== undefined ? data["blog"] : <any>null;
                this.Collaborators = data["collaborators"] !== undefined ? data["collaborators"] : <any>null;
                this.Company = data["company"] !== undefined ? data["company"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Disk_usage = data["disk_usage"] !== undefined ? data["disk_usage"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Followers = data["followers"] !== undefined ? data["followers"] : <any>null;
                this.Following = data["following"] !== undefined ? data["following"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Hireable = data["hireable"] !== undefined ? data["hireable"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Location = data["location"] !== undefined ? data["location"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Owned_private_repos = data["owned_private_repos"] !== undefined ? data["owned_private_repos"] : <any>null;
                this.Plan = data["plan"] ? Plan.fromJS(data["plan"]) : <any>null;
                this.Private_gists = data["private_gists"] !== undefined ? data["private_gists"] : <any>null;
                this.Public_gists = data["public_gists"] !== undefined ? data["public_gists"] : <any>null;
                this.Public_repos = data["public_repos"] !== undefined ? data["public_repos"] : <any>null;
                this.Total_private_repos = data["total_private_repos"] !== undefined ? data["total_private_repos"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User {
            let result = new User();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["bio"] = this.Bio !== undefined ? this.Bio : <any>null;
            data["blog"] = this.Blog !== undefined ? this.Blog : <any>null;
            data["collaborators"] = this.Collaborators !== undefined ? this.Collaborators : <any>null;
            data["company"] = this.Company !== undefined ? this.Company : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["disk_usage"] = this.Disk_usage !== undefined ? this.Disk_usage : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["followers"] = this.Followers !== undefined ? this.Followers : <any>null;
            data["following"] = this.Following !== undefined ? this.Following : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["hireable"] = this.Hireable !== undefined ? this.Hireable : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["location"] = this.Location !== undefined ? this.Location : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["owned_private_repos"] = this.Owned_private_repos !== undefined ? this.Owned_private_repos : <any>null;
            data["plan"] = this.Plan ? this.Plan.toJSON() : <any>null;
            data["private_gists"] = this.Private_gists !== undefined ? this.Private_gists : <any>null;
            data["public_gists"] = this.Public_gists !== undefined ? this.Public_gists : <any>null;
            data["public_repos"] = this.Public_repos !== undefined ? this.Public_repos : <any>null;
            data["total_private_repos"] = this.Total_private_repos !== undefined ? this.Total_private_repos : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser {
        Avatar_url?: string;
        Bio?: string;
        Blog?: string;
        Collaborators?: number;
        Company?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Disk_usage?: number;
        Email?: string;
        Followers?: number;
        Following?: number;
        Gravatar_id?: string;
        Hireable?: boolean;
        Html_url?: string;
        Id?: number;
        Location?: string;
        Login?: string;
        Name?: string;
        Owned_private_repos?: number;
        Plan?: Plan;
        Private_gists?: number;
        Public_gists?: number;
        Public_repos?: number;
        Total_private_repos?: number;
        Type?: string;
        Url?: string;
    }
    
    export class UserKeysKeyId implements IUserKeysKeyId {
        Id?: number;
        Key?: string;
        Title?: string;
        Url?: string;
    
        constructor(data?: IUserKeysKeyId) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Key = data["key"] !== undefined ? data["key"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): UserKeysKeyId {
            let result = new UserKeysKeyId();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["key"] = this.Key !== undefined ? this.Key : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUserKeysKeyId {
        Id?: number;
        Key?: string;
        Title?: string;
        Url?: string;
    }
    
    export class UserKeysPost implements IUserKeysPost {
        Key?: string;
        Title?: string;
    
        constructor(data?: IUserKeysPost) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Key = data["key"] !== undefined ? data["key"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
            }
        }
    
        static fromJS(data: any): UserKeysPost {
            let result = new UserKeysPost();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["key"] = this.Key !== undefined ? this.Key : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            return data; 
        }
    }
    
    export interface IUserKeysPost {
        Key?: string;
        Title?: string;
    }
    
    export class UserUpdate implements IUserUpdate {
        Bio?: string;
        Blog?: string;
        Company?: string;
        Email?: string;
        Hireable?: boolean;
        Location?: string;
        Name?: string;
    
        constructor(data?: IUserUpdate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Bio = data["bio"] !== undefined ? data["bio"] : <any>null;
                this.Blog = data["blog"] !== undefined ? data["blog"] : <any>null;
                this.Company = data["company"] !== undefined ? data["company"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Hireable = data["hireable"] !== undefined ? data["hireable"] : <any>null;
                this.Location = data["location"] !== undefined ? data["location"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): UserUpdate {
            let result = new UserUpdate();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["bio"] = this.Bio !== undefined ? this.Bio : <any>null;
            data["blog"] = this.Blog !== undefined ? this.Blog : <any>null;
            data["company"] = this.Company !== undefined ? this.Company : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["hireable"] = this.Hireable !== undefined ? this.Hireable : <any>null;
            data["location"] = this.Location !== undefined ? this.Location : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IUserUpdate {
        Bio?: string;
        Blog?: string;
        Company?: string;
        Email?: string;
        Hireable?: boolean;
        Location?: string;
        Name?: string;
    }
    
    export class UserUserId implements IUserUserId {
        Avatar_url?: string;
        Bio?: string;
        Blog?: string;
        Company?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        /** Note: The returned email is the user’s publicly visible email address (or null if the user has not specified a public email address in their profile). */
        Email?: string;
        Followers?: number;
        Following?: number;
        Gravatar_id?: string;
        Hireable?: boolean;
        Html_url?: string;
        Id?: number;
        Location?: string;
        Login?: string;
        Name?: string;
        Public_gists?: number;
        Public_repos?: number;
        Type?: string;
        Url?: string;
    
        constructor(data?: IUserUserId) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Bio = data["bio"] !== undefined ? data["bio"] : <any>null;
                this.Blog = data["blog"] !== undefined ? data["blog"] : <any>null;
                this.Company = data["company"] !== undefined ? data["company"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Followers = data["followers"] !== undefined ? data["followers"] : <any>null;
                this.Following = data["following"] !== undefined ? data["following"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Hireable = data["hireable"] !== undefined ? data["hireable"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Location = data["location"] !== undefined ? data["location"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Public_gists = data["public_gists"] !== undefined ? data["public_gists"] : <any>null;
                this.Public_repos = data["public_repos"] !== undefined ? data["public_repos"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): UserUserId {
            let result = new UserUserId();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["bio"] = this.Bio !== undefined ? this.Bio : <any>null;
            data["blog"] = this.Blog !== undefined ? this.Blog : <any>null;
            data["company"] = this.Company !== undefined ? this.Company : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["followers"] = this.Followers !== undefined ? this.Followers : <any>null;
            data["following"] = this.Following !== undefined ? this.Following : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["hireable"] = this.Hireable !== undefined ? this.Hireable : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["location"] = this.Location !== undefined ? this.Location : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["public_gists"] = this.Public_gists !== undefined ? this.Public_gists : <any>null;
            data["public_repos"] = this.Public_repos !== undefined ? this.Public_repos : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUserUserId {
        Avatar_url?: string;
        Bio?: string;
        Blog?: string;
        Company?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        /** Note: The returned email is the user’s publicly visible email address (or null if the user has not specified a public email address in their profile). */
        Email?: string;
        Followers?: number;
        Following?: number;
        Gravatar_id?: string;
        Hireable?: boolean;
        Html_url?: string;
        Id?: number;
        Location?: string;
        Login?: string;
        Name?: string;
        Public_gists?: number;
        Public_repos?: number;
        Type?: string;
        Url?: string;
    }
    
    /** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
    export enum Filter {
        Assigned = <any>"assigned", 
        Created = <any>"created", 
        Mentioned = <any>"mentioned", 
        Subscribed = <any>"subscribed", 
        All = <any>"all", 
    }
    
    export enum State {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export enum Sort {
        Created = <any>"created", 
        Updated = <any>"updated", 
        Comments = <any>"comments", 
    }
    
    export enum Direction {
        Asc = <any>"asc", 
        Desc = <any>"desc", 
    }
    
    /** Indicates the state of the issues to return. Can be either open or closed. */
    export enum State2 {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    /** The sort field. if sort param is provided. Can be either asc or desc. */
    export enum Order {
        Desc = <any>"desc", 
        Asc = <any>"asc", 
    }
    
    /** The sort field. One of stars, forks, or updated. Default: results are sorted by best match. */
    export enum Sort2 {
        Updated = <any>"updated", 
        Stars = <any>"stars", 
        Forks = <any>"forks", 
    }
    
    /** The sort field. if sort param is provided. Can be either asc or desc. */
    export enum Order2 {
        Desc = <any>"desc", 
        Asc = <any>"asc", 
    }
    
    /** The sort field. One of stars, forks, or updated. Default: results are sorted by best match. */
    export enum Sort3 {
        Updated = <any>"updated", 
        Stars = <any>"stars", 
        Forks = <any>"forks", 
    }
    
    /** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
    export enum Filter2 {
        Assigned = <any>"assigned", 
        Created = <any>"created", 
        Mentioned = <any>"mentioned", 
        Subscribed = <any>"subscribed", 
        All = <any>"all", 
    }
    
    export enum State3 {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export enum Sort4 {
        Created = <any>"created", 
        Updated = <any>"updated", 
        Comments = <any>"comments", 
    }
    
    export enum Direction2 {
        Asc = <any>"asc", 
        Desc = <any>"desc", 
    }
    
    export enum Type {
        All = <any>"all", 
        Public = <any>"public", 
        Private = <any>"private", 
        Forks = <any>"forks", 
        Sources = <any>"sources", 
        Member = <any>"member", 
    }
    
    export enum Sort5 {
        Newes = <any>"newes", 
        Oldes = <any>"oldes", 
        Watchers = <any>"watchers", 
    }
    
    /** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
    export enum Filter3 {
        Assigned = <any>"assigned", 
        Created = <any>"created", 
        Mentioned = <any>"mentioned", 
        Subscribed = <any>"subscribed", 
        All = <any>"all", 
    }
    
    export enum State4 {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export enum Sort6 {
        Created = <any>"created", 
        Updated = <any>"updated", 
        Comments = <any>"comments", 
    }
    
    export enum Direction3 {
        Asc = <any>"asc", 
        Desc = <any>"desc", 
    }
    
    export enum Sort7 {
        Created = <any>"created", 
        Updated = <any>"updated", 
    }
    
    /** String to filter by state. */
    export enum State5 {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export enum Sort8 {
        Due_date = <any>"due_date", 
        Completeness = <any>"completeness", 
    }
    
    /** String to filter by state. */
    export enum State6 {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export enum Sort9 {
        Created = <any>"created", 
        Updated = <any>"updated", 
    }
    
    export enum Archive_format {
        Tarball = <any>"tarball", 
        Zipball = <any>"zipball", 
    }
    
    /** The sort field. if sort param is provided. Can be either asc or desc. */
    export enum Order3 {
        Desc = <any>"desc", 
        Asc = <any>"asc", 
    }
    
    /** Can only be 'indexed', which indicates how recently a file has been indexed by the GitHub search infrastructure. If not provided, results are sorted by best match. */
    export enum Sort10 {
        Indexed = <any>"indexed", 
    }
    
    /** The sort field. if sort param is provided. Can be either asc or desc. */
    export enum Order4 {
        Desc = <any>"desc", 
        Asc = <any>"asc", 
    }
    
    /** The sort field. Can be comments, created, or updated. Default: results are sorted by best match. */
    export enum Sort11 {
        Updated = <any>"updated", 
        Created = <any>"created", 
        Comments = <any>"comments", 
    }
    
    /** The sort field. if sort param is provided. Can be either asc or desc. */
    export enum Order5 {
        Desc = <any>"desc", 
        Asc = <any>"asc", 
    }
    
    /** If not provided, results are sorted by best match. */
    export enum Sort12 {
        Stars = <any>"stars", 
        Forks = <any>"forks", 
        Updated = <any>"updated", 
    }
    
    /** The sort field. if sort param is provided. Can be either asc or desc. */
    export enum Order6 {
        Desc = <any>"desc", 
        Asc = <any>"asc", 
    }
    
    /** If not provided, results are sorted by best match. */
    export enum Sort13 {
        Followers = <any>"followers", 
        Repositories = <any>"repositories", 
        Joined = <any>"joined", 
    }
    
    /** Issues assigned to you / created by you / mentioning you / you're subscribed to updates for / All issues the authenticated user can see */
    export enum Filter4 {
        Assigned = <any>"assigned", 
        Created = <any>"created", 
        Mentioned = <any>"mentioned", 
        Subscribed = <any>"subscribed", 
        All = <any>"all", 
    }
    
    export enum State7 {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export enum Sort14 {
        Created = <any>"created", 
        Updated = <any>"updated", 
        Comments = <any>"comments", 
    }
    
    export enum Direction4 {
        Asc = <any>"asc", 
        Desc = <any>"desc", 
    }
    
    export enum Type2 {
        All = <any>"all", 
        Public = <any>"public", 
        Private = <any>"private", 
        Forks = <any>"forks", 
        Sources = <any>"sources", 
        Member = <any>"member", 
    }
    
    export enum Sort15 {
        Created = <any>"created", 
        Updated = <any>"updated", 
    }
    
    export enum Type3 {
        All = <any>"all", 
        Public = <any>"public", 
        Private = <any>"private", 
        Forks = <any>"forks", 
        Sources = <any>"sources", 
        Member = <any>"member", 
    }
    
    export class Anonymous implements IAnonymous {
        Comments?: number;
        Comments_url?: string;
        Created_at?: string;
        Description?: string;
        Files?: Files6;
        Git_pull_url?: string;
        Git_push_url?: string;
        Html_url?: string;
        Id?: string;
        Public?: boolean;
        Url?: string;
        User?: User8;
    
        constructor(data?: IAnonymous) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Comments = data["comments"] !== undefined ? data["comments"] : <any>null;
                this.Comments_url = data["comments_url"] !== undefined ? data["comments_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Files = data["files"] ? Files6.fromJS(data["files"]) : <any>null;
                this.Git_pull_url = data["git_pull_url"] !== undefined ? data["git_pull_url"] : <any>null;
                this.Git_push_url = data["git_push_url"] !== undefined ? data["git_push_url"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Public = data["public"] !== undefined ? data["public"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User8.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous {
            let result = new Anonymous();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["comments"] = this.Comments !== undefined ? this.Comments : <any>null;
            data["comments_url"] = this.Comments_url !== undefined ? this.Comments_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["files"] = this.Files ? this.Files.toJSON() : <any>null;
            data["git_pull_url"] = this.Git_pull_url !== undefined ? this.Git_pull_url : <any>null;
            data["git_push_url"] = this.Git_push_url !== undefined ? this.Git_push_url : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["public"] = this.Public !== undefined ? this.Public : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous {
        Comments?: number;
        Comments_url?: string;
        Created_at?: string;
        Description?: string;
        Files?: Files6;
        Git_pull_url?: string;
        Git_push_url?: string;
        Html_url?: string;
        Id?: string;
        Public?: boolean;
        Url?: string;
        User?: User8;
    }
    
    export class Anonymous2 implements IAnonymous2 {
        Assignee?: Assignee;
        Body?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Closed_at?: string;
        Comments?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Html_url?: string;
        Labels?: Labels[];
        Milestone?: Milestone2;
        Number?: number;
        Pull_request?: Pull_request;
        State?: State8;
        Title?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User9;
    
        constructor(data?: IAnonymous2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Assignee = data["assignee"] ? Assignee.fromJS(data["assignee"]) : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Closed_at = data["closed_at"] !== undefined ? data["closed_at"] : <any>null;
                this.Comments = data["comments"] !== undefined ? data["comments"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                if (data["labels"] && data["labels"].constructor === Array) {
                    this.Labels = [];
                    for (let item of data["labels"])
                        this.Labels.push(Labels.fromJS(item));
                }
                this.Milestone = data["milestone"] ? Milestone2.fromJS(data["milestone"]) : <any>null;
                this.Number = data["number"] !== undefined ? data["number"] : <any>null;
                this.Pull_request = data["pull_request"] ? Pull_request.fromJS(data["pull_request"]) : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User9.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous2 {
            let result = new Anonymous2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["assignee"] = this.Assignee ? this.Assignee.toJSON() : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["closed_at"] = this.Closed_at !== undefined ? this.Closed_at : <any>null;
            data["comments"] = this.Comments !== undefined ? this.Comments : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            if (this.Labels && this.Labels.constructor === Array) {
                data["labels"] = [];
                for (let item of this.Labels)
                    data["labels"].push(item.toJSON());
            }
            data["milestone"] = this.Milestone ? this.Milestone.toJSON() : <any>null;
            data["number"] = this.Number !== undefined ? this.Number : <any>null;
            data["pull_request"] = this.Pull_request ? this.Pull_request.toJSON() : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous2 {
        Assignee?: Assignee;
        Body?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Closed_at?: string;
        Comments?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Html_url?: string;
        Labels?: Labels[];
        Milestone?: Milestone2;
        Number?: number;
        Pull_request?: Pull_request;
        State?: State8;
        Title?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User9;
    }
    
    export class Anonymous3 implements IAnonymous3 {
        Description?: string;
        Fork?: boolean;
        Full_name?: string;
        Html_url?: string;
        Id?: number;
        Name?: string;
        Owner?: Owner3;
        Private?: boolean;
        Url?: string;
    
        constructor(data?: IAnonymous3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Owner = data["owner"] ? Owner3.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous3 {
            let result = new Anonymous3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous3 {
        Description?: string;
        Fork?: boolean;
        Full_name?: string;
        Html_url?: string;
        Id?: number;
        Name?: string;
        Owner?: Owner3;
        Private?: boolean;
        Url?: string;
    }
    
    export class Anonymous4 implements IAnonymous4 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IAnonymous4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous4 {
            let result = new Anonymous4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous4 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Anonymous5 implements IAnonymous5 {
        Body?: string;
        /** ISO 8601. */
        Created_at?: string;
        Id?: number;
        Url?: string;
        User?: User10;
    
        constructor(data?: IAnonymous5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User10.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous5 {
            let result = new Anonymous5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous5 {
        Body?: string;
        /** ISO 8601. */
        Created_at?: string;
        Id?: number;
        Url?: string;
        User?: User10;
    }
    
    export class Anonymous6 implements IAnonymous6 {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner4;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IAnonymous6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner4.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous6 {
            let result = new Anonymous6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous6 {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner4;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class Anonymous7 implements IAnonymous7 {
        Id?: number;
        Name?: string;
        Url?: string;
    
        constructor(data?: IAnonymous7) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous7 {
            let result = new Anonymous7();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous7 {
        Id?: number;
        Name?: string;
        Url?: string;
    }
    
    export class Anonymous8 implements IAnonymous8 {
        Avatar_url?: number;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IAnonymous8) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous8 {
            let result = new Anonymous8();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous8 {
        Avatar_url?: number;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Anonymous9 implements IAnonymous9 {
        Commit?: Commit7;
        Name?: string;
    
        constructor(data?: IAnonymous9) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Commit = data["commit"] ? Commit7.fromJS(data["commit"]) : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous9 {
            let result = new Anonymous9();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["commit"] = this.Commit ? this.Commit.toJSON() : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous9 {
        Commit?: Commit7;
        Name?: string;
    }
    
    export class Anonymous10 implements IAnonymous10 {
        Body?: string;
        Commit_id?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Html_url?: string;
        Id?: number;
        Line?: number;
        Path?: string;
        Position?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User11;
    
        constructor(data?: IAnonymous10) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Commit_id = data["commit_id"] !== undefined ? data["commit_id"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Line = data["line"] !== undefined ? data["line"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Position = data["position"] !== undefined ? data["position"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User11.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous10 {
            let result = new Anonymous10();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["commit_id"] = this.Commit_id !== undefined ? this.Commit_id : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["line"] = this.Line !== undefined ? this.Line : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["position"] = this.Position !== undefined ? this.Position : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous10 {
        Body?: string;
        Commit_id?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Html_url?: string;
        Id?: number;
        Line?: number;
        Path?: string;
        Position?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User11;
    }
    
    export class Anonymous11 implements IAnonymous11 {
        Author?: Author7;
        Commit?: Commit8;
        Committer?: Committer6;
        Parents?: Parents4[];
        Sha?: string;
        Url?: string;
    
        constructor(data?: IAnonymous11) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author7.fromJS(data["author"]) : <any>null;
                this.Commit = data["commit"] ? Commit8.fromJS(data["commit"]) : <any>null;
                this.Committer = data["committer"] ? Committer6.fromJS(data["committer"]) : <any>null;
                if (data["parents"] && data["parents"].constructor === Array) {
                    this.Parents = [];
                    for (let item of data["parents"])
                        this.Parents.push(Parents4.fromJS(item));
                }
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous11 {
            let result = new Anonymous11();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["commit"] = this.Commit ? this.Commit.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            if (this.Parents && this.Parents.constructor === Array) {
                data["parents"] = [];
                for (let item of this.Parents)
                    data["parents"].push(item.toJSON());
            }
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous11 {
        Author?: Author7;
        Commit?: Commit8;
        Committer?: Committer6;
        Parents?: Parents4[];
        Sha?: string;
        Url?: string;
    }
    
    export class Anonymous12 implements IAnonymous12 {
        Commit_url?: string;
        Name?: string;
        Repository_url?: string;
        Sha?: string;
        State?: string;
        Statuses?: Statuses[];
    
        constructor(data?: IAnonymous12) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Commit_url = data["commit_url"] !== undefined ? data["commit_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Repository_url = data["repository_url"] !== undefined ? data["repository_url"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                if (data["statuses"] && data["statuses"].constructor === Array) {
                    this.Statuses = [];
                    for (let item of data["statuses"])
                        this.Statuses.push(Statuses.fromJS(item));
                }
            }
        }
    
        static fromJS(data: any): Anonymous12 {
            let result = new Anonymous12();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["commit_url"] = this.Commit_url !== undefined ? this.Commit_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["repository_url"] = this.Repository_url !== undefined ? this.Repository_url : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            if (this.Statuses && this.Statuses.constructor === Array) {
                data["statuses"] = [];
                for (let item of this.Statuses)
                    data["statuses"].push(item.toJSON());
            }
            return data; 
        }
    }
    
    export interface IAnonymous12 {
        Commit_url?: string;
        Name?: string;
        Repository_url?: string;
        Sha?: string;
        State?: string;
        Statuses?: Statuses[];
    }
    
    export class Anonymous13 implements IAnonymous13 {
        Avatar_url?: string;
        Contributions?: number;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IAnonymous13) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Contributions = data["contributions"] !== undefined ? data["contributions"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous13 {
            let result = new Anonymous13();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["contributions"] = this.Contributions !== undefined ? this.Contributions : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous13 {
        Avatar_url?: string;
        Contributions?: number;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Anonymous14 implements IAnonymous14 {
        Created_at?: string;
        Creator?: Creator3;
        Description?: string;
        Id?: number;
        Payload?: string;
        Sha?: string;
        Statuses_url?: string;
        Updated_at?: string;
        Url?: string;
    
        constructor(data?: IAnonymous14) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Creator = data["creator"] ? Creator3.fromJS(data["creator"]) : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Payload = data["payload"] !== undefined ? data["payload"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Statuses_url = data["statuses_url"] !== undefined ? data["statuses_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous14 {
            let result = new Anonymous14();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["creator"] = this.Creator ? this.Creator.toJSON() : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["payload"] = this.Payload !== undefined ? this.Payload : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["statuses_url"] = this.Statuses_url !== undefined ? this.Statuses_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous14 {
        Created_at?: string;
        Creator?: Creator3;
        Description?: string;
        Id?: number;
        Payload?: string;
        Sha?: string;
        Statuses_url?: string;
        Updated_at?: string;
        Url?: string;
    }
    
    export class Anonymous15 implements IAnonymous15 {
        Created_at?: string;
        Creator?: Creator4;
        Description?: string;
        Id?: number;
        Payload?: string;
        State?: string;
        Target_url?: string;
        Updated_at?: string;
        Url?: string;
    
        constructor(data?: IAnonymous15) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Creator = data["creator"] ? Creator4.fromJS(data["creator"]) : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Payload = data["payload"] !== undefined ? data["payload"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Target_url = data["target_url"] !== undefined ? data["target_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous15 {
            let result = new Anonymous15();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["creator"] = this.Creator ? this.Creator.toJSON() : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["payload"] = this.Payload !== undefined ? this.Payload : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["target_url"] = this.Target_url !== undefined ? this.Target_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous15 {
        Created_at?: string;
        Creator?: Creator4;
        Description?: string;
        Id?: number;
        Payload?: string;
        State?: string;
        Target_url?: string;
        Updated_at?: string;
        Url?: string;
    }
    
    export class Anonymous16 implements IAnonymous16 {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner5;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IAnonymous16) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner5.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous16 {
            let result = new Anonymous16();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous16 {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner5;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class Anonymous17 implements IAnonymous17 {
        Object?: Object4;
        Ref?: string;
        Url?: string;
    
        constructor(data?: IAnonymous17) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Object = data["object"] ? Object4.fromJS(data["object"]) : <any>null;
                this.Ref = data["ref"] !== undefined ? data["ref"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous17 {
            let result = new Anonymous17();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["object"] = this.Object ? this.Object.toJSON() : <any>null;
            data["ref"] = this.Ref !== undefined ? this.Ref : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous17 {
        Object?: Object4;
        Ref?: string;
        Url?: string;
    }
    
    export class Anonymous18 implements IAnonymous18 {
        Active?: boolean;
        Config?: Config;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Events?: Events2[];
        Id?: number;
        Name?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
    
        constructor(data?: IAnonymous18) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Active = data["active"] !== undefined ? data["active"] : <any>null;
                this.Config = data["config"] ? Config.fromJS(data["config"]) : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                if (data["events"] && data["events"].constructor === Array) {
                    this.Events = [];
                    for (let item of data["events"])
                        this.Events.push(item);
                }
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous18 {
            let result = new Anonymous18();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["active"] = this.Active !== undefined ? this.Active : <any>null;
            data["config"] = this.Config ? this.Config.toJSON() : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            if (this.Events && this.Events.constructor === Array) {
                data["events"] = [];
                for (let item of this.Events)
                    data["events"].push(item);
            }
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous18 {
        Active?: boolean;
        Config?: Config;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Events?: Events2[];
        Id?: number;
        Name?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
    }
    
    export class Anonymous19 implements IAnonymous19 {
        _links?: _links7;
        Body?: string;
        Commit_id?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Id?: number;
        Path?: string;
        Position?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User12;
    
        constructor(data?: IAnonymous19) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this._links = data["_links"] ? _links7.fromJS(data["_links"]) : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Commit_id = data["commit_id"] !== undefined ? data["commit_id"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Position = data["position"] !== undefined ? data["position"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User12.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous19 {
            let result = new Anonymous19();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["_links"] = this._links ? this._links.toJSON() : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["commit_id"] = this.Commit_id !== undefined ? this.Commit_id : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["position"] = this.Position !== undefined ? this.Position : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous19 {
        _links?: _links7;
        Body?: string;
        Commit_id?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Id?: number;
        Path?: string;
        Position?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User12;
    }
    
    export class Anonymous20 implements IAnonymous20 {
        Color?: string;
        Name?: string;
        Url?: string;
    
        constructor(data?: IAnonymous20) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Color = data["color"] !== undefined ? data["color"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous20 {
            let result = new Anonymous20();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["color"] = this.Color !== undefined ? this.Color : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous20 {
        Color?: string;
        Name?: string;
        Url?: string;
    }
    
    export class Anonymous21 implements IAnonymous21 {
        Id?: number;
        Key?: string;
        Title?: string;
        Url?: string;
    
        constructor(data?: IAnonymous21) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Key = data["key"] !== undefined ? data["key"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous21 {
            let result = new Anonymous21();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["key"] = this.Key !== undefined ? this.Key : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous21 {
        Id?: number;
        Key?: string;
        Title?: string;
        Url?: string;
    }
    
    export class Anonymous22 implements IAnonymous22 {
        _links?: _links8;
        Base?: Base2;
        Body?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Closed_at?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Diff_url?: string;
        Head?: Head2;
        Html_url?: string;
        Issue_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Merged_at?: string;
        Number?: number;
        Patch_url?: string;
        State?: State9;
        Title?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User13;
    
        constructor(data?: IAnonymous22) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this._links = data["_links"] ? _links8.fromJS(data["_links"]) : <any>null;
                this.Base = data["base"] ? Base2.fromJS(data["base"]) : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Closed_at = data["closed_at"] !== undefined ? data["closed_at"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Diff_url = data["diff_url"] !== undefined ? data["diff_url"] : <any>null;
                this.Head = data["head"] ? Head2.fromJS(data["head"]) : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Issue_url = data["issue_url"] !== undefined ? data["issue_url"] : <any>null;
                this.Merged_at = data["merged_at"] !== undefined ? data["merged_at"] : <any>null;
                this.Number = data["number"] !== undefined ? data["number"] : <any>null;
                this.Patch_url = data["patch_url"] !== undefined ? data["patch_url"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User13.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous22 {
            let result = new Anonymous22();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["_links"] = this._links ? this._links.toJSON() : <any>null;
            data["base"] = this.Base ? this.Base.toJSON() : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["closed_at"] = this.Closed_at !== undefined ? this.Closed_at : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["diff_url"] = this.Diff_url !== undefined ? this.Diff_url : <any>null;
            data["head"] = this.Head ? this.Head.toJSON() : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["issue_url"] = this.Issue_url !== undefined ? this.Issue_url : <any>null;
            data["merged_at"] = this.Merged_at !== undefined ? this.Merged_at : <any>null;
            data["number"] = this.Number !== undefined ? this.Number : <any>null;
            data["patch_url"] = this.Patch_url !== undefined ? this.Patch_url : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous22 {
        _links?: _links8;
        Base?: Base2;
        Body?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Closed_at?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Diff_url?: string;
        Head?: Head2;
        Html_url?: string;
        Issue_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Merged_at?: string;
        Number?: number;
        Patch_url?: string;
        State?: State9;
        Title?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User13;
    }
    
    export class Anonymous23 implements IAnonymous23 {
        Assets?: Assets2[];
        Assets_url?: string;
        Author?: Author8;
        Body?: string;
        Created_at?: string;
        Draft?: boolean;
        Html_url?: string;
        Id?: number;
        Name?: string;
        Prerelease?: boolean;
        Published_at?: string;
        Tag_name?: string;
        Tarball_url?: string;
        Target_commitish?: string;
        Upload_url?: string;
        Url?: string;
        Zipball_url?: string;
    
        constructor(data?: IAnonymous23) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["assets"] && data["assets"].constructor === Array) {
                    this.Assets = [];
                    for (let item of data["assets"])
                        this.Assets.push(Assets2.fromJS(item));
                }
                this.Assets_url = data["assets_url"] !== undefined ? data["assets_url"] : <any>null;
                this.Author = data["author"] ? Author8.fromJS(data["author"]) : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Draft = data["draft"] !== undefined ? data["draft"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Prerelease = data["prerelease"] !== undefined ? data["prerelease"] : <any>null;
                this.Published_at = data["published_at"] !== undefined ? data["published_at"] : <any>null;
                this.Tag_name = data["tag_name"] !== undefined ? data["tag_name"] : <any>null;
                this.Tarball_url = data["tarball_url"] !== undefined ? data["tarball_url"] : <any>null;
                this.Target_commitish = data["target_commitish"] !== undefined ? data["target_commitish"] : <any>null;
                this.Upload_url = data["upload_url"] !== undefined ? data["upload_url"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Zipball_url = data["zipball_url"] !== undefined ? data["zipball_url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous23 {
            let result = new Anonymous23();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Assets && this.Assets.constructor === Array) {
                data["assets"] = [];
                for (let item of this.Assets)
                    data["assets"].push(item.toJSON());
            }
            data["assets_url"] = this.Assets_url !== undefined ? this.Assets_url : <any>null;
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["draft"] = this.Draft !== undefined ? this.Draft : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["prerelease"] = this.Prerelease !== undefined ? this.Prerelease : <any>null;
            data["published_at"] = this.Published_at !== undefined ? this.Published_at : <any>null;
            data["tag_name"] = this.Tag_name !== undefined ? this.Tag_name : <any>null;
            data["tarball_url"] = this.Tarball_url !== undefined ? this.Tarball_url : <any>null;
            data["target_commitish"] = this.Target_commitish !== undefined ? this.Target_commitish : <any>null;
            data["upload_url"] = this.Upload_url !== undefined ? this.Upload_url : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["zipball_url"] = this.Zipball_url !== undefined ? this.Zipball_url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous23 {
        Assets?: Assets2[];
        Assets_url?: string;
        Author?: Author8;
        Body?: string;
        Created_at?: string;
        Draft?: boolean;
        Html_url?: string;
        Id?: number;
        Name?: string;
        Prerelease?: boolean;
        Published_at?: string;
        Tag_name?: string;
        Tarball_url?: string;
        Target_commitish?: string;
        Upload_url?: string;
        Url?: string;
        Zipball_url?: string;
    }
    
    export class Anonymous24 implements IAnonymous24 {
        Content_type?: string;
        Created_at?: string;
        Download_count?: number;
        Id?: number;
        Label?: string;
        Name?: string;
        Size?: number;
        State?: string;
        Updated_at?: string;
        Uploader?: Uploader2;
        Url?: string;
    
        constructor(data?: IAnonymous24) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content_type = data["content_type"] !== undefined ? data["content_type"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Download_count = data["download_count"] !== undefined ? data["download_count"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Label = data["label"] !== undefined ? data["label"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Uploader = data["uploader"] ? Uploader2.fromJS(data["uploader"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous24 {
            let result = new Anonymous24();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content_type"] = this.Content_type !== undefined ? this.Content_type : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["download_count"] = this.Download_count !== undefined ? this.Download_count : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["label"] = this.Label !== undefined ? this.Label : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["uploader"] = this.Uploader ? this.Uploader.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous24 {
        Content_type?: string;
        Created_at?: string;
        Download_count?: number;
        Id?: number;
        Label?: string;
        Name?: string;
        Size?: number;
        State?: string;
        Updated_at?: string;
        Uploader?: Uploader2;
        Url?: string;
    }
    
    export class Anonymous25 implements IAnonymous25 {
        Days?: number[];
        Total?: number;
        Week?: number;
    
        constructor(data?: IAnonymous25) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                if (data["days"] && data["days"].constructor === Array) {
                    this.Days = [];
                    for (let item of data["days"])
                        this.Days.push(item);
                }
                this.Total = data["total"] !== undefined ? data["total"] : <any>null;
                this.Week = data["week"] !== undefined ? data["week"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous25 {
            let result = new Anonymous25();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            if (this.Days && this.Days.constructor === Array) {
                data["days"] = [];
                for (let item of this.Days)
                    data["days"].push(item);
            }
            data["total"] = this.Total !== undefined ? this.Total : <any>null;
            data["week"] = this.Week !== undefined ? this.Week : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous25 {
        Days?: number[];
        Total?: number;
        Week?: number;
    }
    
    export class Anonymous26 implements IAnonymous26 {
        Author?: Author9;
        /** The Total number of commits authored by the contributor. */
        Total?: number;
        Weeks?: Weeks[];
    
        constructor(data?: IAnonymous26) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author9.fromJS(data["author"]) : <any>null;
                this.Total = data["total"] !== undefined ? data["total"] : <any>null;
                if (data["weeks"] && data["weeks"].constructor === Array) {
                    this.Weeks = [];
                    for (let item of data["weeks"])
                        this.Weeks.push(Weeks.fromJS(item));
                }
            }
        }
    
        static fromJS(data: any): Anonymous26 {
            let result = new Anonymous26();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["total"] = this.Total !== undefined ? this.Total : <any>null;
            if (this.Weeks && this.Weeks.constructor === Array) {
                data["weeks"] = [];
                for (let item of this.Weeks)
                    data["weeks"].push(item.toJSON());
            }
            return data; 
        }
    }
    
    export interface IAnonymous26 {
        Author?: Author9;
        /** The Total number of commits authored by the contributor. */
        Total?: number;
        Weeks?: Weeks[];
    }
    
    export class Anonymous27 implements IAnonymous27 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Creator?: Creator5;
        Description?: string;
        Id?: number;
        State?: string;
        Target_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
    
        constructor(data?: IAnonymous27) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Creator = data["creator"] ? Creator5.fromJS(data["creator"]) : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Target_url = data["target_url"] !== undefined ? data["target_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous27 {
            let result = new Anonymous27();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["creator"] = this.Creator ? this.Creator.toJSON() : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["target_url"] = this.Target_url !== undefined ? this.Target_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous27 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Creator?: Creator5;
        Description?: string;
        Id?: number;
        State?: string;
        Target_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
    }
    
    export class Anonymous28 implements IAnonymous28 {
        Clone_url?: string;
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: Language;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner6;
        Private?: boolean;
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IAnonymous28) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner6.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous28 {
            let result = new Anonymous28();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous28 {
        Clone_url?: string;
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: Language;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner6;
        Private?: boolean;
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class Anonymous29 implements IAnonymous29 {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: number;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner7;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IAnonymous29) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner7.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous29 {
            let result = new Anonymous29();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous29 {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: number;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner7;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class Anonymous30 implements IAnonymous30 {
        Id?: number;
        Members_count?: number;
        Name?: string;
        Organization?: Organization3;
        Permission?: string;
        Repos_count?: number;
        Url?: string;
    
        constructor(data?: IAnonymous30) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Members_count = data["members_count"] !== undefined ? data["members_count"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Organization = data["organization"] ? Organization3.fromJS(data["organization"]) : <any>null;
                this.Permission = data["permission"] !== undefined ? data["permission"] : <any>null;
                this.Repos_count = data["repos_count"] !== undefined ? data["repos_count"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Anonymous30 {
            let result = new Anonymous30();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["members_count"] = this.Members_count !== undefined ? this.Members_count : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["organization"] = this.Organization ? this.Organization.toJSON() : <any>null;
            data["permission"] = this.Permission !== undefined ? this.Permission : <any>null;
            data["repos_count"] = this.Repos_count !== undefined ? this.Repos_count : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAnonymous30 {
        Id?: number;
        Members_count?: number;
        Name?: string;
        Organization?: Organization3;
        Permission?: string;
        Repos_count?: number;
        Url?: string;
    }
    
    export class Uploader implements IUploader {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IUploader) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Uploader {
            let result = new Uploader();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUploader {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export enum BlobEncoding {
        Utf8 = <any>"utf-8", 
        Base64 = <any>"base64", 
    }
    
    export class _links implements I_links {
        Html?: string;
        Self?: string;
    
        constructor(data?: I_links) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Html = data["html"] !== undefined ? data["html"] : <any>null;
                this.Self = data["self"] !== undefined ? data["self"] : <any>null;
            }
        }
    
        static fromJS(data: any): _links {
            let result = new _links();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["html"] = this.Html !== undefined ? this.Html : <any>null;
            data["self"] = this.Self !== undefined ? this.Self : <any>null;
            return data; 
        }
    }
    
    export interface I_links {
        Html?: string;
        Self?: string;
    }
    
    export class Commit2 implements ICommit2 {
        Author?: Author10;
        Commit?: Commit9;
        Committer?: Committer7;
        Parents?: Parents5[];
        Sha?: string;
        Url?: string;
    
        constructor(data?: ICommit2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author10.fromJS(data["author"]) : <any>null;
                this.Commit = data["commit"] ? Commit9.fromJS(data["commit"]) : <any>null;
                this.Committer = data["committer"] ? Committer7.fromJS(data["committer"]) : <any>null;
                if (data["parents"] && data["parents"].constructor === Array) {
                    this.Parents = [];
                    for (let item of data["parents"])
                        this.Parents.push(Parents5.fromJS(item));
                }
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit2 {
            let result = new Commit2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["commit"] = this.Commit ? this.Commit.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            if (this.Parents && this.Parents.constructor === Array) {
                data["parents"] = [];
                for (let item of this.Parents)
                    data["parents"].push(item.toJSON());
            }
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit2 {
        Author?: Author10;
        Commit?: Commit9;
        Committer?: Committer7;
        Parents?: Parents5[];
        Sha?: string;
        Url?: string;
    }
    
    export class Author implements IAuthor {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IAuthor) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author {
            let result = new Author();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Commit3 implements ICommit3 {
        Author?: Author11;
        Committer?: Committer8;
        Message?: string;
        Tree?: Tree5;
        Url?: string;
    
        constructor(data?: ICommit3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author11.fromJS(data["author"]) : <any>null;
                this.Committer = data["committer"] ? Committer8.fromJS(data["committer"]) : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Tree = data["tree"] ? Tree5.fromJS(data["tree"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit3 {
            let result = new Commit3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["tree"] = this.Tree ? this.Tree.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit3 {
        Author?: Author11;
        Committer?: Committer8;
        Message?: string;
        Tree?: Tree5;
        Url?: string;
    }
    
    export class Committer implements ICommitter {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: ICommitter) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer {
            let result = new Committer();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Files implements IFiles {
        Additions?: number;
        Blob_url?: string;
        Changes?: number;
        Deletions?: number;
        Filename?: string;
        Patch?: string;
        Raw_url?: string;
        Status?: string;
    
        constructor(data?: IFiles) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Additions = data["additions"] !== undefined ? data["additions"] : <any>null;
                this.Blob_url = data["blob_url"] !== undefined ? data["blob_url"] : <any>null;
                this.Changes = data["changes"] !== undefined ? data["changes"] : <any>null;
                this.Deletions = data["deletions"] !== undefined ? data["deletions"] : <any>null;
                this.Filename = data["filename"] !== undefined ? data["filename"] : <any>null;
                this.Patch = data["patch"] !== undefined ? data["patch"] : <any>null;
                this.Raw_url = data["raw_url"] !== undefined ? data["raw_url"] : <any>null;
                this.Status = data["status"] !== undefined ? data["status"] : <any>null;
            }
        }
    
        static fromJS(data: any): Files {
            let result = new Files();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["additions"] = this.Additions !== undefined ? this.Additions : <any>null;
            data["blob_url"] = this.Blob_url !== undefined ? this.Blob_url : <any>null;
            data["changes"] = this.Changes !== undefined ? this.Changes : <any>null;
            data["deletions"] = this.Deletions !== undefined ? this.Deletions : <any>null;
            data["filename"] = this.Filename !== undefined ? this.Filename : <any>null;
            data["patch"] = this.Patch !== undefined ? this.Patch : <any>null;
            data["raw_url"] = this.Raw_url !== undefined ? this.Raw_url : <any>null;
            data["status"] = this.Status !== undefined ? this.Status : <any>null;
            return data; 
        }
    }
    
    export interface IFiles {
        Additions?: number;
        Blob_url?: string;
        Changes?: number;
        Deletions?: number;
        Filename?: string;
        Patch?: string;
        Raw_url?: string;
        Status?: string;
    }
    
    export class Parents implements IParents {
        Sha?: string;
        Url?: string;
    
        constructor(data?: IParents) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Parents {
            let result = new Parents();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IParents {
        Sha?: string;
        Url?: string;
    }
    
    export class Stats implements IStats {
        Additions?: number;
        Deletions?: number;
        Total?: number;
    
        constructor(data?: IStats) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Additions = data["additions"] !== undefined ? data["additions"] : <any>null;
                this.Deletions = data["deletions"] !== undefined ? data["deletions"] : <any>null;
                this.Total = data["total"] !== undefined ? data["total"] : <any>null;
            }
        }
    
        static fromJS(data: any): Stats {
            let result = new Stats();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["additions"] = this.Additions !== undefined ? this.Additions : <any>null;
            data["deletions"] = this.Deletions !== undefined ? this.Deletions : <any>null;
            data["total"] = this.Total !== undefined ? this.Total : <any>null;
            return data; 
        }
    }
    
    export interface IStats {
        Additions?: number;
        Deletions?: number;
        Total?: number;
    }
    
    export class User2 implements IUser2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User2 {
            let result = new User2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Base_commit implements IBase_commit {
        Author?: Author12;
        Commit?: Commit10;
        Committer?: Committer9;
        Parents?: Parents6[];
        Sha?: string;
        Url?: string;
    
        constructor(data?: IBase_commit) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author12.fromJS(data["author"]) : <any>null;
                this.Commit = data["commit"] ? Commit10.fromJS(data["commit"]) : <any>null;
                this.Committer = data["committer"] ? Committer9.fromJS(data["committer"]) : <any>null;
                if (data["parents"] && data["parents"].constructor === Array) {
                    this.Parents = [];
                    for (let item of data["parents"])
                        this.Parents.push(Parents6.fromJS(item));
                }
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Base_commit {
            let result = new Base_commit();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["commit"] = this.Commit ? this.Commit.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            if (this.Parents && this.Parents.constructor === Array) {
                data["parents"] = [];
                for (let item of this.Parents)
                    data["parents"].push(item.toJSON());
            }
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IBase_commit {
        Author?: Author12;
        Commit?: Commit10;
        Committer?: Committer9;
        Parents?: Parents6[];
        Sha?: string;
        Url?: string;
    }
    
    export class Commits implements ICommits {
        Author?: Author13;
        Commit?: Commit11;
        Committer?: Committer10;
        Parents?: Parents7[];
        Sha?: string;
        Url?: string;
    
        constructor(data?: ICommits) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author13.fromJS(data["author"]) : <any>null;
                this.Commit = data["commit"] ? Commit11.fromJS(data["commit"]) : <any>null;
                this.Committer = data["committer"] ? Committer10.fromJS(data["committer"]) : <any>null;
                if (data["parents"] && data["parents"].constructor === Array) {
                    this.Parents = [];
                    for (let item of data["parents"])
                        this.Parents.push(Parents7.fromJS(item));
                }
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commits {
            let result = new Commits();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["commit"] = this.Commit ? this.Commit.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            if (this.Parents && this.Parents.constructor === Array) {
                data["parents"] = [];
                for (let item of this.Parents)
                    data["parents"].push(item.toJSON());
            }
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommits {
        Author?: Author13;
        Commit?: Commit11;
        Committer?: Committer10;
        Parents?: Parents7[];
        Sha?: string;
        Url?: string;
    }
    
    export class Files2 implements IFiles2 {
        Additions?: number;
        Blob_url?: string;
        Changes?: number;
        Contents_url?: string;
        Deletions?: number;
        Filename?: string;
        Patch?: string;
        Raw_url?: string;
        Sha?: string;
        Status?: string;
    
        constructor(data?: IFiles2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Additions = data["additions"] !== undefined ? data["additions"] : <any>null;
                this.Blob_url = data["blob_url"] !== undefined ? data["blob_url"] : <any>null;
                this.Changes = data["changes"] !== undefined ? data["changes"] : <any>null;
                this.Contents_url = data["contents_url"] !== undefined ? data["contents_url"] : <any>null;
                this.Deletions = data["deletions"] !== undefined ? data["deletions"] : <any>null;
                this.Filename = data["filename"] !== undefined ? data["filename"] : <any>null;
                this.Patch = data["patch"] !== undefined ? data["patch"] : <any>null;
                this.Raw_url = data["raw_url"] !== undefined ? data["raw_url"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Status = data["status"] !== undefined ? data["status"] : <any>null;
            }
        }
    
        static fromJS(data: any): Files2 {
            let result = new Files2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["additions"] = this.Additions !== undefined ? this.Additions : <any>null;
            data["blob_url"] = this.Blob_url !== undefined ? this.Blob_url : <any>null;
            data["changes"] = this.Changes !== undefined ? this.Changes : <any>null;
            data["contents_url"] = this.Contents_url !== undefined ? this.Contents_url : <any>null;
            data["deletions"] = this.Deletions !== undefined ? this.Deletions : <any>null;
            data["filename"] = this.Filename !== undefined ? this.Filename : <any>null;
            data["patch"] = this.Patch !== undefined ? this.Patch : <any>null;
            data["raw_url"] = this.Raw_url !== undefined ? this.Raw_url : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["status"] = this.Status !== undefined ? this.Status : <any>null;
            return data; 
        }
    }
    
    export interface IFiles2 {
        Additions?: number;
        Blob_url?: string;
        Changes?: number;
        Contents_url?: string;
        Deletions?: number;
        Filename?: string;
        Patch?: string;
        Raw_url?: string;
        Sha?: string;
        Status?: string;
    }
    
    export class _links2 implements I_links2 {
        Git?: string;
        Html?: string;
        Self?: string;
    
        constructor(data?: I_links2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Git = data["git"] !== undefined ? data["git"] : <any>null;
                this.Html = data["html"] !== undefined ? data["html"] : <any>null;
                this.Self = data["self"] !== undefined ? data["self"] : <any>null;
            }
        }
    
        static fromJS(data: any): _links2 {
            let result = new _links2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["git"] = this.Git !== undefined ? this.Git : <any>null;
            data["html"] = this.Html !== undefined ? this.Html : <any>null;
            data["self"] = this.Self !== undefined ? this.Self : <any>null;
            return data; 
        }
    }
    
    export interface I_links2 {
        Git?: string;
        Html?: string;
        Self?: string;
    }
    
    export class Commit4 implements ICommit4 {
        Author?: Author14;
        Committer?: Committer11;
        Html_url?: string;
        Message?: string;
        Parents?: Parents8[];
        Sha?: string;
        Tree?: Tree6;
        Url?: string;
    
        constructor(data?: ICommit4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author14.fromJS(data["author"]) : <any>null;
                this.Committer = data["committer"] ? Committer11.fromJS(data["committer"]) : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                if (data["parents"] && data["parents"].constructor === Array) {
                    this.Parents = [];
                    for (let item of data["parents"])
                        this.Parents.push(Parents8.fromJS(item));
                }
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Tree = data["tree"] ? Tree6.fromJS(data["tree"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit4 {
            let result = new Commit4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            if (this.Parents && this.Parents.constructor === Array) {
                data["parents"] = [];
                for (let item of this.Parents)
                    data["parents"].push(item.toJSON());
            }
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["tree"] = this.Tree ? this.Tree.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit4 {
        Author?: Author14;
        Committer?: Committer11;
        Html_url?: string;
        Message?: string;
        Parents?: Parents8[];
        Sha?: string;
        Tree?: Tree6;
        Url?: string;
    }
    
    export class Content implements IContent {
        _links?: _links9;
        Git_url?: string;
        Html_url?: string;
        Name?: string;
        Path?: string;
        Sha?: string;
        Size?: number;
        Type?: string;
        Url?: string;
    
        constructor(data?: IContent) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this._links = data["_links"] ? _links9.fromJS(data["_links"]) : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Content {
            let result = new Content();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["_links"] = this._links ? this._links.toJSON() : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IContent {
        _links?: _links9;
        Git_url?: string;
        Html_url?: string;
        Name?: string;
        Path?: string;
        Sha?: string;
        Size?: number;
        Type?: string;
        Url?: string;
    }
    
    export class Committer2 implements ICommitter2 {
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer2 {
            let result = new Committer2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter2 {
        Email?: string;
        Name?: string;
    }
    
    export class Commit5 implements ICommit5 {
        Author?: Author15;
        Committer?: Committer12;
        Html_url?: string;
        Message?: string;
        Parents?: Parents9;
        Sha?: string;
        Tree?: Tree7;
        Url?: string;
    
        constructor(data?: ICommit5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author15.fromJS(data["author"]) : <any>null;
                this.Committer = data["committer"] ? Committer12.fromJS(data["committer"]) : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Parents = data["parents"] ? Parents9.fromJS(data["parents"]) : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Tree = data["tree"] ? Tree7.fromJS(data["tree"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit5 {
            let result = new Commit5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["parents"] = this.Parents ? this.Parents.toJSON() : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["tree"] = this.Tree ? this.Tree.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit5 {
        Author?: Author15;
        Committer?: Committer12;
        Html_url?: string;
        Message?: string;
        Parents?: Parents9;
        Sha?: string;
        Tree?: Tree7;
        Url?: string;
    }
    
    export class Committer3 implements ICommitter3 {
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer3 {
            let result = new Committer3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter3 {
        Email?: string;
        Name?: string;
    }
    
    export class Payload implements IPayload {
        Deploy_user?: string;
        Environment?: string;
        Room_id?: number;
    
        constructor(data?: IPayload) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Deploy_user = data["deploy_user"] !== undefined ? data["deploy_user"] : <any>null;
                this.Environment = data["environment"] !== undefined ? data["environment"] : <any>null;
                this.Room_id = data["room_id"] !== undefined ? data["room_id"] : <any>null;
            }
        }
    
        static fromJS(data: any): Payload {
            let result = new Payload();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["deploy_user"] = this.Deploy_user !== undefined ? this.Deploy_user : <any>null;
            data["environment"] = this.Environment !== undefined ? this.Environment : <any>null;
            data["room_id"] = this.Room_id !== undefined ? this.Room_id : <any>null;
            return data; 
        }
    }
    
    export interface IPayload {
        Deploy_user?: string;
        Environment?: string;
        Room_id?: number;
    }
    
    export class Creator implements ICreator {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: ICreator) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Creator {
            let result = new Creator();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICreator {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export enum EditTeamPermission {
        Pull = <any>"pull", 
        Push = <any>"push", 
        Admin = <any>"admin", 
    }
    
    export class Actor implements IActor {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IActor) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Actor {
            let result = new Actor();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IActor {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Issue2 implements IIssue2 {
        Assignee?: Assignee2;
        Body?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Closed_at?: string;
        Comments?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Html_url?: string;
        Labels?: Labels2[];
        Milestone?: Milestone3;
        Number?: number;
        Pull_request?: Pull_request2;
        State?: Issue2State;
        Title?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User14;
    
        constructor(data?: IIssue2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Assignee = data["assignee"] ? Assignee2.fromJS(data["assignee"]) : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Closed_at = data["closed_at"] !== undefined ? data["closed_at"] : <any>null;
                this.Comments = data["comments"] !== undefined ? data["comments"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                if (data["labels"] && data["labels"].constructor === Array) {
                    this.Labels = [];
                    for (let item of data["labels"])
                        this.Labels.push(Labels2.fromJS(item));
                }
                this.Milestone = data["milestone"] ? Milestone3.fromJS(data["milestone"]) : <any>null;
                this.Number = data["number"] !== undefined ? data["number"] : <any>null;
                this.Pull_request = data["pull_request"] ? Pull_request2.fromJS(data["pull_request"]) : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User14.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Issue2 {
            let result = new Issue2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["assignee"] = this.Assignee ? this.Assignee.toJSON() : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["closed_at"] = this.Closed_at !== undefined ? this.Closed_at : <any>null;
            data["comments"] = this.Comments !== undefined ? this.Comments : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            if (this.Labels && this.Labels.constructor === Array) {
                data["labels"] = [];
                for (let item of this.Labels)
                    data["labels"].push(item.toJSON());
            }
            data["milestone"] = this.Milestone ? this.Milestone.toJSON() : <any>null;
            data["number"] = this.Number !== undefined ? this.Number : <any>null;
            data["pull_request"] = this.Pull_request ? this.Pull_request.toJSON() : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IIssue2 {
        Assignee?: Assignee2;
        Body?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Closed_at?: string;
        Comments?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Html_url?: string;
        Labels?: Labels2[];
        Milestone?: Milestone3;
        Number?: number;
        Pull_request?: Pull_request2;
        State?: Issue2State;
        Title?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        User?: User14;
    }
    
    export class Actor2 implements IActor2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IActor2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Actor2 {
            let result = new Actor2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IActor2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Org implements IOrg {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOrg) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Org {
            let result = new Org();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOrg {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Repo2 implements IRepo2 {
        Id?: number;
        Name?: string;
        Url?: string;
    
        constructor(data?: IRepo2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Repo2 {
            let result = new Repo2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IRepo2 {
        Id?: number;
        Name?: string;
        Url?: string;
    }
    
    export class _links3 implements I_links3 {
        Current_user?: Current_user;
        Current_user_actor?: Current_user_actor;
        Current_user_organization?: Current_user_organization;
        Current_user_public?: Current_user_public;
        Timeline?: Timeline;
        User?: User15;
    
        constructor(data?: I_links3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Current_user = data["current_user"] ? Current_user.fromJS(data["current_user"]) : <any>null;
                this.Current_user_actor = data["current_user_actor"] ? Current_user_actor.fromJS(data["current_user_actor"]) : <any>null;
                this.Current_user_organization = data["current_user_organization"] ? Current_user_organization.fromJS(data["current_user_organization"]) : <any>null;
                this.Current_user_public = data["current_user_public"] ? Current_user_public.fromJS(data["current_user_public"]) : <any>null;
                this.Timeline = data["timeline"] ? Timeline.fromJS(data["timeline"]) : <any>null;
                this.User = data["user"] ? User15.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): _links3 {
            let result = new _links3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["current_user"] = this.Current_user ? this.Current_user.toJSON() : <any>null;
            data["current_user_actor"] = this.Current_user_actor ? this.Current_user_actor.toJSON() : <any>null;
            data["current_user_organization"] = this.Current_user_organization ? this.Current_user_organization.toJSON() : <any>null;
            data["current_user_public"] = this.Current_user_public ? this.Current_user_public.toJSON() : <any>null;
            data["timeline"] = this.Timeline ? this.Timeline.toJSON() : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface I_links3 {
        Current_user?: Current_user;
        Current_user_actor?: Current_user_actor;
        Current_user_organization?: Current_user_organization;
        Current_user_public?: Current_user_public;
        Timeline?: Timeline;
        User?: User15;
    }
    
    export class Owner implements IOwner {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner {
            let result = new Owner();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Files3 implements IFiles3 {
        RingErl?: RingErl;
    
        constructor(data?: IFiles3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.RingErl = data["ring.erl"] ? RingErl.fromJS(data["ring.erl"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Files3 {
            let result = new Files3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["ring.erl"] = this.RingErl ? this.RingErl.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IFiles3 {
        RingErl?: RingErl;
    }
    
    export class Forks implements IForks {
        /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
        Created_at?: string;
        Url?: string;
        User?: User16;
    
        constructor(data?: IForks) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User16.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Forks {
            let result = new Forks();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IForks {
        /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
        Created_at?: string;
        Url?: string;
        User?: User16;
    }
    
    export class History implements IHistory {
        Change_status?: Change_status;
        /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
        Committed_at?: string;
        Url?: string;
        User?: User17;
        Version?: string;
    
        constructor(data?: IHistory) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Change_status = data["change_status"] ? Change_status.fromJS(data["change_status"]) : <any>null;
                this.Committed_at = data["committed_at"] !== undefined ? data["committed_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User17.fromJS(data["user"]) : <any>null;
                this.Version = data["version"] !== undefined ? data["version"] : <any>null;
            }
        }
    
        static fromJS(data: any): History {
            let result = new History();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["change_status"] = this.Change_status ? this.Change_status.toJSON() : <any>null;
            data["committed_at"] = this.Committed_at !== undefined ? this.Committed_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            data["version"] = this.Version !== undefined ? this.Version : <any>null;
            return data; 
        }
    }
    
    export interface IHistory {
        Change_status?: Change_status;
        /** Timestamp in ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ. */
        Committed_at?: string;
        Url?: string;
        User?: User17;
        Version?: string;
    }
    
    export class User3 implements IUser3 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User3 {
            let result = new User3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser3 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Author2 implements IAuthor2 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author2 {
            let result = new Author2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor2 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Object implements IObject {
        Sha?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IObject) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Object {
            let result = new Object();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IObject {
        Sha?: string;
        Type?: string;
        Url?: string;
    }
    
    export class User4 implements IUser4 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User4 {
            let result = new User4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser4 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Author3 implements IAuthor3 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IAuthor3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author3 {
            let result = new Author3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor3 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Commit6 implements ICommit6 {
        Author?: Author16;
        Comment_count?: number;
        Committer?: Committer13;
        Message?: string;
        Tree?: Tree8;
        Url?: string;
    
        constructor(data?: ICommit6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author16.fromJS(data["author"]) : <any>null;
                this.Comment_count = data["comment_count"] !== undefined ? data["comment_count"] : <any>null;
                this.Committer = data["committer"] ? Committer13.fromJS(data["committer"]) : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Tree = data["tree"] ? Tree8.fromJS(data["tree"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit6 {
            let result = new Commit6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["comment_count"] = this.Comment_count !== undefined ? this.Comment_count : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["tree"] = this.Tree ? this.Tree.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit6 {
        Author?: Author16;
        Comment_count?: number;
        Committer?: Committer13;
        Message?: string;
        Tree?: Tree8;
        Url?: string;
    }
    
    export class Committer4 implements ICommitter4 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: ICommitter4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer4 {
            let result = new Committer4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter4 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Parents2 implements IParents2 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: IParents2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Parents2 {
            let result = new Parents2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IParents2 {
        Sha?: string;
        Url?: string;
    }
    
    export class Creator2 implements ICreator2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: ICreator2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Creator2 {
            let result = new Creator2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICreator2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export enum MilestoneState {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export class Repository implements IRepository {
        Description?: string;
        Fork?: boolean;
        Full_name?: string;
        Html_url?: string;
        Id?: number;
        Name?: string;
        Owner?: Owner8;
        Private?: boolean;
        Url?: string;
    
        constructor(data?: IRepository) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Owner = data["owner"] ? Owner8.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Repository {
            let result = new Repository();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IRepository {
        Description?: string;
        Fork?: boolean;
        Full_name?: string;
        Html_url?: string;
        Id?: number;
        Name?: string;
        Owner?: Owner8;
        Private?: boolean;
        Url?: string;
    }
    
    export class Subject implements ISubject {
        Latest_comment_url?: string;
        Title?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: ISubject) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Latest_comment_url = data["latest_comment_url"] !== undefined ? data["latest_comment_url"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Subject {
            let result = new Subject();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["latest_comment_url"] = this.Latest_comment_url !== undefined ? this.Latest_comment_url : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ISubject {
        Latest_comment_url?: string;
        Title?: string;
        Type?: string;
        Url?: string;
    }
    
    export enum OrgTeamsPostPermission {
        Pull = <any>"pull", 
        Push = <any>"push", 
        Admin = <any>"admin", 
    }
    
    export class Errors implements IErrors {
        Code?: string;
        Field?: string;
        Resource?: string;
    
        constructor(data?: IErrors) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Code = data["code"] !== undefined ? data["code"] : <any>null;
                this.Field = data["field"] !== undefined ? data["field"] : <any>null;
                this.Resource = data["resource"] !== undefined ? data["resource"] : <any>null;
            }
        }
    
        static fromJS(data: any): Errors {
            let result = new Errors();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["code"] = this.Code !== undefined ? this.Code : <any>null;
            data["field"] = this.Field !== undefined ? this.Field : <any>null;
            data["resource"] = this.Resource !== undefined ? this.Resource : <any>null;
            return data; 
        }
    }
    
    export interface IErrors {
        Code?: string;
        Field?: string;
        Resource?: string;
    }
    
    export class Files4 implements IFiles4 {
        Delete_this_fileTxt?: string;
        File1Txt?: File1Txt;
        New_fileTxt?: New_fileTxt;
        Old_nameTxt?: Old_nameTxt;
    
        constructor(data?: IFiles4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Delete_this_fileTxt = data["delete_this_file.txt"] !== undefined ? data["delete_this_file.txt"] : <any>null;
                this.File1Txt = data["file1.txt"] ? File1Txt.fromJS(data["file1.txt"]) : <any>null;
                this.New_fileTxt = data["new_file.txt"] ? New_fileTxt.fromJS(data["new_file.txt"]) : <any>null;
                this.Old_nameTxt = data["old_name.txt"] ? Old_nameTxt.fromJS(data["old_name.txt"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Files4 {
            let result = new Files4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["delete_this_file.txt"] = this.Delete_this_fileTxt !== undefined ? this.Delete_this_fileTxt : <any>null;
            data["file1.txt"] = this.File1Txt ? this.File1Txt.toJSON() : <any>null;
            data["new_file.txt"] = this.New_fileTxt ? this.New_fileTxt.toJSON() : <any>null;
            data["old_name.txt"] = this.Old_nameTxt ? this.Old_nameTxt.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IFiles4 {
        Delete_this_fileTxt?: string;
        File1Txt?: File1Txt;
        New_fileTxt?: New_fileTxt;
        Old_nameTxt?: Old_nameTxt;
    }
    
    export class Files5 implements IFiles5 {
        File1Txt?: File1Txt2;
    
        constructor(data?: IFiles5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.File1Txt = data["file1.txt"] ? File1Txt2.fromJS(data["file1.txt"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Files5 {
            let result = new Files5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["file1.txt"] = this.File1Txt ? this.File1Txt.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IFiles5 {
        File1Txt?: File1Txt2;
    }
    
    export class _links4 implements I_links4 {
        Comments?: Comments;
        Html?: Html;
        Review_comments?: Review_comments;
        Self?: Self;
    
        constructor(data?: I_links4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Comments = data["comments"] ? Comments.fromJS(data["comments"]) : <any>null;
                this.Html = data["html"] ? Html.fromJS(data["html"]) : <any>null;
                this.Review_comments = data["review_comments"] ? Review_comments.fromJS(data["review_comments"]) : <any>null;
                this.Self = data["self"] ? Self.fromJS(data["self"]) : <any>null;
            }
        }
    
        static fromJS(data: any): _links4 {
            let result = new _links4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["comments"] = this.Comments ? this.Comments.toJSON() : <any>null;
            data["html"] = this.Html ? this.Html.toJSON() : <any>null;
            data["review_comments"] = this.Review_comments ? this.Review_comments.toJSON() : <any>null;
            data["self"] = this.Self ? this.Self.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface I_links4 {
        Comments?: Comments;
        Html?: Html;
        Review_comments?: Review_comments;
        Self?: Self;
    }
    
    export class Base implements IBase {
        Label?: string;
        Ref?: string;
        Repo?: Repo3;
        Sha?: string;
        User?: User18;
    
        constructor(data?: IBase) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Label = data["label"] !== undefined ? data["label"] : <any>null;
                this.Ref = data["ref"] !== undefined ? data["ref"] : <any>null;
                this.Repo = data["repo"] ? Repo3.fromJS(data["repo"]) : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.User = data["user"] ? User18.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Base {
            let result = new Base();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["label"] = this.Label !== undefined ? this.Label : <any>null;
            data["ref"] = this.Ref !== undefined ? this.Ref : <any>null;
            data["repo"] = this.Repo ? this.Repo.toJSON() : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IBase {
        Label?: string;
        Ref?: string;
        Repo?: Repo3;
        Sha?: string;
        User?: User18;
    }
    
    export class Head implements IHead {
        Label?: string;
        Ref?: string;
        Repo?: Repo4;
        Sha?: string;
        User?: User19;
    
        constructor(data?: IHead) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Label = data["label"] !== undefined ? data["label"] : <any>null;
                this.Ref = data["ref"] !== undefined ? data["ref"] : <any>null;
                this.Repo = data["repo"] ? Repo4.fromJS(data["repo"]) : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.User = data["user"] ? User19.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Head {
            let result = new Head();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["label"] = this.Label !== undefined ? this.Label : <any>null;
            data["ref"] = this.Ref !== undefined ? this.Ref : <any>null;
            data["repo"] = this.Repo ? this.Repo.toJSON() : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IHead {
        Label?: string;
        Ref?: string;
        Repo?: Repo4;
        Sha?: string;
        User?: User19;
    }
    
    export class Merged_by implements IMerged_by {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IMerged_by) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Merged_by {
            let result = new Merged_by();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IMerged_by {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class User5 implements IUser5 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User5 {
            let result = new User5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser5 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class _links5 implements I_links5 {
        Html?: Html2;
        Pull_request?: Pull_request3;
        Self?: Self2;
    
        constructor(data?: I_links5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Html = data["html"] ? Html2.fromJS(data["html"]) : <any>null;
                this.Pull_request = data["pull_request"] ? Pull_request3.fromJS(data["pull_request"]) : <any>null;
                this.Self = data["self"] ? Self2.fromJS(data["self"]) : <any>null;
            }
        }
    
        static fromJS(data: any): _links5 {
            let result = new _links5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["html"] = this.Html ? this.Html.toJSON() : <any>null;
            data["pull_request"] = this.Pull_request ? this.Pull_request.toJSON() : <any>null;
            data["self"] = this.Self ? this.Self.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface I_links5 {
        Html?: Html2;
        Pull_request?: Pull_request3;
        Self?: Self2;
    }
    
    export class User6 implements IUser6 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User6 {
            let result = new User6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser6 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Rate implements IRate {
        Limit?: number;
        Remaining?: number;
        Reset?: number;
    
        constructor(data?: IRate) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Limit = data["limit"] !== undefined ? data["limit"] : <any>null;
                this.Remaining = data["remaining"] !== undefined ? data["remaining"] : <any>null;
                this.Reset = data["reset"] !== undefined ? data["reset"] : <any>null;
            }
        }
    
        static fromJS(data: any): Rate {
            let result = new Rate();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["limit"] = this.Limit !== undefined ? this.Limit : <any>null;
            data["remaining"] = this.Remaining !== undefined ? this.Remaining : <any>null;
            data["reset"] = this.Reset !== undefined ? this.Reset : <any>null;
            return data; 
        }
    }
    
    export interface IRate {
        Limit?: number;
        Remaining?: number;
        Reset?: number;
    }
    
    export class _links6 implements I_links6 {
        Git?: string;
        Html?: string;
        Self?: string;
    
        constructor(data?: I_links6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Git = data["git"] !== undefined ? data["git"] : <any>null;
                this.Html = data["html"] !== undefined ? data["html"] : <any>null;
                this.Self = data["self"] !== undefined ? data["self"] : <any>null;
            }
        }
    
        static fromJS(data: any): _links6 {
            let result = new _links6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["git"] = this.Git !== undefined ? this.Git : <any>null;
            data["html"] = this.Html !== undefined ? this.Html : <any>null;
            data["self"] = this.Self !== undefined ? this.Self : <any>null;
            return data; 
        }
    }
    
    export interface I_links6 {
        Git?: string;
        Html?: string;
        Self?: string;
    }
    
    export class Object2 implements IObject2 {
        Sha?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IObject2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Object2 {
            let result = new Object2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IObject2 {
        Sha?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Assets implements IAssets {
        Content_type?: string;
        Created_at?: string;
        Download_count?: number;
        Id?: number;
        Label?: string;
        Name?: string;
        Size?: number;
        State?: string;
        Updated_at?: string;
        Uploader?: Uploader3;
        Url?: string;
    
        constructor(data?: IAssets) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content_type = data["content_type"] !== undefined ? data["content_type"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Download_count = data["download_count"] !== undefined ? data["download_count"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Label = data["label"] !== undefined ? data["label"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Uploader = data["uploader"] ? Uploader3.fromJS(data["uploader"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Assets {
            let result = new Assets();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content_type"] = this.Content_type !== undefined ? this.Content_type : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["download_count"] = this.Download_count !== undefined ? this.Download_count : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["label"] = this.Label !== undefined ? this.Label : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["uploader"] = this.Uploader ? this.Uploader.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAssets {
        Content_type?: string;
        Created_at?: string;
        Download_count?: number;
        Id?: number;
        Label?: string;
        Name?: string;
        Size?: number;
        State?: string;
        Updated_at?: string;
        Uploader?: Uploader3;
        Url?: string;
    }
    
    export class Author4 implements IAuthor4 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IAuthor4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author4 {
            let result = new Author4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor4 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Organization2 implements IOrganization2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IOrganization2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Organization2 {
            let result = new Organization2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOrganization2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Owner2 implements IOwner2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner2 {
            let result = new Owner2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Parent implements IParent {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner9;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IParent) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner9.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Parent {
            let result = new Parent();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IParent {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner9;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class Source implements ISource {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner10;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: ISource) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner10.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Source {
            let result = new Source();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface ISource {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner10;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class Author5 implements IAuthor5 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author5 {
            let result = new Author5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor5 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Committer5 implements ICommitter5 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer5 {
            let result = new Committer5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter5 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Parents3 implements IParents3 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: IParents3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Parents3 {
            let result = new Parents3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IParents3 {
        Sha?: string;
        Url?: string;
    }
    
    export class Tree2 implements ITree2 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: ITree2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree2 {
            let result = new Tree2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree2 {
        Sha?: string;
        Url?: string;
    }
    
    export class Author6 implements IAuthor6 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author6 {
            let result = new Author6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor6 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Items implements IItems {
        Git_url?: string;
        Html_url?: string;
        Name?: string;
        Path?: string;
        Repository?: Repository2;
        Score?: number;
        Sha?: string;
        Url?: string;
    
        constructor(data?: IItems) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Repository = data["repository"] ? Repository2.fromJS(data["repository"]) : <any>null;
                this.Score = data["score"] !== undefined ? data["score"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Items {
            let result = new Items();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["repository"] = this.Repository ? this.Repository.toJSON() : <any>null;
            data["score"] = this.Score !== undefined ? this.Score : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IItems {
        Git_url?: string;
        Html_url?: string;
        Name?: string;
        Path?: string;
        Repository?: Repository2;
        Score?: number;
        Sha?: string;
        Url?: string;
    }
    
    export class Items2 implements IItems2 {
        Assignee?: Assignee3;
        Body?: string;
        Closed_at?: Closed_at;
        Comments?: number;
        Comments_url?: string;
        Created_at?: string;
        Events_url?: string;
        Html_url?: string;
        Id?: number;
        Labels?: Labels3[];
        Labels_url?: string;
        Milestone?: Milestone4;
        Number?: number;
        Pull_request?: Pull_request4;
        Score?: number;
        State?: string;
        Title?: string;
        Updated_at?: string;
        Url?: string;
        User?: User20;
    
        constructor(data?: IItems2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Assignee = data["assignee"] !== undefined ? data["assignee"] : <any>null;
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Closed_at = data["closed_at"] !== undefined ? data["closed_at"] : <any>null;
                this.Comments = data["comments"] !== undefined ? data["comments"] : <any>null;
                this.Comments_url = data["comments_url"] !== undefined ? data["comments_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                if (data["labels"] && data["labels"].constructor === Array) {
                    this.Labels = [];
                    for (let item of data["labels"])
                        this.Labels.push(Labels3.fromJS(item));
                }
                this.Labels_url = data["labels_url"] !== undefined ? data["labels_url"] : <any>null;
                this.Milestone = data["milestone"] !== undefined ? data["milestone"] : <any>null;
                this.Number = data["number"] !== undefined ? data["number"] : <any>null;
                this.Pull_request = data["pull_request"] ? Pull_request4.fromJS(data["pull_request"]) : <any>null;
                this.Score = data["score"] !== undefined ? data["score"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.User = data["user"] ? User20.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Items2 {
            let result = new Items2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["assignee"] = this.Assignee !== undefined ? this.Assignee : <any>null;
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["closed_at"] = this.Closed_at !== undefined ? this.Closed_at : <any>null;
            data["comments"] = this.Comments !== undefined ? this.Comments : <any>null;
            data["comments_url"] = this.Comments_url !== undefined ? this.Comments_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            if (this.Labels && this.Labels.constructor === Array) {
                data["labels"] = [];
                for (let item of this.Labels)
                    data["labels"].push(item.toJSON());
            }
            data["labels_url"] = this.Labels_url !== undefined ? this.Labels_url : <any>null;
            data["milestone"] = this.Milestone !== undefined ? this.Milestone : <any>null;
            data["number"] = this.Number !== undefined ? this.Number : <any>null;
            data["pull_request"] = this.Pull_request ? this.Pull_request.toJSON() : <any>null;
            data["score"] = this.Score !== undefined ? this.Score : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IItems2 {
        Assignee?: Assignee3;
        Body?: string;
        Closed_at?: Closed_at;
        Comments?: number;
        Comments_url?: string;
        Created_at?: string;
        Events_url?: string;
        Html_url?: string;
        Id?: number;
        Labels?: Labels3[];
        Labels_url?: string;
        Milestone?: Milestone4;
        Number?: number;
        Pull_request?: Pull_request4;
        Score?: number;
        State?: string;
        Title?: string;
        Updated_at?: string;
        Url?: string;
        User?: User20;
    }
    
    export class Issues implements IIssues {
        Body?: string;
        Comments?: number;
        Created_at?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Labels?: string[];
        Number?: number;
        Position?: number;
        State?: string;
        Title?: string;
        Updated_at?: string;
        User?: string;
        Votes?: number;
    
        constructor(data?: IIssues) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Body = data["body"] !== undefined ? data["body"] : <any>null;
                this.Comments = data["comments"] !== undefined ? data["comments"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                if (data["labels"] && data["labels"].constructor === Array) {
                    this.Labels = [];
                    for (let item of data["labels"])
                        this.Labels.push(item);
                }
                this.Number = data["number"] !== undefined ? data["number"] : <any>null;
                this.Position = data["position"] !== undefined ? data["position"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.User = data["user"] !== undefined ? data["user"] : <any>null;
                this.Votes = data["votes"] !== undefined ? data["votes"] : <any>null;
            }
        }
    
        static fromJS(data: any): Issues {
            let result = new Issues();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["body"] = this.Body !== undefined ? this.Body : <any>null;
            data["comments"] = this.Comments !== undefined ? this.Comments : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            if (this.Labels && this.Labels.constructor === Array) {
                data["labels"] = [];
                for (let item of this.Labels)
                    data["labels"].push(item);
            }
            data["number"] = this.Number !== undefined ? this.Number : <any>null;
            data["position"] = this.Position !== undefined ? this.Position : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["user"] = this.User !== undefined ? this.User : <any>null;
            data["votes"] = this.Votes !== undefined ? this.Votes : <any>null;
            return data; 
        }
    }
    
    export interface IIssues {
        Body?: string;
        Comments?: number;
        Created_at?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Labels?: string[];
        Number?: number;
        Position?: number;
        State?: string;
        Title?: string;
        Updated_at?: string;
        User?: string;
        Votes?: number;
    }
    
    export class Items3 implements IItems3 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Default_branch?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner11;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Score?: number;
        Size?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IItems3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Default_branch = data["default_branch"] !== undefined ? data["default_branch"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner11.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Score = data["score"] !== undefined ? data["score"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Items3 {
            let result = new Items3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["default_branch"] = this.Default_branch !== undefined ? this.Default_branch : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["score"] = this.Score !== undefined ? this.Score : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IItems3 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Default_branch?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner11;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Score?: number;
        Size?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class Repositories implements IRepositories {
        Created?: string;
        Created_at?: string;
        Description?: string;
        Followers?: number;
        Fork?: boolean;
        Forks?: number;
        Has_downloads?: boolean;
        Has_issues?: boolean;
        Has_wiki?: boolean;
        Homepage?: string;
        Language?: string;
        Name?: string;
        Open_issues?: number;
        Owner?: string;
        Private?: boolean;
        Pushed?: string;
        Pushed_at?: string;
        Score?: number;
        Size?: number;
        Type?: string;
        Url?: string;
        Username?: string;
        Watchers?: number;
    
        constructor(data?: IRepositories) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created = data["created"] !== undefined ? data["created"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Followers = data["followers"] !== undefined ? data["followers"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Has_downloads = data["has_downloads"] !== undefined ? data["has_downloads"] : <any>null;
                this.Has_issues = data["has_issues"] !== undefined ? data["has_issues"] : <any>null;
                this.Has_wiki = data["has_wiki"] !== undefined ? data["has_wiki"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Owner = data["owner"] !== undefined ? data["owner"] : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed = data["pushed"] !== undefined ? data["pushed"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Score = data["score"] !== undefined ? data["score"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Username = data["username"] !== undefined ? data["username"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
            }
        }
    
        static fromJS(data: any): Repositories {
            let result = new Repositories();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created"] = this.Created !== undefined ? this.Created : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["followers"] = this.Followers !== undefined ? this.Followers : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["has_downloads"] = this.Has_downloads !== undefined ? this.Has_downloads : <any>null;
            data["has_issues"] = this.Has_issues !== undefined ? this.Has_issues : <any>null;
            data["has_wiki"] = this.Has_wiki !== undefined ? this.Has_wiki : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["owner"] = this.Owner !== undefined ? this.Owner : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed"] = this.Pushed !== undefined ? this.Pushed : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["score"] = this.Score !== undefined ? this.Score : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["username"] = this.Username !== undefined ? this.Username : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            return data; 
        }
    }
    
    export interface IRepositories {
        Created?: string;
        Created_at?: string;
        Description?: string;
        Followers?: number;
        Fork?: boolean;
        Forks?: number;
        Has_downloads?: boolean;
        Has_issues?: boolean;
        Has_wiki?: boolean;
        Homepage?: string;
        Language?: string;
        Name?: string;
        Open_issues?: number;
        Owner?: string;
        Private?: boolean;
        Pushed?: string;
        Pushed_at?: string;
        Score?: number;
        Size?: number;
        Type?: string;
        Url?: string;
        Username?: string;
        Watchers?: number;
    }
    
    export class User7 implements IUser7 {
        Blog?: string;
        Company?: string;
        Created?: string;
        Created_at?: string;
        Email?: string;
        Followers_count?: number;
        Following_count?: number;
        Gravatar_id?: string;
        Id?: number;
        Location?: string;
        Login?: string;
        Name?: string;
        Public_gist_count?: number;
        Public_repo_count?: number;
        Type?: string;
    
        constructor(data?: IUser7) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Blog = data["blog"] !== undefined ? data["blog"] : <any>null;
                this.Company = data["company"] !== undefined ? data["company"] : <any>null;
                this.Created = data["created"] !== undefined ? data["created"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Followers_count = data["followers_count"] !== undefined ? data["followers_count"] : <any>null;
                this.Following_count = data["following_count"] !== undefined ? data["following_count"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Location = data["location"] !== undefined ? data["location"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Public_gist_count = data["public_gist_count"] !== undefined ? data["public_gist_count"] : <any>null;
                this.Public_repo_count = data["public_repo_count"] !== undefined ? data["public_repo_count"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
            }
        }
    
        static fromJS(data: any): User7 {
            let result = new User7();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["blog"] = this.Blog !== undefined ? this.Blog : <any>null;
            data["company"] = this.Company !== undefined ? this.Company : <any>null;
            data["created"] = this.Created !== undefined ? this.Created : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["followers_count"] = this.Followers_count !== undefined ? this.Followers_count : <any>null;
            data["following_count"] = this.Following_count !== undefined ? this.Following_count : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["location"] = this.Location !== undefined ? this.Location : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["public_gist_count"] = this.Public_gist_count !== undefined ? this.Public_gist_count : <any>null;
            data["public_repo_count"] = this.Public_repo_count !== undefined ? this.Public_repo_count : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            return data; 
        }
    }
    
    export interface IUser7 {
        Blog?: string;
        Company?: string;
        Created?: string;
        Created_at?: string;
        Email?: string;
        Followers_count?: number;
        Following_count?: number;
        Gravatar_id?: string;
        Id?: number;
        Location?: string;
        Login?: string;
        Name?: string;
        Public_gist_count?: number;
        Public_repo_count?: number;
        Type?: string;
    }
    
    export class Items4 implements IItems4 {
        Avatar_url?: string;
        Followers_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Score?: number;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IItems4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Score = data["score"] !== undefined ? data["score"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Items4 {
            let result = new Items4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["score"] = this.Score !== undefined ? this.Score : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IItems4 {
        Avatar_url?: string;
        Followers_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Score?: number;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Users implements IUsers {
        Created?: string;
        Created_at?: string;
        Followers?: number;
        Followers_count?: number;
        Fullname?: string;
        Gravatar_id?: string;
        Id?: string;
        Language?: string;
        Location?: string;
        Login?: string;
        Name?: string;
        Public_repo_count?: number;
        Repos?: number;
        Score?: number;
        Type?: string;
        Username?: string;
    
        constructor(data?: IUsers) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Created = data["created"] !== undefined ? data["created"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Followers = data["followers"] !== undefined ? data["followers"] : <any>null;
                this.Followers_count = data["followers_count"] !== undefined ? data["followers_count"] : <any>null;
                this.Fullname = data["fullname"] !== undefined ? data["fullname"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Location = data["location"] !== undefined ? data["location"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Public_repo_count = data["public_repo_count"] !== undefined ? data["public_repo_count"] : <any>null;
                this.Repos = data["repos"] !== undefined ? data["repos"] : <any>null;
                this.Score = data["score"] !== undefined ? data["score"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Username = data["username"] !== undefined ? data["username"] : <any>null;
            }
        }
    
        static fromJS(data: any): Users {
            let result = new Users();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["created"] = this.Created !== undefined ? this.Created : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["followers"] = this.Followers !== undefined ? this.Followers : <any>null;
            data["followers_count"] = this.Followers_count !== undefined ? this.Followers_count : <any>null;
            data["fullname"] = this.Fullname !== undefined ? this.Fullname : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["location"] = this.Location !== undefined ? this.Location : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["public_repo_count"] = this.Public_repo_count !== undefined ? this.Public_repo_count : <any>null;
            data["repos"] = this.Repos !== undefined ? this.Repos : <any>null;
            data["score"] = this.Score !== undefined ? this.Score : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["username"] = this.Username !== undefined ? this.Username : <any>null;
            return data; 
        }
    }
    
    export interface IUsers {
        Created?: string;
        Created_at?: string;
        Followers?: number;
        Followers_count?: number;
        Fullname?: string;
        Gravatar_id?: string;
        Id?: string;
        Language?: string;
        Location?: string;
        Login?: string;
        Name?: string;
        Public_repo_count?: number;
        Repos?: number;
        Score?: number;
        Type?: string;
        Username?: string;
    }
    
    export class Object3 implements IObject3 {
        Sha?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IObject3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Object3 {
            let result = new Object3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IObject3 {
        Sha?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Tagger implements ITagger {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: ITagger) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tagger {
            let result = new Tagger();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ITagger {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Tagger2 implements ITagger2 {
        /** Timestamp of when this object was tagged. */
        Date?: string;
        /** String of the email of the author of the tag. */
        Email?: string;
        /** String of the name of the author of the tag. */
        Name?: string;
    
        constructor(data?: ITagger2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tagger2 {
            let result = new Tagger2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ITagger2 {
        /** Timestamp of when this object was tagged. */
        Date?: string;
        /** String of the email of the author of the tag. */
        Email?: string;
        /** String of the name of the author of the tag. */
        Name?: string;
    }
    
    export class Tree3 implements ITree3 {
        Mode?: string;
        Path?: string;
        Sha?: string;
        Size?: number;
        Type?: string;
        Url?: string;
    
        constructor(data?: ITree3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Mode = data["mode"] !== undefined ? data["mode"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree3 {
            let result = new Tree3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["mode"] = this.Mode !== undefined ? this.Mode : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree3 {
        Mode?: string;
        Path?: string;
        Sha?: string;
        Size?: number;
        Type?: string;
        Url?: string;
    }
    
    export class Tree4 implements ITree4 {
        /** One of 100644 for file (blob), 100755 for executable (blob), 040000 for subdirectory (tree), 160000 for submodule (commit) or 120000 for a blob that specifies the path of a symlink. */
        Mode?: Tree4Mode;
        Path?: string;
        /** SHA1 checksum ID of the object in the tree. */
        Sha?: string;
        Type?: Tree4Type;
        Url?: string;
    
        constructor(data?: ITree4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Mode = data["mode"] !== undefined ? data["mode"] : <any>null;
                this.Path = data["path"] !== undefined ? data["path"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree4 {
            let result = new Tree4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["mode"] = this.Mode !== undefined ? this.Mode : <any>null;
            data["path"] = this.Path !== undefined ? this.Path : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree4 {
        /** One of 100644 for file (blob), 100755 for executable (blob), 040000 for subdirectory (tree), 160000 for submodule (commit) or 120000 for a blob that specifies the path of a symlink. */
        Mode?: Tree4Mode;
        Path?: string;
        /** SHA1 checksum ID of the object in the tree. */
        Sha?: string;
        Type?: Tree4Type;
        Url?: string;
    }
    
    export class Plan implements IPlan {
        Collaborators?: number;
        Name?: string;
        Private_repos?: number;
        Space?: number;
    
        constructor(data?: IPlan) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Collaborators = data["collaborators"] !== undefined ? data["collaborators"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Private_repos = data["private_repos"] !== undefined ? data["private_repos"] : <any>null;
                this.Space = data["space"] !== undefined ? data["space"] : <any>null;
            }
        }
    
        static fromJS(data: any): Plan {
            let result = new Plan();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["collaborators"] = this.Collaborators !== undefined ? this.Collaborators : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["private_repos"] = this.Private_repos !== undefined ? this.Private_repos : <any>null;
            data["space"] = this.Space !== undefined ? this.Space : <any>null;
            return data; 
        }
    }
    
    export interface IPlan {
        Collaborators?: number;
        Name?: string;
        Private_repos?: number;
        Space?: number;
    }
    
    export class Files6 implements IFiles6 {
        RingErl?: RingErl2;
    
        constructor(data?: IFiles6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.RingErl = data["ring.erl"] ? RingErl2.fromJS(data["ring.erl"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Files6 {
            let result = new Files6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["ring.erl"] = this.RingErl ? this.RingErl.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IFiles6 {
        RingErl?: RingErl2;
    }
    
    export class User8 implements IUser8 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser8) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User8 {
            let result = new User8();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser8 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Assignee implements IAssignee {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IAssignee) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Assignee {
            let result = new Assignee();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAssignee {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Labels implements ILabels {
        Color?: string;
        Name?: string;
        Url?: string;
    
        constructor(data?: ILabels) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Color = data["color"] !== undefined ? data["color"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Labels {
            let result = new Labels();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["color"] = this.Color !== undefined ? this.Color : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ILabels {
        Color?: string;
        Name?: string;
        Url?: string;
    }
    
    export class Milestone2 implements IMilestone2 {
        Closed_issues?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Creator?: Creator6;
        Description?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Due_on?: string;
        Number?: number;
        Open_issues?: number;
        State?: Milestone2State;
        Title?: string;
        Url?: string;
    
        constructor(data?: IMilestone2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Closed_issues = data["closed_issues"] !== undefined ? data["closed_issues"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Creator = data["creator"] ? Creator6.fromJS(data["creator"]) : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Due_on = data["due_on"] !== undefined ? data["due_on"] : <any>null;
                this.Number = data["number"] !== undefined ? data["number"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Milestone2 {
            let result = new Milestone2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["closed_issues"] = this.Closed_issues !== undefined ? this.Closed_issues : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["creator"] = this.Creator ? this.Creator.toJSON() : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["due_on"] = this.Due_on !== undefined ? this.Due_on : <any>null;
            data["number"] = this.Number !== undefined ? this.Number : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IMilestone2 {
        Closed_issues?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Creator?: Creator6;
        Description?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Due_on?: string;
        Number?: number;
        Open_issues?: number;
        State?: Milestone2State;
        Title?: string;
        Url?: string;
    }
    
    export class Pull_request implements IPull_request {
        Diff_url?: string;
        Html_url?: string;
        Patch_url?: string;
    
        constructor(data?: IPull_request) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Diff_url = data["diff_url"] !== undefined ? data["diff_url"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Patch_url = data["patch_url"] !== undefined ? data["patch_url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Pull_request {
            let result = new Pull_request();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["diff_url"] = this.Diff_url !== undefined ? this.Diff_url : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["patch_url"] = this.Patch_url !== undefined ? this.Patch_url : <any>null;
            return data; 
        }
    }
    
    export interface IPull_request {
        Diff_url?: string;
        Html_url?: string;
        Patch_url?: string;
    }
    
    export enum State8 {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export class User9 implements IUser9 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser9) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User9 {
            let result = new User9();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser9 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Owner3 implements IOwner3 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner3 {
            let result = new Owner3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner3 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class User10 implements IUser10 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser10) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User10 {
            let result = new User10();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser10 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Owner4 implements IOwner4 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner4 {
            let result = new Owner4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner4 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Commit7 implements ICommit7 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: ICommit7) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit7 {
            let result = new Commit7();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit7 {
        Sha?: string;
        Url?: string;
    }
    
    export class User11 implements IUser11 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser11) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User11 {
            let result = new User11();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser11 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Author7 implements IAuthor7 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IAuthor7) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author7 {
            let result = new Author7();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor7 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Commit8 implements ICommit8 {
        Author?: Author17;
        Committer?: Committer14;
        Message?: string;
        Tree?: Tree9;
        Url?: string;
    
        constructor(data?: ICommit8) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author17.fromJS(data["author"]) : <any>null;
                this.Committer = data["committer"] ? Committer14.fromJS(data["committer"]) : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Tree = data["tree"] ? Tree9.fromJS(data["tree"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit8 {
            let result = new Commit8();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["tree"] = this.Tree ? this.Tree.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit8 {
        Author?: Author17;
        Committer?: Committer14;
        Message?: string;
        Tree?: Tree9;
        Url?: string;
    }
    
    export class Committer6 implements ICommitter6 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: ICommitter6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer6 {
            let result = new Committer6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter6 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Parents4 implements IParents4 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: IParents4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Parents4 {
            let result = new Parents4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IParents4 {
        Sha?: string;
        Url?: string;
    }
    
    export class Statuses implements IStatuses {
        Context?: string;
        Created_at?: string;
        Description?: string;
        Id?: number;
        State?: string;
        Target_url?: string;
        Updated_at?: string;
        Url?: string;
    
        constructor(data?: IStatuses) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Context = data["context"] !== undefined ? data["context"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Target_url = data["target_url"] !== undefined ? data["target_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Statuses {
            let result = new Statuses();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["context"] = this.Context !== undefined ? this.Context : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["target_url"] = this.Target_url !== undefined ? this.Target_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IStatuses {
        Context?: string;
        Created_at?: string;
        Description?: string;
        Id?: number;
        State?: string;
        Target_url?: string;
        Updated_at?: string;
        Url?: string;
    }
    
    export class Creator3 implements ICreator3 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: ICreator3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Creator3 {
            let result = new Creator3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICreator3 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Creator4 implements ICreator4 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: ICreator4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Creator4 {
            let result = new Creator4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICreator4 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Owner5 implements IOwner5 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner5 {
            let result = new Owner5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner5 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Object4 implements IObject4 {
        Sha?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IObject4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Object4 {
            let result = new Object4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IObject4 {
        Sha?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Config implements IConfig {
        Content_type?: string;
        Url?: string;
    
        constructor(data?: IConfig) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content_type = data["content_type"] !== undefined ? data["content_type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Config {
            let result = new Config();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content_type"] = this.Content_type !== undefined ? this.Content_type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IConfig {
        Content_type?: string;
        Url?: string;
    }
    
    export enum Events2 {
        Push = <any>"push", 
        Issues = <any>"issues", 
        Issue_comment = <any>"issue_comment", 
        Commit_comment = <any>"commit_comment", 
        Pull_request = <any>"pull_request", 
        Pull_request_review_comment = <any>"pull_request_review_comment", 
        Gollum = <any>"gollum", 
        Watch = <any>"watch", 
        Download = <any>"download", 
        Fork = <any>"fork", 
        Fork_apply = <any>"fork_apply", 
        Member = <any>"member", 
        Public = <any>"public", 
        Team_add = <any>"team_add", 
        Status = <any>"status", 
    }
    
    export class _links7 implements I_links7 {
        Html?: Html3;
        Pull_request?: Pull_request5;
        Self?: Self3;
    
        constructor(data?: I_links7) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Html = data["html"] ? Html3.fromJS(data["html"]) : <any>null;
                this.Pull_request = data["pull_request"] ? Pull_request5.fromJS(data["pull_request"]) : <any>null;
                this.Self = data["self"] ? Self3.fromJS(data["self"]) : <any>null;
            }
        }
    
        static fromJS(data: any): _links7 {
            let result = new _links7();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["html"] = this.Html ? this.Html.toJSON() : <any>null;
            data["pull_request"] = this.Pull_request ? this.Pull_request.toJSON() : <any>null;
            data["self"] = this.Self ? this.Self.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface I_links7 {
        Html?: Html3;
        Pull_request?: Pull_request5;
        Self?: Self3;
    }
    
    export class User12 implements IUser12 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser12) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User12 {
            let result = new User12();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser12 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class _links8 implements I_links8 {
        Comments?: Comments2;
        Html?: Html4;
        Review_comments?: Review_comments2;
        Self?: Self4;
    
        constructor(data?: I_links8) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Comments = data["comments"] ? Comments2.fromJS(data["comments"]) : <any>null;
                this.Html = data["html"] ? Html4.fromJS(data["html"]) : <any>null;
                this.Review_comments = data["review_comments"] ? Review_comments2.fromJS(data["review_comments"]) : <any>null;
                this.Self = data["self"] ? Self4.fromJS(data["self"]) : <any>null;
            }
        }
    
        static fromJS(data: any): _links8 {
            let result = new _links8();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["comments"] = this.Comments ? this.Comments.toJSON() : <any>null;
            data["html"] = this.Html ? this.Html.toJSON() : <any>null;
            data["review_comments"] = this.Review_comments ? this.Review_comments.toJSON() : <any>null;
            data["self"] = this.Self ? this.Self.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface I_links8 {
        Comments?: Comments2;
        Html?: Html4;
        Review_comments?: Review_comments2;
        Self?: Self4;
    }
    
    export class Base2 implements IBase2 {
        Label?: string;
        Ref?: string;
        Repo?: Repo5;
        Sha?: string;
        User?: User21;
    
        constructor(data?: IBase2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Label = data["label"] !== undefined ? data["label"] : <any>null;
                this.Ref = data["ref"] !== undefined ? data["ref"] : <any>null;
                this.Repo = data["repo"] ? Repo5.fromJS(data["repo"]) : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.User = data["user"] ? User21.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Base2 {
            let result = new Base2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["label"] = this.Label !== undefined ? this.Label : <any>null;
            data["ref"] = this.Ref !== undefined ? this.Ref : <any>null;
            data["repo"] = this.Repo ? this.Repo.toJSON() : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IBase2 {
        Label?: string;
        Ref?: string;
        Repo?: Repo5;
        Sha?: string;
        User?: User21;
    }
    
    export class Head2 implements IHead2 {
        Label?: string;
        Ref?: string;
        Repo?: Repo6;
        Sha?: string;
        User?: User22;
    
        constructor(data?: IHead2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Label = data["label"] !== undefined ? data["label"] : <any>null;
                this.Ref = data["ref"] !== undefined ? data["ref"] : <any>null;
                this.Repo = data["repo"] ? Repo6.fromJS(data["repo"]) : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.User = data["user"] ? User22.fromJS(data["user"]) : <any>null;
            }
        }
    
        static fromJS(data: any): Head2 {
            let result = new Head2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["label"] = this.Label !== undefined ? this.Label : <any>null;
            data["ref"] = this.Ref !== undefined ? this.Ref : <any>null;
            data["repo"] = this.Repo ? this.Repo.toJSON() : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["user"] = this.User ? this.User.toJSON() : <any>null;
            return data; 
        }
    }
    
    export interface IHead2 {
        Label?: string;
        Ref?: string;
        Repo?: Repo6;
        Sha?: string;
        User?: User22;
    }
    
    export enum State9 {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export class User13 implements IUser13 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser13) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User13 {
            let result = new User13();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser13 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Assets2 implements IAssets2 {
        Content_type?: string;
        Created_at?: string;
        Download_count?: number;
        Id?: number;
        Label?: string;
        Name?: string;
        Size?: number;
        State?: string;
        Updated_at?: string;
        Uploader?: Uploader4;
        Url?: string;
    
        constructor(data?: IAssets2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content_type = data["content_type"] !== undefined ? data["content_type"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Download_count = data["download_count"] !== undefined ? data["download_count"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Label = data["label"] !== undefined ? data["label"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Uploader = data["uploader"] ? Uploader4.fromJS(data["uploader"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Assets2 {
            let result = new Assets2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content_type"] = this.Content_type !== undefined ? this.Content_type : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["download_count"] = this.Download_count !== undefined ? this.Download_count : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["label"] = this.Label !== undefined ? this.Label : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["uploader"] = this.Uploader ? this.Uploader.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAssets2 {
        Content_type?: string;
        Created_at?: string;
        Download_count?: number;
        Id?: number;
        Label?: string;
        Name?: string;
        Size?: number;
        State?: string;
        Updated_at?: string;
        Uploader?: Uploader4;
        Url?: string;
    }
    
    export class Author8 implements IAuthor8 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IAuthor8) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author8 {
            let result = new Author8();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor8 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Uploader2 implements IUploader2 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IUploader2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Uploader2 {
            let result = new Uploader2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUploader2 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Author9 implements IAuthor9 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IAuthor9) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author9 {
            let result = new Author9();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor9 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Weeks implements IWeeks {
        /** Number of additions. */
        A?: number;
        /** Number of commits. */
        C?: number;
        /** Number of deletions. */
        D?: number;
        /** Start of the week. */
        W?: string;
    
        constructor(data?: IWeeks) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.A = data["a"] !== undefined ? data["a"] : <any>null;
                this.C = data["c"] !== undefined ? data["c"] : <any>null;
                this.D = data["d"] !== undefined ? data["d"] : <any>null;
                this.W = data["w"] !== undefined ? data["w"] : <any>null;
            }
        }
    
        static fromJS(data: any): Weeks {
            let result = new Weeks();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["a"] = this.A !== undefined ? this.A : <any>null;
            data["c"] = this.C !== undefined ? this.C : <any>null;
            data["d"] = this.D !== undefined ? this.D : <any>null;
            data["w"] = this.W !== undefined ? this.W : <any>null;
            return data; 
        }
    }
    
    export interface IWeeks {
        /** Number of additions. */
        A?: number;
        /** Number of commits. */
        C?: number;
        /** Number of deletions. */
        D?: number;
        /** Start of the week. */
        W?: string;
    }
    
    export class Creator5 implements ICreator5 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: ICreator5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Creator5 {
            let result = new Creator5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICreator5 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Language implements ILanguage {
    
        constructor(data?: ILanguage) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
            }
        }
    
        static fromJS(data: any): Language {
            let result = new Language();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            return data; 
        }
    }
    
    export interface ILanguage {
    }
    
    export class Owner6 implements IOwner6 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner6 {
            let result = new Owner6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner6 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Owner7 implements IOwner7 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner7) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner7 {
            let result = new Owner7();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner7 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Organization3 implements IOrganization3 {
        Avatar_url?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOrganization3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Organization3 {
            let result = new Organization3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOrganization3 {
        Avatar_url?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Author10 implements IAuthor10 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IAuthor10) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author10 {
            let result = new Author10();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor10 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Commit9 implements ICommit9 {
        Author?: Author18;
        Committer?: Committer15;
        Message?: string;
        Tree?: Tree10;
        Url?: string;
    
        constructor(data?: ICommit9) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author18.fromJS(data["author"]) : <any>null;
                this.Committer = data["committer"] ? Committer15.fromJS(data["committer"]) : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Tree = data["tree"] ? Tree10.fromJS(data["tree"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit9 {
            let result = new Commit9();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["tree"] = this.Tree ? this.Tree.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit9 {
        Author?: Author18;
        Committer?: Committer15;
        Message?: string;
        Tree?: Tree10;
        Url?: string;
    }
    
    export class Committer7 implements ICommitter7 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: ICommitter7) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer7 {
            let result = new Committer7();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter7 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Parents5 implements IParents5 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: IParents5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Parents5 {
            let result = new Parents5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IParents5 {
        Sha?: string;
        Url?: string;
    }
    
    export class Author11 implements IAuthor11 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor11) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author11 {
            let result = new Author11();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor11 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Committer8 implements ICommitter8 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter8) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer8 {
            let result = new Committer8();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter8 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Tree5 implements ITree5 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: ITree5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree5 {
            let result = new Tree5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree5 {
        Sha?: string;
        Url?: string;
    }
    
    export class Author12 implements IAuthor12 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IAuthor12) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author12 {
            let result = new Author12();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor12 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Commit10 implements ICommit10 {
        Author?: Author19;
        Committer?: Committer16;
        Message?: string;
        Tree?: Tree11;
        Url?: string;
    
        constructor(data?: ICommit10) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author19.fromJS(data["author"]) : <any>null;
                this.Committer = data["committer"] ? Committer16.fromJS(data["committer"]) : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Tree = data["tree"] ? Tree11.fromJS(data["tree"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit10 {
            let result = new Commit10();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["tree"] = this.Tree ? this.Tree.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit10 {
        Author?: Author19;
        Committer?: Committer16;
        Message?: string;
        Tree?: Tree11;
        Url?: string;
    }
    
    export class Committer9 implements ICommitter9 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: ICommitter9) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer9 {
            let result = new Committer9();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter9 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Parents6 implements IParents6 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: IParents6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Parents6 {
            let result = new Parents6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IParents6 {
        Sha?: string;
        Url?: string;
    }
    
    export class Author13 implements IAuthor13 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IAuthor13) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author13 {
            let result = new Author13();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor13 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Commit11 implements ICommit11 {
        Author?: Author20;
        Committer?: Committer17;
        Message?: string;
        Tree?: Tree12;
        Url?: string;
    
        constructor(data?: ICommit11) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Author = data["author"] ? Author20.fromJS(data["author"]) : <any>null;
                this.Committer = data["committer"] ? Committer17.fromJS(data["committer"]) : <any>null;
                this.Message = data["message"] !== undefined ? data["message"] : <any>null;
                this.Tree = data["tree"] ? Tree12.fromJS(data["tree"]) : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Commit11 {
            let result = new Commit11();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["author"] = this.Author ? this.Author.toJSON() : <any>null;
            data["committer"] = this.Committer ? this.Committer.toJSON() : <any>null;
            data["message"] = this.Message !== undefined ? this.Message : <any>null;
            data["tree"] = this.Tree ? this.Tree.toJSON() : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommit11 {
        Author?: Author20;
        Committer?: Committer17;
        Message?: string;
        Tree?: Tree12;
        Url?: string;
    }
    
    export class Committer10 implements ICommitter10 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: ICommitter10) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer10 {
            let result = new Committer10();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter10 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Parents7 implements IParents7 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: IParents7) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Parents7 {
            let result = new Parents7();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IParents7 {
        Sha?: string;
        Url?: string;
    }
    
    export class Author14 implements IAuthor14 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor14) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author14 {
            let result = new Author14();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor14 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Committer11 implements ICommitter11 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter11) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer11 {
            let result = new Committer11();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter11 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Parents8 implements IParents8 {
        Html_url?: string;
        Sha?: string;
        Url?: string;
    
        constructor(data?: IParents8) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Parents8 {
            let result = new Parents8();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IParents8 {
        Html_url?: string;
        Sha?: string;
        Url?: string;
    }
    
    export class Tree6 implements ITree6 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: ITree6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree6 {
            let result = new Tree6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree6 {
        Sha?: string;
        Url?: string;
    }
    
    export class _links9 implements I_links9 {
        Git?: string;
        Html?: string;
        Self?: string;
    
        constructor(data?: I_links9) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Git = data["git"] !== undefined ? data["git"] : <any>null;
                this.Html = data["html"] !== undefined ? data["html"] : <any>null;
                this.Self = data["self"] !== undefined ? data["self"] : <any>null;
            }
        }
    
        static fromJS(data: any): _links9 {
            let result = new _links9();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["git"] = this.Git !== undefined ? this.Git : <any>null;
            data["html"] = this.Html !== undefined ? this.Html : <any>null;
            data["self"] = this.Self !== undefined ? this.Self : <any>null;
            return data; 
        }
    }
    
    export interface I_links9 {
        Git?: string;
        Html?: string;
        Self?: string;
    }
    
    export class Author15 implements IAuthor15 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor15) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author15 {
            let result = new Author15();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor15 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Committer12 implements ICommitter12 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter12) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer12 {
            let result = new Committer12();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter12 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Parents9 implements IParents9 {
        Html_url?: string;
        Sha?: string;
        Url?: string;
    
        constructor(data?: IParents9) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Parents9 {
            let result = new Parents9();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IParents9 {
        Html_url?: string;
        Sha?: string;
        Url?: string;
    }
    
    export class Tree7 implements ITree7 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: ITree7) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree7 {
            let result = new Tree7();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree7 {
        Sha?: string;
        Url?: string;
    }
    
    export class Assignee2 implements IAssignee2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IAssignee2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Assignee2 {
            let result = new Assignee2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IAssignee2 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Labels2 implements ILabels2 {
        Color?: string;
        Name?: string;
        Url?: string;
    
        constructor(data?: ILabels2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Color = data["color"] !== undefined ? data["color"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Labels2 {
            let result = new Labels2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["color"] = this.Color !== undefined ? this.Color : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ILabels2 {
        Color?: string;
        Name?: string;
        Url?: string;
    }
    
    export class Milestone3 implements IMilestone3 {
        Closed_issues?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Creator?: Creator7;
        Description?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Due_on?: string;
        Number?: number;
        Open_issues?: number;
        State?: Milestone3State;
        Title?: string;
        Url?: string;
    
        constructor(data?: IMilestone3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Closed_issues = data["closed_issues"] !== undefined ? data["closed_issues"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Creator = data["creator"] ? Creator7.fromJS(data["creator"]) : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Due_on = data["due_on"] !== undefined ? data["due_on"] : <any>null;
                this.Number = data["number"] !== undefined ? data["number"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.State = data["state"] !== undefined ? data["state"] : <any>null;
                this.Title = data["title"] !== undefined ? data["title"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Milestone3 {
            let result = new Milestone3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["closed_issues"] = this.Closed_issues !== undefined ? this.Closed_issues : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["creator"] = this.Creator ? this.Creator.toJSON() : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["due_on"] = this.Due_on !== undefined ? this.Due_on : <any>null;
            data["number"] = this.Number !== undefined ? this.Number : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["state"] = this.State !== undefined ? this.State : <any>null;
            data["title"] = this.Title !== undefined ? this.Title : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IMilestone3 {
        Closed_issues?: number;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Creator?: Creator7;
        Description?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Due_on?: string;
        Number?: number;
        Open_issues?: number;
        State?: Milestone3State;
        Title?: string;
        Url?: string;
    }
    
    export class Pull_request2 implements IPull_request2 {
        Diff_url?: string;
        Html_url?: string;
        Patch_url?: string;
    
        constructor(data?: IPull_request2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Diff_url = data["diff_url"] !== undefined ? data["diff_url"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Patch_url = data["patch_url"] !== undefined ? data["patch_url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Pull_request2 {
            let result = new Pull_request2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["diff_url"] = this.Diff_url !== undefined ? this.Diff_url : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["patch_url"] = this.Patch_url !== undefined ? this.Patch_url : <any>null;
            return data; 
        }
    }
    
    export interface IPull_request2 {
        Diff_url?: string;
        Html_url?: string;
        Patch_url?: string;
    }
    
    export enum Issue2State {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export class User14 implements IUser14 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser14) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User14 {
            let result = new User14();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser14 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Current_user implements ICurrent_user {
        Href?: string;
        Type?: string;
    
        constructor(data?: ICurrent_user) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
            }
        }
    
        static fromJS(data: any): Current_user {
            let result = new Current_user();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            return data; 
        }
    }
    
    export interface ICurrent_user {
        Href?: string;
        Type?: string;
    }
    
    export class Current_user_actor implements ICurrent_user_actor {
        Href?: string;
        Type?: string;
    
        constructor(data?: ICurrent_user_actor) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
            }
        }
    
        static fromJS(data: any): Current_user_actor {
            let result = new Current_user_actor();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            return data; 
        }
    }
    
    export interface ICurrent_user_actor {
        Href?: string;
        Type?: string;
    }
    
    export class Current_user_organization implements ICurrent_user_organization {
        Href?: string;
        Type?: string;
    
        constructor(data?: ICurrent_user_organization) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
            }
        }
    
        static fromJS(data: any): Current_user_organization {
            let result = new Current_user_organization();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            return data; 
        }
    }
    
    export interface ICurrent_user_organization {
        Href?: string;
        Type?: string;
    }
    
    export class Current_user_public implements ICurrent_user_public {
        Href?: string;
        Type?: string;
    
        constructor(data?: ICurrent_user_public) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
            }
        }
    
        static fromJS(data: any): Current_user_public {
            let result = new Current_user_public();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            return data; 
        }
    }
    
    export interface ICurrent_user_public {
        Href?: string;
        Type?: string;
    }
    
    export class Timeline implements ITimeline {
        Href?: string;
        Type?: string;
    
        constructor(data?: ITimeline) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
            }
        }
    
        static fromJS(data: any): Timeline {
            let result = new Timeline();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            return data; 
        }
    }
    
    export interface ITimeline {
        Href?: string;
        Type?: string;
    }
    
    export class User15 implements IUser15 {
        Href?: string;
        Type?: string;
    
        constructor(data?: IUser15) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
            }
        }
    
        static fromJS(data: any): User15 {
            let result = new User15();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            return data; 
        }
    }
    
    export interface IUser15 {
        Href?: string;
        Type?: string;
    }
    
    export class RingErl implements IRingErl {
        Filename?: string;
        Raw_url?: string;
        Size?: number;
    
        constructor(data?: IRingErl) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Filename = data["filename"] !== undefined ? data["filename"] : <any>null;
                this.Raw_url = data["raw_url"] !== undefined ? data["raw_url"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
            }
        }
    
        static fromJS(data: any): RingErl {
            let result = new RingErl();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["filename"] = this.Filename !== undefined ? this.Filename : <any>null;
            data["raw_url"] = this.Raw_url !== undefined ? this.Raw_url : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            return data; 
        }
    }
    
    export interface IRingErl {
        Filename?: string;
        Raw_url?: string;
        Size?: number;
    }
    
    export class User16 implements IUser16 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser16) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User16 {
            let result = new User16();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser16 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Change_status implements IChange_status {
        Additions?: number;
        Deletions?: number;
        Total?: number;
    
        constructor(data?: IChange_status) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Additions = data["additions"] !== undefined ? data["additions"] : <any>null;
                this.Deletions = data["deletions"] !== undefined ? data["deletions"] : <any>null;
                this.Total = data["total"] !== undefined ? data["total"] : <any>null;
            }
        }
    
        static fromJS(data: any): Change_status {
            let result = new Change_status();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["additions"] = this.Additions !== undefined ? this.Additions : <any>null;
            data["deletions"] = this.Deletions !== undefined ? this.Deletions : <any>null;
            data["total"] = this.Total !== undefined ? this.Total : <any>null;
            return data; 
        }
    }
    
    export interface IChange_status {
        Additions?: number;
        Deletions?: number;
        Total?: number;
    }
    
    export class User17 implements IUser17 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser17) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User17 {
            let result = new User17();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser17 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Author16 implements IAuthor16 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor16) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author16 {
            let result = new Author16();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor16 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Committer13 implements ICommitter13 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter13) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer13 {
            let result = new Committer13();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter13 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Tree8 implements ITree8 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: ITree8) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree8 {
            let result = new Tree8();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree8 {
        Sha?: string;
        Url?: string;
    }
    
    export class Owner8 implements IOwner8 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner8) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner8 {
            let result = new Owner8();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner8 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class File1Txt implements IFile1Txt {
        Content?: string;
    
        constructor(data?: IFile1Txt) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content = data["content"] !== undefined ? data["content"] : <any>null;
            }
        }
    
        static fromJS(data: any): File1Txt {
            let result = new File1Txt();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content"] = this.Content !== undefined ? this.Content : <any>null;
            return data; 
        }
    }
    
    export interface IFile1Txt {
        Content?: string;
    }
    
    export class New_fileTxt implements INew_fileTxt {
        Content?: string;
    
        constructor(data?: INew_fileTxt) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content = data["content"] !== undefined ? data["content"] : <any>null;
            }
        }
    
        static fromJS(data: any): New_fileTxt {
            let result = new New_fileTxt();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content"] = this.Content !== undefined ? this.Content : <any>null;
            return data; 
        }
    }
    
    export interface INew_fileTxt {
        Content?: string;
    }
    
    export class Old_nameTxt implements IOld_nameTxt {
        Content?: string;
        Filename?: string;
    
        constructor(data?: IOld_nameTxt) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content = data["content"] !== undefined ? data["content"] : <any>null;
                this.Filename = data["filename"] !== undefined ? data["filename"] : <any>null;
            }
        }
    
        static fromJS(data: any): Old_nameTxt {
            let result = new Old_nameTxt();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content"] = this.Content !== undefined ? this.Content : <any>null;
            data["filename"] = this.Filename !== undefined ? this.Filename : <any>null;
            return data; 
        }
    }
    
    export interface IOld_nameTxt {
        Content?: string;
        Filename?: string;
    }
    
    export class File1Txt2 implements IFile1Txt2 {
        Content?: string;
    
        constructor(data?: IFile1Txt2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Content = data["content"] !== undefined ? data["content"] : <any>null;
            }
        }
    
        static fromJS(data: any): File1Txt2 {
            let result = new File1Txt2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["content"] = this.Content !== undefined ? this.Content : <any>null;
            return data; 
        }
    }
    
    export interface IFile1Txt2 {
        Content?: string;
    }
    
    export class Comments implements IComments {
        Href?: string;
    
        constructor(data?: IComments) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Comments {
            let result = new Comments();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface IComments {
        Href?: string;
    }
    
    export class Html implements IHtml {
        Href?: string;
    
        constructor(data?: IHtml) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Html {
            let result = new Html();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface IHtml {
        Href?: string;
    }
    
    export class Review_comments implements IReview_comments {
        Href?: string;
    
        constructor(data?: IReview_comments) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Review_comments {
            let result = new Review_comments();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface IReview_comments {
        Href?: string;
    }
    
    export class Self implements ISelf {
        Href?: string;
    
        constructor(data?: ISelf) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Self {
            let result = new Self();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface ISelf {
        Href?: string;
    }
    
    export class Repo3 implements IRepo3 {
        Clone_url?: string;
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: Language2;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner12;
        Private?: boolean;
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IRepo3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner12.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Repo3 {
            let result = new Repo3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IRepo3 {
        Clone_url?: string;
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: Language2;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner12;
        Private?: boolean;
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class User18 implements IUser18 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser18) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User18 {
            let result = new User18();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser18 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Repo4 implements IRepo4 {
        Clone_url?: string;
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: Language3;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner13;
        Private?: boolean;
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IRepo4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner13.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Repo4 {
            let result = new Repo4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IRepo4 {
        Clone_url?: string;
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: Language3;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner13;
        Private?: boolean;
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class User19 implements IUser19 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser19) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User19 {
            let result = new User19();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser19 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Html2 implements IHtml2 {
        Href?: string;
    
        constructor(data?: IHtml2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Html2 {
            let result = new Html2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface IHtml2 {
        Href?: string;
    }
    
    export class Pull_request3 implements IPull_request3 {
        Href?: string;
    
        constructor(data?: IPull_request3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Pull_request3 {
            let result = new Pull_request3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface IPull_request3 {
        Href?: string;
    }
    
    export class Self2 implements ISelf2 {
        Href?: string;
    
        constructor(data?: ISelf2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Self2 {
            let result = new Self2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface ISelf2 {
        Href?: string;
    }
    
    export class Uploader3 implements IUploader3 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IUploader3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Uploader3 {
            let result = new Uploader3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUploader3 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Owner9 implements IOwner9 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner9) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner9 {
            let result = new Owner9();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner9 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Owner10 implements IOwner10 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner10) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner10 {
            let result = new Owner10();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner10 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Repository2 implements IRepository2 {
        Archive_url?: string;
        Assignees_url?: string;
        Blobs_url?: string;
        Branches_url?: string;
        Collaborators_url?: string;
        Comments_url?: string;
        Commits_url?: string;
        Compare_url?: string;
        Contents_url?: string;
        Contributors_url?: string;
        Description?: string;
        Downloads_url?: string;
        Events_url?: string;
        Fork?: boolean;
        Forks_url?: string;
        Full_name?: string;
        Git_commits_url?: string;
        Git_refs_url?: string;
        Git_tags_url?: string;
        Hooks_url?: string;
        Html_url?: string;
        Id?: number;
        Issue_comment_url?: string;
        Issue_events_url?: string;
        Issues_url?: string;
        Keys_url?: string;
        Labels_url?: string;
        Languages_url?: string;
        Merges_url?: string;
        Milestones_url?: string;
        Name?: string;
        Notifications_url?: string;
        Owner?: Owner14;
        Private?: boolean;
        Pulls_url?: string;
        Stargazers_url?: string;
        Statuses_url?: string;
        Subscribers_url?: string;
        Subscription_url?: string;
        Tags_url?: string;
        Teams_url?: string;
        Trees_url?: string;
        Url?: string;
    
        constructor(data?: IRepository2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Archive_url = data["archive_url"] !== undefined ? data["archive_url"] : <any>null;
                this.Assignees_url = data["assignees_url"] !== undefined ? data["assignees_url"] : <any>null;
                this.Blobs_url = data["blobs_url"] !== undefined ? data["blobs_url"] : <any>null;
                this.Branches_url = data["branches_url"] !== undefined ? data["branches_url"] : <any>null;
                this.Collaborators_url = data["collaborators_url"] !== undefined ? data["collaborators_url"] : <any>null;
                this.Comments_url = data["comments_url"] !== undefined ? data["comments_url"] : <any>null;
                this.Commits_url = data["commits_url"] !== undefined ? data["commits_url"] : <any>null;
                this.Compare_url = data["compare_url"] !== undefined ? data["compare_url"] : <any>null;
                this.Contents_url = data["contents_url"] !== undefined ? data["contents_url"] : <any>null;
                this.Contributors_url = data["contributors_url"] !== undefined ? data["contributors_url"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Downloads_url = data["downloads_url"] !== undefined ? data["downloads_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks_url = data["forks_url"] !== undefined ? data["forks_url"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_commits_url = data["git_commits_url"] !== undefined ? data["git_commits_url"] : <any>null;
                this.Git_refs_url = data["git_refs_url"] !== undefined ? data["git_refs_url"] : <any>null;
                this.Git_tags_url = data["git_tags_url"] !== undefined ? data["git_tags_url"] : <any>null;
                this.Hooks_url = data["hooks_url"] !== undefined ? data["hooks_url"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Issue_comment_url = data["issue_comment_url"] !== undefined ? data["issue_comment_url"] : <any>null;
                this.Issue_events_url = data["issue_events_url"] !== undefined ? data["issue_events_url"] : <any>null;
                this.Issues_url = data["issues_url"] !== undefined ? data["issues_url"] : <any>null;
                this.Keys_url = data["keys_url"] !== undefined ? data["keys_url"] : <any>null;
                this.Labels_url = data["labels_url"] !== undefined ? data["labels_url"] : <any>null;
                this.Languages_url = data["languages_url"] !== undefined ? data["languages_url"] : <any>null;
                this.Merges_url = data["merges_url"] !== undefined ? data["merges_url"] : <any>null;
                this.Milestones_url = data["milestones_url"] !== undefined ? data["milestones_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Notifications_url = data["notifications_url"] !== undefined ? data["notifications_url"] : <any>null;
                this.Owner = data["owner"] ? Owner14.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pulls_url = data["pulls_url"] !== undefined ? data["pulls_url"] : <any>null;
                this.Stargazers_url = data["stargazers_url"] !== undefined ? data["stargazers_url"] : <any>null;
                this.Statuses_url = data["statuses_url"] !== undefined ? data["statuses_url"] : <any>null;
                this.Subscribers_url = data["subscribers_url"] !== undefined ? data["subscribers_url"] : <any>null;
                this.Subscription_url = data["subscription_url"] !== undefined ? data["subscription_url"] : <any>null;
                this.Tags_url = data["tags_url"] !== undefined ? data["tags_url"] : <any>null;
                this.Teams_url = data["teams_url"] !== undefined ? data["teams_url"] : <any>null;
                this.Trees_url = data["trees_url"] !== undefined ? data["trees_url"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Repository2 {
            let result = new Repository2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["archive_url"] = this.Archive_url !== undefined ? this.Archive_url : <any>null;
            data["assignees_url"] = this.Assignees_url !== undefined ? this.Assignees_url : <any>null;
            data["blobs_url"] = this.Blobs_url !== undefined ? this.Blobs_url : <any>null;
            data["branches_url"] = this.Branches_url !== undefined ? this.Branches_url : <any>null;
            data["collaborators_url"] = this.Collaborators_url !== undefined ? this.Collaborators_url : <any>null;
            data["comments_url"] = this.Comments_url !== undefined ? this.Comments_url : <any>null;
            data["commits_url"] = this.Commits_url !== undefined ? this.Commits_url : <any>null;
            data["compare_url"] = this.Compare_url !== undefined ? this.Compare_url : <any>null;
            data["contents_url"] = this.Contents_url !== undefined ? this.Contents_url : <any>null;
            data["contributors_url"] = this.Contributors_url !== undefined ? this.Contributors_url : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["downloads_url"] = this.Downloads_url !== undefined ? this.Downloads_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks_url"] = this.Forks_url !== undefined ? this.Forks_url : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_commits_url"] = this.Git_commits_url !== undefined ? this.Git_commits_url : <any>null;
            data["git_refs_url"] = this.Git_refs_url !== undefined ? this.Git_refs_url : <any>null;
            data["git_tags_url"] = this.Git_tags_url !== undefined ? this.Git_tags_url : <any>null;
            data["hooks_url"] = this.Hooks_url !== undefined ? this.Hooks_url : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["issue_comment_url"] = this.Issue_comment_url !== undefined ? this.Issue_comment_url : <any>null;
            data["issue_events_url"] = this.Issue_events_url !== undefined ? this.Issue_events_url : <any>null;
            data["issues_url"] = this.Issues_url !== undefined ? this.Issues_url : <any>null;
            data["keys_url"] = this.Keys_url !== undefined ? this.Keys_url : <any>null;
            data["labels_url"] = this.Labels_url !== undefined ? this.Labels_url : <any>null;
            data["languages_url"] = this.Languages_url !== undefined ? this.Languages_url : <any>null;
            data["merges_url"] = this.Merges_url !== undefined ? this.Merges_url : <any>null;
            data["milestones_url"] = this.Milestones_url !== undefined ? this.Milestones_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["notifications_url"] = this.Notifications_url !== undefined ? this.Notifications_url : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pulls_url"] = this.Pulls_url !== undefined ? this.Pulls_url : <any>null;
            data["stargazers_url"] = this.Stargazers_url !== undefined ? this.Stargazers_url : <any>null;
            data["statuses_url"] = this.Statuses_url !== undefined ? this.Statuses_url : <any>null;
            data["subscribers_url"] = this.Subscribers_url !== undefined ? this.Subscribers_url : <any>null;
            data["subscription_url"] = this.Subscription_url !== undefined ? this.Subscription_url : <any>null;
            data["tags_url"] = this.Tags_url !== undefined ? this.Tags_url : <any>null;
            data["teams_url"] = this.Teams_url !== undefined ? this.Teams_url : <any>null;
            data["trees_url"] = this.Trees_url !== undefined ? this.Trees_url : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IRepository2 {
        Archive_url?: string;
        Assignees_url?: string;
        Blobs_url?: string;
        Branches_url?: string;
        Collaborators_url?: string;
        Comments_url?: string;
        Commits_url?: string;
        Compare_url?: string;
        Contents_url?: string;
        Contributors_url?: string;
        Description?: string;
        Downloads_url?: string;
        Events_url?: string;
        Fork?: boolean;
        Forks_url?: string;
        Full_name?: string;
        Git_commits_url?: string;
        Git_refs_url?: string;
        Git_tags_url?: string;
        Hooks_url?: string;
        Html_url?: string;
        Id?: number;
        Issue_comment_url?: string;
        Issue_events_url?: string;
        Issues_url?: string;
        Keys_url?: string;
        Labels_url?: string;
        Languages_url?: string;
        Merges_url?: string;
        Milestones_url?: string;
        Name?: string;
        Notifications_url?: string;
        Owner?: Owner14;
        Private?: boolean;
        Pulls_url?: string;
        Stargazers_url?: string;
        Statuses_url?: string;
        Subscribers_url?: string;
        Subscription_url?: string;
        Tags_url?: string;
        Teams_url?: string;
        Trees_url?: string;
        Url?: string;
    }
    
    export class Assignee3 implements IAssignee3 {
    
        constructor(data?: IAssignee3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
            }
        }
    
        static fromJS(data: any): Assignee3 {
            let result = new Assignee3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            return data; 
        }
    }
    
    export interface IAssignee3 {
    }
    
    export class Closed_at implements IClosed_at {
    
        constructor(data?: IClosed_at) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
            }
        }
    
        static fromJS(data: any): Closed_at {
            let result = new Closed_at();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            return data; 
        }
    }
    
    export interface IClosed_at {
    }
    
    export class Labels3 implements ILabels3 {
        Color?: string;
        Name?: string;
        Url?: string;
    
        constructor(data?: ILabels3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Color = data["color"] !== undefined ? data["color"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Labels3 {
            let result = new Labels3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["color"] = this.Color !== undefined ? this.Color : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ILabels3 {
        Color?: string;
        Name?: string;
        Url?: string;
    }
    
    export class Milestone4 implements IMilestone4 {
    
        constructor(data?: IMilestone4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
            }
        }
    
        static fromJS(data: any): Milestone4 {
            let result = new Milestone4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            return data; 
        }
    }
    
    export interface IMilestone4 {
    }
    
    export class Pull_request4 implements IPull_request4 {
        Diff_url?: Diff_url;
        Html_url?: Html_url;
        Patch_url?: Patch_url;
    
        constructor(data?: IPull_request4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Diff_url = data["diff_url"] !== undefined ? data["diff_url"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Patch_url = data["patch_url"] !== undefined ? data["patch_url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Pull_request4 {
            let result = new Pull_request4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["diff_url"] = this.Diff_url !== undefined ? this.Diff_url : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["patch_url"] = this.Patch_url !== undefined ? this.Patch_url : <any>null;
            return data; 
        }
    }
    
    export interface IPull_request4 {
        Diff_url?: Diff_url;
        Html_url?: Html_url;
        Patch_url?: Patch_url;
    }
    
    export class User20 implements IUser20 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IUser20) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User20 {
            let result = new User20();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser20 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Owner11 implements IOwner11 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Received_events_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IOwner11) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner11 {
            let result = new Owner11();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner11 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Received_events_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export enum Tree4Mode {
        _100644 = <any>"100644", 
        _100755 = <any>"100755", 
        _040000 = <any>"040000", 
        _160000 = <any>"160000", 
        _120000 = <any>"120000", 
    }
    
    export enum Tree4Type {
        Blob = <any>"blob", 
        Tree = <any>"tree", 
        Commit = <any>"commit", 
    }
    
    export class RingErl2 implements IRingErl2 {
        Filename?: string;
        Raw_url?: string;
        Size?: number;
    
        constructor(data?: IRingErl2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Filename = data["filename"] !== undefined ? data["filename"] : <any>null;
                this.Raw_url = data["raw_url"] !== undefined ? data["raw_url"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
            }
        }
    
        static fromJS(data: any): RingErl2 {
            let result = new RingErl2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["filename"] = this.Filename !== undefined ? this.Filename : <any>null;
            data["raw_url"] = this.Raw_url !== undefined ? this.Raw_url : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            return data; 
        }
    }
    
    export interface IRingErl2 {
        Filename?: string;
        Raw_url?: string;
        Size?: number;
    }
    
    export class Creator6 implements ICreator6 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: ICreator6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Creator6 {
            let result = new Creator6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICreator6 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export enum Milestone2State {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export class Author17 implements IAuthor17 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor17) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author17 {
            let result = new Author17();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor17 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Committer14 implements ICommitter14 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter14) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer14 {
            let result = new Committer14();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter14 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Tree9 implements ITree9 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: ITree9) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree9 {
            let result = new Tree9();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree9 {
        Sha?: string;
        Url?: string;
    }
    
    export class Html3 implements IHtml3 {
        Href?: string;
    
        constructor(data?: IHtml3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Html3 {
            let result = new Html3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface IHtml3 {
        Href?: string;
    }
    
    export class Pull_request5 implements IPull_request5 {
        Href?: string;
    
        constructor(data?: IPull_request5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Pull_request5 {
            let result = new Pull_request5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface IPull_request5 {
        Href?: string;
    }
    
    export class Self3 implements ISelf3 {
        Href?: string;
    
        constructor(data?: ISelf3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Self3 {
            let result = new Self3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface ISelf3 {
        Href?: string;
    }
    
    export class Comments2 implements IComments2 {
        Href?: string;
    
        constructor(data?: IComments2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Comments2 {
            let result = new Comments2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface IComments2 {
        Href?: string;
    }
    
    export class Html4 implements IHtml4 {
        Href?: string;
    
        constructor(data?: IHtml4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Html4 {
            let result = new Html4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface IHtml4 {
        Href?: string;
    }
    
    export class Review_comments2 implements IReview_comments2 {
        Href?: string;
    
        constructor(data?: IReview_comments2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Review_comments2 {
            let result = new Review_comments2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface IReview_comments2 {
        Href?: string;
    }
    
    export class Self4 implements ISelf4 {
        Href?: string;
    
        constructor(data?: ISelf4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Href = data["href"] !== undefined ? data["href"] : <any>null;
            }
        }
    
        static fromJS(data: any): Self4 {
            let result = new Self4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["href"] = this.Href !== undefined ? this.Href : <any>null;
            return data; 
        }
    }
    
    export interface ISelf4 {
        Href?: string;
    }
    
    export class Repo5 implements IRepo5 {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner15;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IRepo5) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner15.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Repo5 {
            let result = new Repo5();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IRepo5 {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner15;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class User21 implements IUser21 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser21) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User21 {
            let result = new User21();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser21 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Repo6 implements IRepo6 {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner16;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    
        constructor(data?: IRepo6) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Clone_url = data["clone_url"] !== undefined ? data["clone_url"] : <any>null;
                this.Created_at = data["created_at"] !== undefined ? data["created_at"] : <any>null;
                this.Description = data["description"] !== undefined ? data["description"] : <any>null;
                this.Fork = data["fork"] !== undefined ? data["fork"] : <any>null;
                this.Forks = data["forks"] !== undefined ? data["forks"] : <any>null;
                this.Forks_count = data["forks_count"] !== undefined ? data["forks_count"] : <any>null;
                this.Full_name = data["full_name"] !== undefined ? data["full_name"] : <any>null;
                this.Git_url = data["git_url"] !== undefined ? data["git_url"] : <any>null;
                this.Homepage = data["homepage"] !== undefined ? data["homepage"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Language = data["language"] !== undefined ? data["language"] : <any>null;
                this.Master_branch = data["master_branch"] !== undefined ? data["master_branch"] : <any>null;
                this.Mirror_url = data["mirror_url"] !== undefined ? data["mirror_url"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
                this.Open_issues = data["open_issues"] !== undefined ? data["open_issues"] : <any>null;
                this.Open_issues_count = data["open_issues_count"] !== undefined ? data["open_issues_count"] : <any>null;
                this.Owner = data["owner"] ? Owner16.fromJS(data["owner"]) : <any>null;
                this.Private = data["private"] !== undefined ? data["private"] : <any>null;
                this.Pushed_at = data["pushed_at"] !== undefined ? data["pushed_at"] : <any>null;
                this.Size = data["size"] !== undefined ? data["size"] : <any>null;
                this.Ssh_url = data["ssh_url"] !== undefined ? data["ssh_url"] : <any>null;
                this.Svn_url = data["svn_url"] !== undefined ? data["svn_url"] : <any>null;
                this.Updated_at = data["updated_at"] !== undefined ? data["updated_at"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
                this.Watchers = data["watchers"] !== undefined ? data["watchers"] : <any>null;
                this.Watchers_count = data["watchers_count"] !== undefined ? data["watchers_count"] : <any>null;
            }
        }
    
        static fromJS(data: any): Repo6 {
            let result = new Repo6();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["clone_url"] = this.Clone_url !== undefined ? this.Clone_url : <any>null;
            data["created_at"] = this.Created_at !== undefined ? this.Created_at : <any>null;
            data["description"] = this.Description !== undefined ? this.Description : <any>null;
            data["fork"] = this.Fork !== undefined ? this.Fork : <any>null;
            data["forks"] = this.Forks !== undefined ? this.Forks : <any>null;
            data["forks_count"] = this.Forks_count !== undefined ? this.Forks_count : <any>null;
            data["full_name"] = this.Full_name !== undefined ? this.Full_name : <any>null;
            data["git_url"] = this.Git_url !== undefined ? this.Git_url : <any>null;
            data["homepage"] = this.Homepage !== undefined ? this.Homepage : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["language"] = this.Language !== undefined ? this.Language : <any>null;
            data["master_branch"] = this.Master_branch !== undefined ? this.Master_branch : <any>null;
            data["mirror_url"] = this.Mirror_url !== undefined ? this.Mirror_url : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            data["open_issues"] = this.Open_issues !== undefined ? this.Open_issues : <any>null;
            data["open_issues_count"] = this.Open_issues_count !== undefined ? this.Open_issues_count : <any>null;
            data["owner"] = this.Owner ? this.Owner.toJSON() : <any>null;
            data["private"] = this.Private !== undefined ? this.Private : <any>null;
            data["pushed_at"] = this.Pushed_at !== undefined ? this.Pushed_at : <any>null;
            data["size"] = this.Size !== undefined ? this.Size : <any>null;
            data["ssh_url"] = this.Ssh_url !== undefined ? this.Ssh_url : <any>null;
            data["svn_url"] = this.Svn_url !== undefined ? this.Svn_url : <any>null;
            data["updated_at"] = this.Updated_at !== undefined ? this.Updated_at : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            data["watchers"] = this.Watchers !== undefined ? this.Watchers : <any>null;
            data["watchers_count"] = this.Watchers_count !== undefined ? this.Watchers_count : <any>null;
            return data; 
        }
    }
    
    export interface IRepo6 {
        Clone_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Created_at?: string;
        Description?: string;
        Fork?: boolean;
        Forks?: number;
        Forks_count?: number;
        Full_name?: string;
        Git_url?: string;
        Homepage?: string;
        Html_url?: string;
        Id?: number;
        Language?: string;
        Master_branch?: string;
        Mirror_url?: string;
        Name?: string;
        Open_issues?: number;
        Open_issues_count?: number;
        Owner?: Owner16;
        Private?: boolean;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Pushed_at?: string;
        Size?: number;
        Ssh_url?: string;
        Svn_url?: string;
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Updated_at?: string;
        Url?: string;
        Watchers?: number;
        Watchers_count?: number;
    }
    
    export class User22 implements IUser22 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IUser22) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): User22 {
            let result = new User22();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUser22 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Uploader4 implements IUploader4 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IUploader4) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Site_admin = data["site_admin"] !== undefined ? data["site_admin"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Uploader4 {
            let result = new Uploader4();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["site_admin"] = this.Site_admin !== undefined ? this.Site_admin : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IUploader4 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Site_admin?: boolean;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Author18 implements IAuthor18 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor18) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author18 {
            let result = new Author18();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor18 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Committer15 implements ICommitter15 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter15) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer15 {
            let result = new Committer15();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter15 {
        /** ISO 8601 format: YYYY-MM-DDTHH:MM:SSZ */
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Tree10 implements ITree10 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: ITree10) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree10 {
            let result = new Tree10();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree10 {
        Sha?: string;
        Url?: string;
    }
    
    export class Author19 implements IAuthor19 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor19) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author19 {
            let result = new Author19();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor19 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Committer16 implements ICommitter16 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter16) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer16 {
            let result = new Committer16();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter16 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Tree11 implements ITree11 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: ITree11) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree11 {
            let result = new Tree11();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree11 {
        Sha?: string;
        Url?: string;
    }
    
    export class Author20 implements IAuthor20 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: IAuthor20) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Author20 {
            let result = new Author20();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface IAuthor20 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Committer17 implements ICommitter17 {
        Date?: string;
        Email?: string;
        Name?: string;
    
        constructor(data?: ICommitter17) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Date = data["date"] !== undefined ? data["date"] : <any>null;
                this.Email = data["email"] !== undefined ? data["email"] : <any>null;
                this.Name = data["name"] !== undefined ? data["name"] : <any>null;
            }
        }
    
        static fromJS(data: any): Committer17 {
            let result = new Committer17();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["date"] = this.Date !== undefined ? this.Date : <any>null;
            data["email"] = this.Email !== undefined ? this.Email : <any>null;
            data["name"] = this.Name !== undefined ? this.Name : <any>null;
            return data; 
        }
    }
    
    export interface ICommitter17 {
        Date?: string;
        Email?: string;
        Name?: string;
    }
    
    export class Tree12 implements ITree12 {
        Sha?: string;
        Url?: string;
    
        constructor(data?: ITree12) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Sha = data["sha"] !== undefined ? data["sha"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Tree12 {
            let result = new Tree12();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["sha"] = this.Sha !== undefined ? this.Sha : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ITree12 {
        Sha?: string;
        Url?: string;
    }
    
    export class Creator7 implements ICreator7 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: ICreator7) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Creator7 {
            let result = new Creator7();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface ICreator7 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export enum Milestone3State {
        Open = <any>"open", 
        Closed = <any>"closed", 
    }
    
    export class Language2 implements ILanguage2 {
    
        constructor(data?: ILanguage2) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
            }
        }
    
        static fromJS(data: any): Language2 {
            let result = new Language2();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            return data; 
        }
    }
    
    export interface ILanguage2 {
    }
    
    export class Owner12 implements IOwner12 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner12) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner12 {
            let result = new Owner12();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner12 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Language3 implements ILanguage3 {
    
        constructor(data?: ILanguage3) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
            }
        }
    
        static fromJS(data: any): Language3 {
            let result = new Language3();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            return data; 
        }
    }
    
    export interface ILanguage3 {
    }
    
    export class Owner13 implements IOwner13 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner13) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner13 {
            let result = new Owner13();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner13 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Owner14 implements IOwner14 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    
        constructor(data?: IOwner14) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Events_url = data["events_url"] !== undefined ? data["events_url"] : <any>null;
                this.Followers_url = data["followers_url"] !== undefined ? data["followers_url"] : <any>null;
                this.Following_url = data["following_url"] !== undefined ? data["following_url"] : <any>null;
                this.Gists_url = data["gists_url"] !== undefined ? data["gists_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Html_url = data["html_url"] !== undefined ? data["html_url"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Organizations_url = data["organizations_url"] !== undefined ? data["organizations_url"] : <any>null;
                this.Received_events_url = data["received_events_url"] !== undefined ? data["received_events_url"] : <any>null;
                this.Repos_url = data["repos_url"] !== undefined ? data["repos_url"] : <any>null;
                this.Starred_url = data["starred_url"] !== undefined ? data["starred_url"] : <any>null;
                this.Subscriptions_url = data["subscriptions_url"] !== undefined ? data["subscriptions_url"] : <any>null;
                this.Type = data["type"] !== undefined ? data["type"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner14 {
            let result = new Owner14();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["events_url"] = this.Events_url !== undefined ? this.Events_url : <any>null;
            data["followers_url"] = this.Followers_url !== undefined ? this.Followers_url : <any>null;
            data["following_url"] = this.Following_url !== undefined ? this.Following_url : <any>null;
            data["gists_url"] = this.Gists_url !== undefined ? this.Gists_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["html_url"] = this.Html_url !== undefined ? this.Html_url : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["organizations_url"] = this.Organizations_url !== undefined ? this.Organizations_url : <any>null;
            data["received_events_url"] = this.Received_events_url !== undefined ? this.Received_events_url : <any>null;
            data["repos_url"] = this.Repos_url !== undefined ? this.Repos_url : <any>null;
            data["starred_url"] = this.Starred_url !== undefined ? this.Starred_url : <any>null;
            data["subscriptions_url"] = this.Subscriptions_url !== undefined ? this.Subscriptions_url : <any>null;
            data["type"] = this.Type !== undefined ? this.Type : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner14 {
        Avatar_url?: string;
        Events_url?: string;
        Followers_url?: string;
        Following_url?: string;
        Gists_url?: string;
        Gravatar_id?: string;
        Html_url?: string;
        Id?: number;
        Login?: string;
        Organizations_url?: string;
        Received_events_url?: string;
        Repos_url?: string;
        Starred_url?: string;
        Subscriptions_url?: string;
        Type?: string;
        Url?: string;
    }
    
    export class Diff_url implements IDiff_url {
    
        constructor(data?: IDiff_url) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
            }
        }
    
        static fromJS(data: any): Diff_url {
            let result = new Diff_url();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            return data; 
        }
    }
    
    export interface IDiff_url {
    }
    
    export class Html_url implements IHtml_url {
    
        constructor(data?: IHtml_url) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
            }
        }
    
        static fromJS(data: any): Html_url {
            let result = new Html_url();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            return data; 
        }
    }
    
    export interface IHtml_url {
    }
    
    export class Patch_url implements IPatch_url {
    
        constructor(data?: IPatch_url) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
            }
        }
    
        static fromJS(data: any): Patch_url {
            let result = new Patch_url();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            return data; 
        }
    }
    
    export interface IPatch_url {
    }
    
    export class Owner15 implements IOwner15 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner15) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner15 {
            let result = new Owner15();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner15 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class Owner16 implements IOwner16 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    
        constructor(data?: IOwner16) {
            if (data) {
                for (var property in data) {
                    if (data.hasOwnProperty(property))
                        (<any>this)[property] = (<any>data)[property];
                }
            }
        }
    
        init(data?: any) {
            if (data) {
                this.Avatar_url = data["avatar_url"] !== undefined ? data["avatar_url"] : <any>null;
                this.Gravatar_id = data["gravatar_id"] !== undefined ? data["gravatar_id"] : <any>null;
                this.Id = data["id"] !== undefined ? data["id"] : <any>null;
                this.Login = data["login"] !== undefined ? data["login"] : <any>null;
                this.Url = data["url"] !== undefined ? data["url"] : <any>null;
            }
        }
    
        static fromJS(data: any): Owner16 {
            let result = new Owner16();
            result.init(data);
            return result;
        }
    
        toJSON(data?: any) {
            data = typeof data === 'object' ? data : {};
            data["avatar_url"] = this.Avatar_url !== undefined ? this.Avatar_url : <any>null;
            data["gravatar_id"] = this.Gravatar_id !== undefined ? this.Gravatar_id : <any>null;
            data["id"] = this.Id !== undefined ? this.Id : <any>null;
            data["login"] = this.Login !== undefined ? this.Login : <any>null;
            data["url"] = this.Url !== undefined ? this.Url : <any>null;
            return data; 
        }
    }
    
    export interface IOwner16 {
        Avatar_url?: string;
        Gravatar_id?: string;
        Id?: number;
        Login?: string;
        Url?: string;
    }
    
    export class SwaggerException extends Error {
        message: string;
        status: number; 
        response: string; 
        headers: { [key: string]: any; };
        result: any; 
    
        constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
            super();
    
            this.message = message;
            this.status = status;
            this.response = response;
            this.headers = headers;
            this.result = result;
        }
    
        protected isSwaggerException = true;
    
        static isSwaggerException(obj: any): obj is SwaggerException {
            return obj.isSwaggerException === true;
        }
    }
    
    function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
        if(result !== null && result !== undefined)
            throw result;
        else
            throw new SwaggerException(message, status, response, headers, null);
    }
}
